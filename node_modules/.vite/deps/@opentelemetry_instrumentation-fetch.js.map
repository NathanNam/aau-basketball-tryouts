{
  "version": 3,
  "sources": ["../../.pnpm/@opentelemetry+instrumentation-fetch@0.208.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-fetch/src/enums/AttributeNames.ts", "../../.pnpm/@opentelemetry+instrumentation-fetch@0.208.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-fetch/src/semconv.ts", "../../.pnpm/@opentelemetry+instrumentation-fetch@0.208.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-fetch/src/utils.ts", "../../.pnpm/@opentelemetry+instrumentation-fetch@0.208.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-fetch/src/version.ts", "../../.pnpm/@opentelemetry+instrumentation-fetch@0.208.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-fetch/src/fetch.ts"],
  "sourcesContent": ["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/trace/semantic_conventions/http.md\n */\nexport enum AttributeNames {\n  COMPONENT = 'component',\n  HTTP_STATUS_TEXT = 'http.status_text',\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*\n * This file contains a copy of unstable semantic convention definitions\n * used by this package.\n * @see https://github.com/open-telemetry/opentelemetry-js/tree/main/semantic-conventions#unstable-semconv\n */\n\n/**\n * Deprecated, use one of `server.address`, `client.address` or `http.request.header.host` instead, depending on the usage.\n *\n * @example www.example.org\n *\n * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.\n *\n * @deprecated Replaced by one of `server.address`, `client.address` or `http.request.header.host`, depending on the usage.\n */\nexport const ATTR_HTTP_HOST = 'http.host' as const;\n\n/**\n * Deprecated, use `http.request.method` instead.\n *\n * @example GET\n * @example POST\n * @example HEAD\n *\n * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.\n *\n * @deprecated Replaced by `http.request.method`.\n */\nexport const ATTR_HTTP_METHOD = 'http.method' as const;\n\n/**\n * The size of the request payload body in bytes. This is the number of bytes transferred excluding headers and is often, but not always, present as the [Content-Length](https://www.rfc-editor.org/rfc/rfc9110.html#field.content-length) header. For requests using transport encoding, this should be the compressed size.\n *\n * @example 3495\n *\n * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.\n */\nexport const ATTR_HTTP_REQUEST_BODY_SIZE = 'http.request.body.size' as const;\n\n/**\n * Deprecated, use `http.request.body.size` instead.\n *\n * @example 5493\n *\n * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.\n *\n * @deprecated Replaced by `http.request.body.size`.\n */\nexport const ATTR_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED =\n  'http.request_content_length_uncompressed' as const;\n\n/**\n * Deprecated, use `http.response.header.<key>` instead.\n *\n * @example 3495\n *\n * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.\n *\n * @deprecated Replaced by `http.response.header.<key>`.\n */\nexport const ATTR_HTTP_RESPONSE_CONTENT_LENGTH =\n  'http.response_content_length' as const;\n\n/**\n * Deprecated, use `url.scheme` instead.\n *\n * @example http\n * @example https\n *\n * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.\n *\n * @deprecated Replaced by `url.scheme` instead.\n */\nexport const ATTR_HTTP_SCHEME = 'http.scheme' as const;\n\n/**\n * Deprecated, use `http.response.status_code` instead.\n *\n * @example 200\n *\n * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.\n *\n * @deprecated Replaced by `http.response.status_code`.\n */\nexport const ATTR_HTTP_STATUS_CODE = 'http.status_code' as const;\n\n/**\n * Deprecated, use `url.full` instead.\n *\n * @example https://www.foo.bar/search?q=OpenTelemetry#SemConv\n *\n * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.\n *\n * @deprecated Replaced by `url.full`.\n */\nexport const ATTR_HTTP_URL = 'http.url' as const;\n\n/**\n * Deprecated, use `user_agent.original` instead.\n *\n * @example CERN-LineMode/2.15 libwww/2.17b3\n * @example Mozilla/5.0 (iPhone; CPU iPhone OS 14_7_1 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.1.2 Mobile/15E148 Safari/604.1\n *\n * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.\n *\n * @deprecated Replaced by `user_agent.original`.\n */\nexport const ATTR_HTTP_USER_AGENT = 'http.user_agent' as const;\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// Much of the logic here overlaps with the same utils file in opentelemetry-instrumentation-xml-http-request\n// These may be unified in the future.\n\nimport * as api from '@opentelemetry/api';\nimport { getStringListFromEnv } from '@opentelemetry/core';\nimport { URLLike } from '@opentelemetry/sdk-trace-web';\n\nconst DIAG_LOGGER = api.diag.createComponentLogger({\n  namespace: '@opentelemetry/opentelemetry-instrumentation-fetch/utils',\n});\n\n/**\n * Helper function to determine payload content length for fetch requests\n *\n * The fetch API is kinda messy: there are a couple of ways the body can be passed in.\n *\n * In all cases, the body param can be some variation of ReadableStream,\n * and ReadableStreams can only be read once! We want to avoid consuming the body here,\n * because that would mean that the body never gets sent with the actual fetch request.\n *\n * Either the first arg is a Request object, which can be cloned\n *   so we can clone that object and read the body of the clone\n *   without disturbing the original argument\n *   However, reading the body here can only be done async; the body() method returns a promise\n *   this means this entire function has to return a promise\n *\n * OR the first arg is a url/string\n *   in which case the second arg has type RequestInit\n *   RequestInit is NOT cloneable, but RequestInit.body is writable\n *   so we can chain it into ReadableStream.pipeThrough()\n *\n *   ReadableStream.pipeThrough() lets us process a stream and returns a new stream\n *   So we can measure the body length as it passes through the pie, but need to attach\n *   the new stream to the original request\n *   so that the browser still has access to the body.\n *\n * @param body\n * @returns promise that resolves to the content length of the body\n */\nexport function getFetchBodyLength(...args: Parameters<typeof fetch>) {\n  if (args[0] instanceof URL || typeof args[0] === 'string') {\n    const requestInit = args[1];\n    if (!requestInit?.body) {\n      return Promise.resolve();\n    }\n    if (requestInit.body instanceof ReadableStream) {\n      const { body, length } = _getBodyNonDestructively(requestInit.body);\n      requestInit.body = body;\n\n      return length;\n    } else {\n      return Promise.resolve(getXHRBodyLength(requestInit.body));\n    }\n  } else {\n    const info = args[0];\n    if (!info?.body) {\n      return Promise.resolve();\n    }\n\n    return info\n      .clone()\n      .text()\n      .then(t => getByteLength(t));\n  }\n}\n\nfunction _getBodyNonDestructively(body: ReadableStream) {\n  // can't read a ReadableStream without destroying it\n  // but we CAN pipe it through and return a new ReadableStream\n\n  // some (older) platforms don't expose the pipeThrough method and in that scenario, we're out of luck;\n  //   there's no way to read the stream without consuming it.\n  if (!body.pipeThrough) {\n    DIAG_LOGGER.warn('Platform has ReadableStream but not pipeThrough!');\n    return {\n      body,\n      length: Promise.resolve(undefined),\n    };\n  }\n\n  let length = 0;\n  let resolveLength: (l: number) => void;\n  const lengthPromise = new Promise<number>(resolve => {\n    resolveLength = resolve;\n  });\n\n  const transform = new TransformStream({\n    start() {},\n    async transform(chunk, controller) {\n      const bytearray = (await chunk) as Uint8Array;\n      length += bytearray.byteLength;\n\n      controller.enqueue(chunk);\n    },\n    flush() {\n      resolveLength(length);\n    },\n  });\n\n  return {\n    body: body.pipeThrough(transform),\n    length: lengthPromise,\n  };\n}\n\nfunction isDocument(value: unknown): value is Document {\n  return typeof Document !== 'undefined' && value instanceof Document;\n}\n\n/**\n * Helper function to determine payload content length for XHR requests\n * @param body\n * @returns content length\n */\nexport function getXHRBodyLength(\n  body: Document | XMLHttpRequestBodyInit\n): number | undefined {\n  if (isDocument(body)) {\n    return new XMLSerializer().serializeToString(document).length;\n  }\n\n  // XMLHttpRequestBodyInit expands to the following:\n  if (typeof body === 'string') {\n    return getByteLength(body);\n  }\n\n  if (body instanceof Blob) {\n    return body.size;\n  }\n\n  if (body instanceof FormData) {\n    return getFormDataSize(body);\n  }\n\n  if (body instanceof URLSearchParams) {\n    return getByteLength(body.toString());\n  }\n\n  // ArrayBuffer | ArrayBufferView\n  if (body.byteLength !== undefined) {\n    return body.byteLength;\n  }\n\n  DIAG_LOGGER.warn('unknown body type');\n  return undefined;\n}\n\nconst TEXT_ENCODER = new TextEncoder();\nfunction getByteLength(s: string): number {\n  return TEXT_ENCODER.encode(s).byteLength;\n}\n\nfunction getFormDataSize(formData: FormData): number {\n  let size = 0;\n  for (const [key, value] of formData.entries()) {\n    size += key.length;\n    if (value instanceof Blob) {\n      size += value.size;\n    } else {\n      size += value.length;\n    }\n  }\n  return size;\n}\n\n/**\n * Normalize an HTTP request method string per `http.request.method` spec\n * https://github.com/open-telemetry/semantic-conventions/blob/main/docs/http/http-spans.md#http-client-span\n */\nexport function normalizeHttpRequestMethod(method: string): string {\n  const knownMethods = getKnownMethods();\n  const methUpper = method.toUpperCase();\n  if (methUpper in knownMethods) {\n    return methUpper;\n  } else {\n    return '_OTHER';\n  }\n}\n\nconst DEFAULT_KNOWN_METHODS = {\n  CONNECT: true,\n  DELETE: true,\n  GET: true,\n  HEAD: true,\n  OPTIONS: true,\n  PATCH: true,\n  POST: true,\n  PUT: true,\n  TRACE: true,\n};\nlet knownMethods: { [key: string]: boolean };\nfunction getKnownMethods() {\n  if (knownMethods === undefined) {\n    const cfgMethods = getStringListFromEnv(\n      'OTEL_INSTRUMENTATION_HTTP_KNOWN_METHODS'\n    );\n    if (cfgMethods && cfgMethods.length > 0) {\n      knownMethods = {};\n      cfgMethods.forEach(m => {\n        knownMethods[m] = true;\n      });\n    } else {\n      knownMethods = DEFAULT_KNOWN_METHODS;\n    }\n  }\n  return knownMethods;\n}\n\nconst HTTP_PORT_FROM_PROTOCOL: { [key: string]: string } = {\n  'https:': '443',\n  'http:': '80',\n};\nexport function serverPortFromUrl(url: URLLike): number | undefined {\n  const serverPort = Number(url.port || HTTP_PORT_FROM_PROTOCOL[url.protocol]);\n  // Guard with `if (serverPort)` because `Number('') === 0`.\n  if (serverPort && !isNaN(serverPort)) {\n    return serverPort;\n  } else {\n    return undefined;\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// this is autogenerated file, see scripts/version-update.js\nexport const VERSION = '0.208.0';\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as api from '@opentelemetry/api';\nimport {\n  SemconvStability,\n  semconvStabilityFromStr,\n  isWrapped,\n  InstrumentationBase,\n  InstrumentationConfig,\n  safeExecuteInTheMiddle,\n} from '@opentelemetry/instrumentation';\nimport * as core from '@opentelemetry/core';\nimport * as web from '@opentelemetry/sdk-trace-web';\nimport { AttributeNames } from './enums/AttributeNames';\nimport {\n  ATTR_HTTP_STATUS_CODE,\n  ATTR_HTTP_HOST,\n  ATTR_HTTP_USER_AGENT,\n  ATTR_HTTP_SCHEME,\n  ATTR_HTTP_URL,\n  ATTR_HTTP_METHOD,\n  ATTR_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED,\n  ATTR_HTTP_REQUEST_BODY_SIZE,\n} from './semconv';\nimport {\n  ATTR_ERROR_TYPE,\n  ATTR_HTTP_REQUEST_METHOD,\n  ATTR_HTTP_REQUEST_METHOD_ORIGINAL,\n  ATTR_HTTP_RESPONSE_STATUS_CODE,\n  ATTR_SERVER_ADDRESS,\n  ATTR_SERVER_PORT,\n  ATTR_URL_FULL,\n} from '@opentelemetry/semantic-conventions';\nimport { FetchError, FetchResponse, SpanData } from './types';\nimport {\n  getFetchBodyLength,\n  normalizeHttpRequestMethod,\n  serverPortFromUrl,\n} from './utils';\nimport { VERSION } from './version';\nimport { _globalThis } from '@opentelemetry/core';\n\n// how long to wait for observer to collect information about resources\n// this is needed as event \"load\" is called before observer\n// hard to say how long it should really wait, seems like 300ms is\n// safe enough\nconst OBSERVER_WAIT_TIME_MS = 300;\n\nconst isNode = typeof process === 'object' && process.release?.name === 'node';\n\nexport interface FetchCustomAttributeFunction {\n  (\n    span: api.Span,\n    request: Request | RequestInit,\n    result: Response | FetchError\n  ): void;\n}\n\nexport interface FetchRequestHookFunction {\n  (span: api.Span, request: Request | RequestInit): void;\n}\n\n/**\n * FetchPlugin Config\n */\nexport interface FetchInstrumentationConfig extends InstrumentationConfig {\n  // the number of timing resources is limited, after the limit\n  // (chrome 250, safari 150) the information is not collected anymore\n  // the only way to prevent that is to regularly clean the resources\n  // whenever it is possible, this is needed only when PerformanceObserver\n  // is not available\n  clearTimingResources?: boolean;\n  // urls which should include trace headers when origin doesn't match\n  propagateTraceHeaderCorsUrls?: web.PropagateTraceHeaderCorsUrls;\n  /**\n   * URLs that partially match any regex in ignoreUrls will not be traced.\n   * In addition, URLs that are _exact matches_ of strings in ignoreUrls will\n   * also not be traced.\n   */\n  ignoreUrls?: Array<string | RegExp>;\n  /** Function for adding custom attributes on the span */\n  applyCustomAttributesOnSpan?: FetchCustomAttributeFunction;\n  /** Function for adding custom attributes or headers before the request is handled */\n  requestHook?: FetchRequestHookFunction;\n  // Ignore adding network events as span events\n  ignoreNetworkEvents?: boolean;\n  /** Measure outgoing request size */\n  measureRequestSize?: boolean;\n  /** Select the HTTP semantic conventions version(s) used. */\n  semconvStabilityOptIn?: string;\n}\n\n/**\n * This class represents a fetch plugin for auto instrumentation\n */\nexport class FetchInstrumentation extends InstrumentationBase<FetchInstrumentationConfig> {\n  readonly component: string = 'fetch';\n  readonly version: string = VERSION;\n  moduleName = this.component;\n  private _usedResources = new WeakSet<PerformanceResourceTiming>();\n  private _tasksCount = 0;\n\n  private _semconvStability: SemconvStability;\n\n  constructor(config: FetchInstrumentationConfig = {}) {\n    super('@opentelemetry/instrumentation-fetch', VERSION, config);\n    this._semconvStability = semconvStabilityFromStr(\n      'http',\n      config?.semconvStabilityOptIn\n    );\n  }\n\n  init(): void {}\n\n  /**\n   * Add cors pre flight child span\n   * @param span\n   * @param corsPreFlightRequest\n   */\n  private _addChildSpan(\n    span: api.Span,\n    corsPreFlightRequest: PerformanceResourceTiming\n  ): void {\n    const childSpan = this.tracer.startSpan(\n      'CORS Preflight',\n      {\n        startTime: corsPreFlightRequest[web.PerformanceTimingNames.FETCH_START],\n      },\n      api.trace.setSpan(api.context.active(), span)\n    );\n    const skipOldSemconvContentLengthAttrs = !(\n      this._semconvStability & SemconvStability.OLD\n    );\n    web.addSpanNetworkEvents(\n      childSpan,\n      corsPreFlightRequest,\n      this.getConfig().ignoreNetworkEvents,\n      undefined,\n      skipOldSemconvContentLengthAttrs\n    );\n    childSpan.end(\n      corsPreFlightRequest[web.PerformanceTimingNames.RESPONSE_END]\n    );\n  }\n\n  /**\n   * Adds more attributes to span just before ending it\n   * @param span\n   * @param response\n   */\n  private _addFinalSpanAttributes(\n    span: api.Span,\n    response: FetchResponse\n  ): void {\n    const parsedUrl = web.parseUrl(response.url);\n\n    if (this._semconvStability & SemconvStability.OLD) {\n      span.setAttribute(ATTR_HTTP_STATUS_CODE, response.status);\n      if (response.statusText != null) {\n        span.setAttribute(AttributeNames.HTTP_STATUS_TEXT, response.statusText);\n      }\n      span.setAttribute(ATTR_HTTP_HOST, parsedUrl.host);\n      span.setAttribute(ATTR_HTTP_SCHEME, parsedUrl.protocol.replace(':', ''));\n      if (typeof navigator !== 'undefined') {\n        span.setAttribute(ATTR_HTTP_USER_AGENT, navigator.userAgent);\n      }\n    }\n\n    if (this._semconvStability & SemconvStability.STABLE) {\n      span.setAttribute(ATTR_HTTP_RESPONSE_STATUS_CODE, response.status);\n      // TODO: Set server.{address,port} at span creation for sampling decisions\n      // (a \"SHOULD\" requirement in semconv).\n      span.setAttribute(ATTR_SERVER_ADDRESS, parsedUrl.hostname);\n      const serverPort = serverPortFromUrl(parsedUrl);\n      if (serverPort) {\n        span.setAttribute(ATTR_SERVER_PORT, serverPort);\n      }\n    }\n  }\n\n  /**\n   * Add headers\n   * @param options\n   * @param spanUrl\n   */\n  private _addHeaders(options: Request | RequestInit, spanUrl: string): void {\n    if (\n      !web.shouldPropagateTraceHeaders(\n        spanUrl,\n        this.getConfig().propagateTraceHeaderCorsUrls\n      )\n    ) {\n      const headers: Partial<Record<string, unknown>> = {};\n      api.propagation.inject(api.context.active(), headers);\n      if (Object.keys(headers).length > 0) {\n        this._diag.debug('headers inject skipped due to CORS policy');\n      }\n      return;\n    }\n\n    if (options instanceof Request) {\n      api.propagation.inject(api.context.active(), options.headers, {\n        set: (h, k, v) => h.set(k, typeof v === 'string' ? v : String(v)),\n      });\n    } else if (options.headers instanceof Headers) {\n      api.propagation.inject(api.context.active(), options.headers, {\n        set: (h, k, v) => h.set(k, typeof v === 'string' ? v : String(v)),\n      });\n    } else if (options.headers instanceof Map) {\n      api.propagation.inject(api.context.active(), options.headers, {\n        set: (h, k, v) => h.set(k, typeof v === 'string' ? v : String(v)),\n      });\n    } else {\n      const headers: Partial<Record<string, unknown>> = {};\n      api.propagation.inject(api.context.active(), headers);\n      options.headers = Object.assign({}, headers, options.headers || {});\n    }\n  }\n\n  /**\n   * Clears the resource timings and all resources assigned with spans\n   *     when {@link FetchPluginConfig.clearTimingResources} is\n   *     set to true (default false)\n   * @private\n   */\n  private _clearResources() {\n    if (this._tasksCount === 0 && this.getConfig().clearTimingResources) {\n      performance.clearResourceTimings();\n      this._usedResources = new WeakSet<PerformanceResourceTiming>();\n    }\n  }\n\n  /**\n   * Creates a new span\n   * @param url\n   * @param options\n   */\n  private _createSpan(\n    url: string,\n    options: Partial<Request | RequestInit> = {}\n  ): api.Span | undefined {\n    if (core.isUrlIgnored(url, this.getConfig().ignoreUrls)) {\n      this._diag.debug('ignoring span as url matches ignored url');\n      return;\n    }\n\n    let name = '';\n    const attributes = {} as api.Attributes;\n    if (this._semconvStability & SemconvStability.OLD) {\n      const method = (options.method || 'GET').toUpperCase();\n      name = `HTTP ${method}`;\n      attributes[AttributeNames.COMPONENT] = this.moduleName;\n      attributes[ATTR_HTTP_METHOD] = method;\n      attributes[ATTR_HTTP_URL] = url;\n    }\n    if (this._semconvStability & SemconvStability.STABLE) {\n      const origMethod = options.method;\n      const normMethod = normalizeHttpRequestMethod(options.method || 'GET');\n      if (!name) {\n        // The \"old\" span name wins if emitting both old and stable semconv\n        // ('http/dup').\n        name = normMethod;\n      }\n      attributes[ATTR_HTTP_REQUEST_METHOD] = normMethod;\n      if (normMethod !== origMethod) {\n        attributes[ATTR_HTTP_REQUEST_METHOD_ORIGINAL] = origMethod;\n      }\n      attributes[ATTR_URL_FULL] = url;\n    }\n\n    return this.tracer.startSpan(name, {\n      kind: api.SpanKind.CLIENT,\n      attributes,\n    });\n  }\n\n  /**\n   * Finds appropriate resource and add network events to the span\n   * @param span\n   * @param resourcesObserver\n   * @param endTime\n   */\n  private _findResourceAndAddNetworkEvents(\n    span: api.Span,\n    resourcesObserver: SpanData,\n    endTime: api.HrTime\n  ): void {\n    let resources: PerformanceResourceTiming[] = resourcesObserver.entries;\n    if (!resources.length) {\n      if (!performance.getEntriesByType) {\n        return;\n      }\n      // fallback - either Observer is not available or it took longer\n      // then OBSERVER_WAIT_TIME_MS and observer didn't collect enough\n      // information\n      resources = performance.getEntriesByType(\n        'resource'\n      ) as PerformanceResourceTiming[];\n    }\n    const resource = web.getResource(\n      resourcesObserver.spanUrl,\n      resourcesObserver.startTime,\n      endTime,\n      resources,\n      this._usedResources,\n      'fetch'\n    );\n\n    if (resource.mainRequest) {\n      const mainRequest = resource.mainRequest;\n      this._markResourceAsUsed(mainRequest);\n\n      const corsPreFlightRequest = resource.corsPreFlightRequest;\n      if (corsPreFlightRequest) {\n        this._addChildSpan(span, corsPreFlightRequest);\n        this._markResourceAsUsed(corsPreFlightRequest);\n      }\n      const skipOldSemconvContentLengthAttrs = !(\n        this._semconvStability & SemconvStability.OLD\n      );\n      web.addSpanNetworkEvents(\n        span,\n        mainRequest,\n        this.getConfig().ignoreNetworkEvents,\n        undefined,\n        skipOldSemconvContentLengthAttrs\n      );\n    }\n  }\n\n  /**\n   * Marks certain [resource]{@link PerformanceResourceTiming} when information\n   * from this is used to add events to span.\n   * This is done to avoid reusing the same resource again for next span\n   * @param resource\n   */\n  private _markResourceAsUsed(resource: PerformanceResourceTiming): void {\n    this._usedResources.add(resource);\n  }\n\n  /**\n   * Finish span, add attributes, network events etc.\n   * @param span\n   * @param spanData\n   * @param response\n   */\n  private _endSpan(\n    span: api.Span,\n    spanData: SpanData,\n    response: FetchResponse\n  ) {\n    const endTime = core.millisToHrTime(Date.now());\n    const performanceEndTime = core.hrTime();\n    this._addFinalSpanAttributes(span, response);\n\n    if (this._semconvStability & SemconvStability.STABLE) {\n      // https://github.com/open-telemetry/semantic-conventions/blob/main/docs/http/http-spans.md#status\n      if (response.status >= 400) {\n        span.setStatus({ code: api.SpanStatusCode.ERROR });\n        span.setAttribute(ATTR_ERROR_TYPE, String(response.status));\n      }\n    }\n\n    setTimeout(() => {\n      spanData.observer?.disconnect();\n      this._findResourceAndAddNetworkEvents(span, spanData, performanceEndTime);\n      this._tasksCount--;\n      this._clearResources();\n      span.end(endTime);\n    }, OBSERVER_WAIT_TIME_MS);\n  }\n\n  /**\n   * Patches the constructor of fetch\n   */\n  private _patchConstructor(): (original: typeof fetch) => typeof fetch {\n    return original => {\n      const plugin = this;\n      return function patchConstructor(\n        this: typeof globalThis,\n        ...args: Parameters<typeof fetch>\n      ): Promise<Response> {\n        const self = this;\n        const url = web.parseUrl(\n          args[0] instanceof Request ? args[0].url : String(args[0])\n        ).href;\n\n        const options = args[0] instanceof Request ? args[0] : args[1] || {};\n        const createdSpan = plugin._createSpan(url, options);\n        if (!createdSpan) {\n          return original.apply(this, args);\n        }\n        const spanData = plugin._prepareSpanData(url);\n\n        if (plugin.getConfig().measureRequestSize) {\n          getFetchBodyLength(...args)\n            .then(bodyLength => {\n              if (!bodyLength) return;\n              if (plugin._semconvStability & SemconvStability.OLD) {\n                createdSpan.setAttribute(\n                  ATTR_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED,\n                  bodyLength\n                );\n              }\n              if (plugin._semconvStability & SemconvStability.STABLE) {\n                createdSpan.setAttribute(\n                  ATTR_HTTP_REQUEST_BODY_SIZE,\n                  bodyLength\n                );\n              }\n            })\n            .catch(error => {\n              plugin._diag.warn('getFetchBodyLength', error);\n            });\n        }\n\n        function endSpanOnError(span: api.Span, error: FetchError) {\n          plugin._applyAttributesAfterFetch(span, options, error);\n          plugin._endSpan(span, spanData, {\n            status: error.status || 0,\n            statusText: error.message,\n            url,\n          });\n        }\n\n        function endSpanOnSuccess(span: api.Span, response: Response) {\n          plugin._applyAttributesAfterFetch(span, options, response);\n          if (response.status >= 200 && response.status < 400) {\n            plugin._endSpan(span, spanData, response);\n          } else {\n            plugin._endSpan(span, spanData, {\n              status: response.status,\n              statusText: response.statusText,\n              url,\n            });\n          }\n        }\n\n        function withCancelPropagation(\n          body: ReadableStream<Uint8Array> | null,\n          readerClone: ReadableStreamDefaultReader<Uint8Array>\n        ): ReadableStream<Uint8Array> | null {\n          if (!body) return null;\n\n          const reader = body.getReader();\n\n          return new ReadableStream({\n            async pull(controller) {\n              try {\n                const { value, done } = await reader.read();\n                if (done) {\n                  reader.releaseLock();\n                  controller.close();\n                } else {\n                  controller.enqueue(value);\n                }\n              } catch (err) {\n                controller.error(err);\n                reader.cancel(err).catch(_ => {});\n\n                try {\n                  reader.releaseLock();\n                } catch {\n                  // Spec reference:\n                  // https://streams.spec.whatwg.org/#default-reader-release-lock\n                  //\n                  // releaseLock() only throws if called on an invalid reader\n                  // (i.e. reader.[[stream]] is undefined, meaning the lock is already released\n                  // or the reader was never associated). In normal use this cannot happen.\n                  // This catch is defensive only.\n                }\n              }\n            },\n            cancel(reason) {\n              readerClone.cancel(reason).catch(_ => {});\n              return reader.cancel(reason);\n            },\n          });\n        }\n\n        function onSuccess(\n          span: api.Span,\n          resolve: (value: Response | PromiseLike<Response>) => void,\n          response: Response\n        ): void {\n          let proxiedResponse: Response | null = null;\n\n          try {\n            // TODO: Switch to a consumer-driven model and drop `resClone`.\n            // Keeping eager consumption here to preserve current behavior and avoid breaking existing tests.\n            // Context: discussion in PR #5894 â†’ https://github.com/open-telemetry/opentelemetry-js/pull/5894\n            const resClone = response.clone();\n            const body = resClone.body;\n            if (body) {\n              const reader = body.getReader();\n              const isNullBodyStatus =\n                // 101 responses and protocol upgrading is handled internally by the browser\n                response.status === 204 ||\n                response.status === 205 ||\n                response.status === 304;\n              const wrappedBody = isNullBodyStatus\n                ? null\n                : withCancelPropagation(response.body, reader);\n\n              proxiedResponse = new Response(wrappedBody, {\n                status: response.status,\n                statusText: response.statusText,\n                headers: response.headers,\n              });\n\n              const read = (): void => {\n                reader.read().then(\n                  ({ done }) => {\n                    if (done) {\n                      endSpanOnSuccess(span, response);\n                    } else {\n                      read();\n                    }\n                  },\n                  error => {\n                    endSpanOnError(span, error);\n                  }\n                );\n              };\n              read();\n            } else {\n              // some older browsers don't have .body implemented\n              endSpanOnSuccess(span, response);\n            }\n          } finally {\n            resolve(proxiedResponse ?? response);\n          }\n        }\n\n        function onError(\n          span: api.Span,\n          reject: (reason?: unknown) => void,\n          error: FetchError\n        ) {\n          try {\n            endSpanOnError(span, error);\n          } finally {\n            reject(error);\n          }\n        }\n\n        return new Promise((resolve, reject) => {\n          return api.context.with(\n            api.trace.setSpan(api.context.active(), createdSpan),\n            () => {\n              plugin._addHeaders(options, url);\n              plugin._callRequestHook(createdSpan, options);\n              plugin._tasksCount++;\n\n              return original\n                .apply(\n                  self,\n                  options instanceof Request ? [options] : [url, options]\n                )\n                .then(\n                  onSuccess.bind(self, createdSpan, resolve),\n                  onError.bind(self, createdSpan, reject)\n                );\n            }\n          );\n        });\n      };\n    };\n  }\n\n  private _applyAttributesAfterFetch(\n    span: api.Span,\n    request: Request | RequestInit,\n    result: Response | FetchError\n  ) {\n    const applyCustomAttributesOnSpan =\n      this.getConfig().applyCustomAttributesOnSpan;\n    if (applyCustomAttributesOnSpan) {\n      safeExecuteInTheMiddle(\n        () => applyCustomAttributesOnSpan(span, request, result),\n        error => {\n          if (!error) {\n            return;\n          }\n\n          this._diag.error('applyCustomAttributesOnSpan', error);\n        },\n        true\n      );\n    }\n  }\n\n  private _callRequestHook(span: api.Span, request: Request | RequestInit) {\n    const requestHook = this.getConfig().requestHook;\n    if (requestHook) {\n      safeExecuteInTheMiddle(\n        () => requestHook(span, request),\n        error => {\n          if (!error) {\n            return;\n          }\n\n          this._diag.error('requestHook', error);\n        },\n        true\n      );\n    }\n  }\n\n  /**\n   * Prepares a span data - needed later for matching appropriate network\n   *     resources\n   * @param spanUrl\n   */\n  private _prepareSpanData(spanUrl: string): SpanData {\n    const startTime = core.hrTime();\n    const entries: PerformanceResourceTiming[] = [];\n    if (typeof PerformanceObserver !== 'function') {\n      return { entries, startTime, spanUrl };\n    }\n\n    const observer = new PerformanceObserver(list => {\n      const perfObsEntries = list.getEntries() as PerformanceResourceTiming[];\n      perfObsEntries.forEach(entry => {\n        if (entry.initiatorType === 'fetch' && entry.name === spanUrl) {\n          entries.push(entry);\n        }\n      });\n    });\n    observer.observe({\n      entryTypes: ['resource'],\n    });\n    return { entries, observer, startTime, spanUrl };\n  }\n\n  /**\n   * implements enable function\n   */\n  override enable(): void {\n    if (isNode) {\n      // Node.js v18+ *does* have a global `fetch()`, but this package does not\n      // support instrumenting it.\n      this._diag.warn(\n        \"this instrumentation is intended for web usage only, it does not instrument Node.js's fetch()\"\n      );\n      return;\n    }\n    if (isWrapped(fetch)) {\n      this._unwrap(_globalThis, 'fetch');\n      this._diag.debug('removing previous patch for constructor');\n    }\n    this._wrap(_globalThis, 'fetch', this._patchConstructor());\n  }\n\n  /**\n   * implements unpatch function\n   */\n  override disable(): void {\n    if (isNode) {\n      return;\n    }\n    this._unwrap(_globalThis, 'fetch');\n    this._usedResources = new WeakSet<PerformanceResourceTiming>();\n  }\n}\n"],
  "mappings": "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",
  "names": ["AttributeNames", "knownMethods"]
}
