{
  "version": 3,
  "sources": ["../../.pnpm/@opentelemetry+instrumentation-xml-http-request@0.208.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-xml-http-request/src/semconv.ts", "../../.pnpm/@opentelemetry+instrumentation-xml-http-request@0.208.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-xml-http-request/src/enums/EventNames.ts", "../../.pnpm/@opentelemetry+instrumentation-xml-http-request@0.208.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-xml-http-request/src/utils.ts", "../../.pnpm/@opentelemetry+instrumentation-xml-http-request@0.208.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-xml-http-request/src/version.ts", "../../.pnpm/@opentelemetry+instrumentation-xml-http-request@0.208.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-xml-http-request/src/enums/AttributeNames.ts", "../../.pnpm/@opentelemetry+instrumentation-xml-http-request@0.208.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-xml-http-request/src/xhr.ts"],
  "sourcesContent": ["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*\n * This file contains a copy of unstable semantic convention definitions\n * used by this package.\n * @see https://github.com/open-telemetry/opentelemetry-js/tree/main/semantic-conventions#unstable-semconv\n */\n\n/**\n * Deprecated, use one of `server.address`, `client.address` or `http.request.header.host` instead, depending on the usage.\n *\n * @example www.example.org\n *\n * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.\n *\n * @deprecated Replaced by one of `server.address`, `client.address` or `http.request.header.host`, depending on the usage.\n */\nexport const ATTR_HTTP_HOST = 'http.host' as const;\n\n/**\n * Deprecated, use `http.request.method` instead.\n *\n * @example GET\n * @example POST\n * @example HEAD\n *\n * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.\n *\n * @deprecated Replaced by `http.request.method`.\n */\nexport const ATTR_HTTP_METHOD = 'http.method' as const;\n\n/**\n * The size of the request payload body in bytes. This is the number of bytes transferred excluding headers and is often, but not always, present as the [Content-Length](https://www.rfc-editor.org/rfc/rfc9110.html#field.content-length) header. For requests using transport encoding, this should be the compressed size.\n *\n * @example 3495\n *\n * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.\n */\nexport const ATTR_HTTP_REQUEST_BODY_SIZE = 'http.request.body.size' as const;\n\n/**\n * Deprecated, use `http.request.body.size` instead.\n *\n * @example 5493\n *\n * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.\n *\n * @deprecated Replaced by `http.request.body.size`.\n */\nexport const ATTR_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED =\n  'http.request_content_length_uncompressed' as const;\n\n/**\n * Deprecated, use `http.response.header.<key>` instead.\n *\n * @example 3495\n *\n * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.\n *\n * @deprecated Replaced by `http.response.header.<key>`.\n */\nexport const ATTR_HTTP_RESPONSE_CONTENT_LENGTH =\n  'http.response_content_length' as const;\n\n/**\n * Deprecated, use `url.scheme` instead.\n *\n * @example http\n * @example https\n *\n * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.\n *\n * @deprecated Replaced by `url.scheme` instead.\n */\nexport const ATTR_HTTP_SCHEME = 'http.scheme' as const;\n\n/**\n * Deprecated, use `http.response.status_code` instead.\n *\n * @example 200\n *\n * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.\n *\n * @deprecated Replaced by `http.response.status_code`.\n */\nexport const ATTR_HTTP_STATUS_CODE = 'http.status_code' as const;\n\n/**\n * Deprecated, use `url.full` instead.\n *\n * @example https://www.foo.bar/search?q=OpenTelemetry#SemConv\n *\n * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.\n *\n * @deprecated Replaced by `url.full`.\n */\nexport const ATTR_HTTP_URL = 'http.url' as const;\n\n/**\n * Deprecated, use `user_agent.original` instead.\n *\n * @example CERN-LineMode/2.15 libwww/2.17b3\n * @example Mozilla/5.0 (iPhone; CPU iPhone OS 14_7_1 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.1.2 Mobile/15E148 Safari/604.1\n *\n * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.\n *\n * @deprecated Replaced by `user_agent.original`.\n */\nexport const ATTR_HTTP_USER_AGENT = 'http.user_agent' as const;\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport enum EventNames {\n  METHOD_OPEN = 'open',\n  METHOD_SEND = 'send',\n  EVENT_ABORT = 'abort',\n  EVENT_ERROR = 'error',\n  EVENT_LOAD = 'loaded',\n  EVENT_TIMEOUT = 'timeout',\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// Much of the logic here overlaps with the same utils file in opentelemetry-instrumentation-fetch\n// These may be unified in the future.\n\nimport * as api from '@opentelemetry/api';\nimport { getStringListFromEnv } from '@opentelemetry/core';\nimport { URLLike } from '@opentelemetry/sdk-trace-web';\n\nconst DIAG_LOGGER = api.diag.createComponentLogger({\n  namespace:\n    '@opentelemetry/opentelemetry-instrumentation-xml-http-request/utils',\n});\n\nfunction isDocument(value: unknown): value is Document {\n  return typeof Document !== 'undefined' && value instanceof Document;\n}\n\n/**\n * Helper function to determine payload content length for XHR requests\n * @param body\n * @returns content length\n */\nexport function getXHRBodyLength(\n  body: Document | XMLHttpRequestBodyInit\n): number | undefined {\n  if (isDocument(body)) {\n    return new XMLSerializer().serializeToString(document).length;\n  }\n\n  // XMLHttpRequestBodyInit expands to the following:\n  if (typeof body === 'string') {\n    return getByteLength(body);\n  }\n\n  if (body instanceof Blob) {\n    return body.size;\n  }\n\n  if (body instanceof FormData) {\n    return getFormDataSize(body);\n  }\n\n  if (body instanceof URLSearchParams) {\n    return getByteLength(body.toString());\n  }\n\n  // ArrayBuffer | ArrayBufferView\n  if (body.byteLength !== undefined) {\n    return body.byteLength;\n  }\n\n  DIAG_LOGGER.warn('unknown body type');\n  return undefined;\n}\n\nconst TEXT_ENCODER = new TextEncoder();\nfunction getByteLength(s: string): number {\n  return TEXT_ENCODER.encode(s).byteLength;\n}\n\nfunction getFormDataSize(formData: FormData): number {\n  let size = 0;\n  for (const [key, value] of formData.entries()) {\n    size += key.length;\n    if (value instanceof Blob) {\n      size += value.size;\n    } else {\n      size += value.length;\n    }\n  }\n  return size;\n}\n\n/**\n * Normalize an HTTP request method string per `http.request.method` spec\n * https://github.com/open-telemetry/semantic-conventions/blob/main/docs/http/http-spans.md#http-client-span\n */\nexport function normalizeHttpRequestMethod(method: string): string {\n  const knownMethods = getKnownMethods();\n  const methUpper = method.toUpperCase();\n  if (methUpper in knownMethods) {\n    return methUpper;\n  } else {\n    return '_OTHER';\n  }\n}\n\nconst DEFAULT_KNOWN_METHODS = {\n  CONNECT: true,\n  DELETE: true,\n  GET: true,\n  HEAD: true,\n  OPTIONS: true,\n  PATCH: true,\n  POST: true,\n  PUT: true,\n  TRACE: true,\n};\nlet knownMethods: { [key: string]: boolean };\nfunction getKnownMethods() {\n  if (knownMethods === undefined) {\n    const cfgMethods = getStringListFromEnv(\n      'OTEL_INSTRUMENTATION_HTTP_KNOWN_METHODS'\n    );\n    if (cfgMethods && cfgMethods.length > 0) {\n      knownMethods = {};\n      cfgMethods.forEach(m => {\n        knownMethods[m] = true;\n      });\n    } else {\n      knownMethods = DEFAULT_KNOWN_METHODS;\n    }\n  }\n  return knownMethods;\n}\n\nconst HTTP_PORT_FROM_PROTOCOL: { [key: string]: string } = {\n  'https:': '443',\n  'http:': '80',\n};\nexport function serverPortFromUrl(url: URLLike): number | undefined {\n  const serverPort = Number(url.port || HTTP_PORT_FROM_PROTOCOL[url.protocol]);\n  // Guard with `if (serverPort)` because `Number('') === 0`.\n  if (serverPort && !isNaN(serverPort)) {\n    return serverPort;\n  } else {\n    return undefined;\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// this is autogenerated file, see scripts/version-update.js\nexport const VERSION = '0.208.0';\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/trace/semantic_conventions/http.md\n */\nexport enum AttributeNames {\n  HTTP_STATUS_TEXT = 'http.status_text',\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as api from '@opentelemetry/api';\nimport {\n  SemconvStability,\n  semconvStabilityFromStr,\n  isWrapped,\n  InstrumentationBase,\n  InstrumentationConfig,\n  safeExecuteInTheMiddle,\n} from '@opentelemetry/instrumentation';\nimport { hrTime, isUrlIgnored, otperformance } from '@opentelemetry/core';\nimport {\n  addSpanNetworkEvents,\n  getResource,\n  PerformanceTimingNames as PTN,\n  shouldPropagateTraceHeaders,\n  parseUrl,\n} from '@opentelemetry/sdk-trace-web';\nimport {\n  ATTR_ERROR_TYPE,\n  ATTR_HTTP_REQUEST_METHOD,\n  ATTR_HTTP_REQUEST_METHOD_ORIGINAL,\n  ATTR_HTTP_RESPONSE_STATUS_CODE,\n  ATTR_SERVER_ADDRESS,\n  ATTR_SERVER_PORT,\n  ATTR_URL_FULL,\n} from '@opentelemetry/semantic-conventions';\nimport {\n  ATTR_HTTP_HOST,\n  ATTR_HTTP_METHOD,\n  ATTR_HTTP_SCHEME,\n  ATTR_HTTP_STATUS_CODE,\n  ATTR_HTTP_URL,\n  ATTR_HTTP_USER_AGENT,\n  ATTR_HTTP_REQUEST_BODY_SIZE,\n  ATTR_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED,\n} from './semconv';\nimport { EventNames } from './enums/EventNames';\nimport {\n  OpenFunction,\n  PropagateTraceHeaderCorsUrls,\n  SendFunction,\n  XhrMem,\n} from './types';\nimport {\n  normalizeHttpRequestMethod,\n  serverPortFromUrl,\n  getXHRBodyLength,\n} from './utils';\nimport { VERSION } from './version';\nimport { AttributeNames } from './enums/AttributeNames';\n\n// how long to wait for observer to collect information about resources\n// this is needed as event \"load\" is called before observer\n// hard to say how long it should really wait, seems like 300ms is\n// safe enough\nconst OBSERVER_WAIT_TIME_MS = 300;\n\nexport type XHRCustomAttributeFunction = (\n  span: api.Span,\n  xhr: XMLHttpRequest\n) => void;\n\n/**\n * XMLHttpRequest config\n */\nexport interface XMLHttpRequestInstrumentationConfig\n  extends InstrumentationConfig {\n  /**\n   * The number of timing resources is limited, after the limit\n   * (chrome 250, safari 150) the information is not collected anymore.\n   * The only way to prevent that is to regularly clean the resources\n   * whenever it is possible. This is needed only when PerformanceObserver\n   * is not available\n   */\n  clearTimingResources?: boolean;\n  /** URLs which should include trace headers when origin doesn't match */\n  propagateTraceHeaderCorsUrls?: PropagateTraceHeaderCorsUrls;\n  /**\n   * URLs that partially match any regex in ignoreUrls will not be traced.\n   * In addition, URLs that are _exact matches_ of strings in ignoreUrls will\n   * also not be traced.\n   */\n  ignoreUrls?: Array<string | RegExp>;\n  /** Function for adding custom attributes on the span */\n  applyCustomAttributesOnSpan?: XHRCustomAttributeFunction;\n  /** Ignore adding network events as span events */\n  ignoreNetworkEvents?: boolean;\n  /** Measure outgoing request size */\n  measureRequestSize?: boolean;\n  /** Select the HTTP semantic conventions version(s) used. */\n  semconvStabilityOptIn?: string;\n}\n\n/**\n * This class represents a XMLHttpRequest plugin for auto instrumentation\n */\nexport class XMLHttpRequestInstrumentation extends InstrumentationBase<XMLHttpRequestInstrumentationConfig> {\n  readonly component: string = 'xml-http-request';\n  readonly version: string = VERSION;\n  moduleName = this.component;\n\n  private _tasksCount = 0;\n  private _xhrMem = new WeakMap<XMLHttpRequest, XhrMem>();\n  private _usedResources = new WeakSet<PerformanceResourceTiming>();\n  private _semconvStability: SemconvStability;\n\n  constructor(config: XMLHttpRequestInstrumentationConfig = {}) {\n    super('@opentelemetry/instrumentation-xml-http-request', VERSION, config);\n    this._semconvStability = semconvStabilityFromStr(\n      'http',\n      config?.semconvStabilityOptIn\n    );\n  }\n\n  init() {}\n\n  /**\n   * Adds custom headers to XMLHttpRequest\n   * @param xhr\n   * @param spanUrl\n   * @private\n   */\n  private _addHeaders(xhr: XMLHttpRequest, spanUrl: string) {\n    const url = parseUrl(spanUrl).href;\n    if (\n      !shouldPropagateTraceHeaders(\n        url,\n        this.getConfig().propagateTraceHeaderCorsUrls\n      )\n    ) {\n      const headers: Partial<Record<string, unknown>> = {};\n      api.propagation.inject(api.context.active(), headers);\n      if (Object.keys(headers).length > 0) {\n        this._diag.debug('headers inject skipped due to CORS policy');\n      }\n      return;\n    }\n    const headers: { [key: string]: unknown } = {};\n    api.propagation.inject(api.context.active(), headers);\n    Object.keys(headers).forEach(key => {\n      xhr.setRequestHeader(key, String(headers[key]));\n    });\n  }\n\n  /**\n   * Add cors pre flight child span\n   * @param span\n   * @param corsPreFlightRequest\n   * @private\n   */\n  private _addChildSpan(\n    span: api.Span,\n    corsPreFlightRequest: PerformanceResourceTiming\n  ): void {\n    api.context.with(api.trace.setSpan(api.context.active(), span), () => {\n      const childSpan = this.tracer.startSpan('CORS Preflight', {\n        startTime: corsPreFlightRequest[PTN.FETCH_START],\n      });\n      const skipOldSemconvContentLengthAttrs = !(\n        this._semconvStability & SemconvStability.OLD\n      );\n      addSpanNetworkEvents(\n        childSpan,\n        corsPreFlightRequest,\n        this.getConfig().ignoreNetworkEvents,\n        undefined,\n        skipOldSemconvContentLengthAttrs\n      );\n      childSpan.end(corsPreFlightRequest[PTN.RESPONSE_END]);\n    });\n  }\n\n  /**\n   * Add attributes when span is going to end\n   * @param span\n   * @param xhr\n   * @param spanUrl\n   * @private\n   */\n  _addFinalSpanAttributes(span: api.Span, xhrMem: XhrMem, spanUrl?: string) {\n    if (this._semconvStability & SemconvStability.OLD) {\n      if (xhrMem.status !== undefined) {\n        span.setAttribute(ATTR_HTTP_STATUS_CODE, xhrMem.status);\n      }\n      if (xhrMem.statusText !== undefined) {\n        span.setAttribute(AttributeNames.HTTP_STATUS_TEXT, xhrMem.statusText);\n      }\n      if (typeof spanUrl === 'string') {\n        const parsedUrl = parseUrl(spanUrl);\n        span.setAttribute(ATTR_HTTP_HOST, parsedUrl.host);\n        span.setAttribute(\n          ATTR_HTTP_SCHEME,\n          parsedUrl.protocol.replace(':', '')\n        );\n      }\n\n      // @TODO do we want to collect this or it will be collected earlier once only or\n      //    maybe when parent span is not available ?\n      span.setAttribute(ATTR_HTTP_USER_AGENT, navigator.userAgent);\n    }\n    if (this._semconvStability & SemconvStability.STABLE) {\n      if (xhrMem.status) {\n        // Intentionally exclude status=0, because XHR uses 0 for before a\n        // response is received and semconv says to only add the attribute if\n        // received a response.\n        span.setAttribute(ATTR_HTTP_RESPONSE_STATUS_CODE, xhrMem.status);\n      }\n    }\n  }\n\n  private _applyAttributesAfterXHR(span: api.Span, xhr: XMLHttpRequest) {\n    const applyCustomAttributesOnSpan =\n      this.getConfig().applyCustomAttributesOnSpan;\n    if (typeof applyCustomAttributesOnSpan === 'function') {\n      safeExecuteInTheMiddle(\n        () => applyCustomAttributesOnSpan(span, xhr),\n        error => {\n          if (!error) {\n            return;\n          }\n\n          this._diag.error('applyCustomAttributesOnSpan', error);\n        },\n        true\n      );\n    }\n  }\n\n  /**\n   * will collect information about all resources created\n   * between \"send\" and \"end\" with additional waiting for main resource\n   * @param xhr\n   * @param spanUrl\n   * @private\n   */\n  private _addResourceObserver(xhr: XMLHttpRequest, spanUrl: string) {\n    const xhrMem = this._xhrMem.get(xhr);\n    if (\n      !xhrMem ||\n      typeof PerformanceObserver !== 'function' ||\n      typeof PerformanceResourceTiming !== 'function'\n    ) {\n      return;\n    }\n    xhrMem.createdResources = {\n      observer: new PerformanceObserver(list => {\n        const entries = list.getEntries() as PerformanceResourceTiming[];\n        const parsedUrl = parseUrl(spanUrl);\n\n        entries.forEach(entry => {\n          if (\n            entry.initiatorType === 'xmlhttprequest' &&\n            entry.name === parsedUrl.href\n          ) {\n            if (xhrMem.createdResources) {\n              xhrMem.createdResources.entries.push(entry);\n            }\n          }\n        });\n      }),\n      entries: [],\n    };\n    xhrMem.createdResources.observer.observe({\n      entryTypes: ['resource'],\n    });\n  }\n\n  /**\n   * Clears the resource timings and all resources assigned with spans\n   *     when {@link XMLHttpRequestInstrumentationConfig.clearTimingResources} is\n   *     set to true (default false)\n   * @private\n   */\n  private _clearResources() {\n    if (this._tasksCount === 0 && this.getConfig().clearTimingResources) {\n      (otperformance as unknown as Performance).clearResourceTimings();\n      this._xhrMem = new WeakMap<XMLHttpRequest, XhrMem>();\n      this._usedResources = new WeakSet<PerformanceResourceTiming>();\n    }\n  }\n\n  /**\n   * Finds appropriate resource and add network events to the span\n   * @param span\n   */\n  private _findResourceAndAddNetworkEvents(\n    xhrMem: XhrMem,\n    span: api.Span,\n    spanUrl?: string,\n    startTime?: api.HrTime,\n    endTime?: api.HrTime\n  ): void {\n    if (!spanUrl || !startTime || !endTime || !xhrMem.createdResources) {\n      return;\n    }\n\n    let resources: PerformanceResourceTiming[] =\n      xhrMem.createdResources.entries;\n\n    if (!resources || !resources.length) {\n      // fallback - either Observer is not available or it took longer\n      // then OBSERVER_WAIT_TIME_MS and observer didn't collect enough\n      // information\n      // ts thinks this is the perf_hooks module, but it is the browser performance api\n      resources = (otperformance as unknown as Performance).getEntriesByType(\n        'resource'\n      ) as PerformanceResourceTiming[];\n    }\n\n    const resource = getResource(\n      parseUrl(spanUrl).href,\n      startTime,\n      endTime,\n      resources,\n      this._usedResources\n    );\n\n    if (resource.mainRequest) {\n      const mainRequest = resource.mainRequest;\n      this._markResourceAsUsed(mainRequest);\n\n      const corsPreFlightRequest = resource.corsPreFlightRequest;\n      if (corsPreFlightRequest) {\n        this._addChildSpan(span, corsPreFlightRequest);\n        this._markResourceAsUsed(corsPreFlightRequest);\n      }\n      const skipOldSemconvContentLengthAttrs = !(\n        this._semconvStability & SemconvStability.OLD\n      );\n      addSpanNetworkEvents(\n        span,\n        mainRequest,\n        this.getConfig().ignoreNetworkEvents,\n        undefined,\n        skipOldSemconvContentLengthAttrs\n      );\n    }\n  }\n\n  /**\n   * Removes the previous information about span.\n   * This might happened when the same xhr is used again.\n   * @param xhr\n   * @private\n   */\n  private _cleanPreviousSpanInformation(xhr: XMLHttpRequest) {\n    const xhrMem = this._xhrMem.get(xhr);\n    if (xhrMem) {\n      const callbackToRemoveEvents = xhrMem.callbackToRemoveEvents;\n      if (callbackToRemoveEvents) {\n        callbackToRemoveEvents();\n      }\n      this._xhrMem.delete(xhr);\n    }\n  }\n\n  /**\n   * Creates a new span when method \"open\" is called\n   * @param xhr\n   * @param url\n   * @param method\n   * @private\n   */\n  private _createSpan(\n    xhr: XMLHttpRequest,\n    url: string,\n    method: string\n  ): api.Span | undefined {\n    if (isUrlIgnored(url, this.getConfig().ignoreUrls)) {\n      this._diag.debug('ignoring span as url matches ignored url');\n      return;\n    }\n\n    let name = '';\n    const parsedUrl = parseUrl(url);\n    const attributes = {} as api.Attributes;\n    if (this._semconvStability & SemconvStability.OLD) {\n      name = method.toUpperCase();\n      attributes[ATTR_HTTP_METHOD] = method;\n      attributes[ATTR_HTTP_URL] = parsedUrl.toString();\n    }\n    if (this._semconvStability & SemconvStability.STABLE) {\n      const origMethod = method;\n      const normMethod = normalizeHttpRequestMethod(method);\n      if (!name) {\n        // The \"old\" span name wins if emitting both old and stable semconv\n        // ('http/dup').\n        name = normMethod;\n      }\n      attributes[ATTR_HTTP_REQUEST_METHOD] = normMethod;\n      if (normMethod !== origMethod) {\n        attributes[ATTR_HTTP_REQUEST_METHOD_ORIGINAL] = origMethod;\n      }\n      attributes[ATTR_URL_FULL] = parsedUrl.toString();\n      attributes[ATTR_SERVER_ADDRESS] = parsedUrl.hostname;\n      const serverPort = serverPortFromUrl(parsedUrl);\n      if (serverPort) {\n        attributes[ATTR_SERVER_PORT] = serverPort;\n      }\n    }\n\n    const currentSpan = this.tracer.startSpan(name, {\n      kind: api.SpanKind.CLIENT,\n      attributes,\n    });\n\n    currentSpan.addEvent(EventNames.METHOD_OPEN);\n\n    this._cleanPreviousSpanInformation(xhr);\n\n    this._xhrMem.set(xhr, {\n      span: currentSpan,\n      spanUrl: url,\n    });\n\n    return currentSpan;\n  }\n\n  /**\n   * Marks certain [resource]{@link PerformanceResourceTiming} when information\n   * from this is used to add events to span.\n   * This is done to avoid reusing the same resource again for next span\n   * @param resource\n   * @private\n   */\n  private _markResourceAsUsed(resource: PerformanceResourceTiming) {\n    this._usedResources.add(resource);\n  }\n\n  /**\n   * Patches the method open\n   * @private\n   */\n  protected _patchOpen() {\n    return (original: OpenFunction): OpenFunction => {\n      const plugin = this;\n      return function patchOpen(this: XMLHttpRequest, ...args): void {\n        const method: string = args[0];\n        const url: string = args[1];\n        plugin._createSpan(this, url, method);\n\n        return original.apply(this, args);\n      };\n    };\n  }\n\n  /**\n   * Patches the method send\n   * @private\n   */\n  protected _patchSend() {\n    const plugin = this;\n\n    function endSpanTimeout(\n      eventName: string,\n      xhrMem: XhrMem,\n      performanceEndTime: api.HrTime,\n      endTime: number\n    ) {\n      const callbackToRemoveEvents = xhrMem.callbackToRemoveEvents;\n\n      if (typeof callbackToRemoveEvents === 'function') {\n        callbackToRemoveEvents();\n      }\n\n      const { span, spanUrl, sendStartTime } = xhrMem;\n\n      if (span) {\n        plugin._findResourceAndAddNetworkEvents(\n          xhrMem,\n          span,\n          spanUrl,\n          sendStartTime,\n          performanceEndTime\n        );\n        span.addEvent(eventName, endTime);\n        plugin._addFinalSpanAttributes(span, xhrMem, spanUrl);\n        span.end(endTime);\n        plugin._tasksCount--;\n      }\n      plugin._clearResources();\n    }\n\n    function endSpan(\n      eventName: string,\n      xhr: XMLHttpRequest,\n      isError: boolean,\n      errorType?: string\n    ) {\n      const xhrMem = plugin._xhrMem.get(xhr);\n      if (!xhrMem) {\n        return;\n      }\n      xhrMem.status = xhr.status;\n      xhrMem.statusText = xhr.statusText;\n      plugin._xhrMem.delete(xhr);\n\n      if (xhrMem.span) {\n        const span = xhrMem.span;\n        plugin._applyAttributesAfterXHR(span, xhr);\n\n        if (plugin._semconvStability & SemconvStability.STABLE) {\n          if (isError) {\n            if (errorType) {\n              span.setStatus({\n                code: api.SpanStatusCode.ERROR,\n                message: errorType,\n              });\n              span.setAttribute(ATTR_ERROR_TYPE, errorType);\n            }\n          } else if (xhrMem.status && xhrMem.status >= 400) {\n            span.setStatus({ code: api.SpanStatusCode.ERROR });\n            span.setAttribute(ATTR_ERROR_TYPE, String(xhrMem.status));\n          }\n        }\n      }\n\n      const performanceEndTime = hrTime();\n      const endTime = Date.now();\n\n      // the timeout is needed as observer doesn't have yet information\n      // when event \"load\" is called. Also the time may differ depends on\n      // browser and speed of computer\n      setTimeout(() => {\n        endSpanTimeout(eventName, xhrMem, performanceEndTime, endTime);\n      }, OBSERVER_WAIT_TIME_MS);\n    }\n\n    function onError(this: XMLHttpRequest) {\n      endSpan(EventNames.EVENT_ERROR, this, true, 'error');\n    }\n\n    function onAbort(this: XMLHttpRequest) {\n      endSpan(EventNames.EVENT_ABORT, this, false);\n    }\n\n    function onTimeout(this: XMLHttpRequest) {\n      endSpan(EventNames.EVENT_TIMEOUT, this, true, 'timeout');\n    }\n\n    function onLoad(this: XMLHttpRequest) {\n      if (this.status < 299) {\n        endSpan(EventNames.EVENT_LOAD, this, false);\n      } else {\n        endSpan(EventNames.EVENT_ERROR, this, false);\n      }\n    }\n\n    function unregister(xhr: XMLHttpRequest) {\n      xhr.removeEventListener('abort', onAbort);\n      xhr.removeEventListener('error', onError);\n      xhr.removeEventListener('load', onLoad);\n      xhr.removeEventListener('timeout', onTimeout);\n      const xhrMem = plugin._xhrMem.get(xhr);\n      if (xhrMem) {\n        xhrMem.callbackToRemoveEvents = undefined;\n      }\n    }\n\n    return (original: SendFunction): SendFunction => {\n      return function patchSend(this: XMLHttpRequest, ...args): void {\n        const xhrMem = plugin._xhrMem.get(this);\n        if (!xhrMem) {\n          return original.apply(this, args);\n        }\n        const currentSpan = xhrMem.span;\n        const spanUrl = xhrMem.spanUrl;\n\n        if (currentSpan && spanUrl) {\n          if (plugin.getConfig().measureRequestSize && args?.[0]) {\n            const body = args[0];\n            const bodyLength = getXHRBodyLength(body);\n            if (bodyLength !== undefined) {\n              if (plugin._semconvStability & SemconvStability.OLD) {\n                currentSpan.setAttribute(\n                  ATTR_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED,\n                  bodyLength\n                );\n              }\n              if (plugin._semconvStability & SemconvStability.STABLE) {\n                currentSpan.setAttribute(\n                  ATTR_HTTP_REQUEST_BODY_SIZE,\n                  bodyLength\n                );\n              }\n            }\n          }\n\n          api.context.with(\n            api.trace.setSpan(api.context.active(), currentSpan),\n            () => {\n              plugin._tasksCount++;\n              xhrMem.sendStartTime = hrTime();\n              currentSpan.addEvent(EventNames.METHOD_SEND);\n\n              this.addEventListener('abort', onAbort);\n              this.addEventListener('error', onError);\n              this.addEventListener('load', onLoad);\n              this.addEventListener('timeout', onTimeout);\n\n              xhrMem.callbackToRemoveEvents = () => {\n                unregister(this);\n                if (xhrMem.createdResources) {\n                  xhrMem.createdResources.observer.disconnect();\n                }\n              };\n              plugin._addHeaders(this, spanUrl);\n              plugin._addResourceObserver(this, spanUrl);\n            }\n          );\n        }\n        return original.apply(this, args);\n      };\n    };\n  }\n\n  /**\n   * implements enable function\n   */\n  override enable() {\n    this._diag.debug('applying patch to', this.moduleName, this.version);\n\n    if (isWrapped(XMLHttpRequest.prototype.open)) {\n      this._unwrap(XMLHttpRequest.prototype, 'open');\n      this._diag.debug('removing previous patch from method open');\n    }\n\n    if (isWrapped(XMLHttpRequest.prototype.send)) {\n      this._unwrap(XMLHttpRequest.prototype, 'send');\n      this._diag.debug('removing previous patch from method send');\n    }\n\n    this._wrap(XMLHttpRequest.prototype, 'open', this._patchOpen());\n    this._wrap(XMLHttpRequest.prototype, 'send', this._patchSend());\n  }\n\n  /**\n   * implements disable function\n   */\n  override disable() {\n    this._diag.debug('removing patch from', this.moduleName, this.version);\n\n    this._unwrap(XMLHttpRequest.prototype, 'open');\n    this._unwrap(XMLHttpRequest.prototype, 'send');\n\n    this._tasksCount = 0;\n    this._xhrMem = new WeakMap<XMLHttpRequest, XhrMem>();\n    this._usedResources = new WeakSet<PerformanceResourceTiming>();\n  }\n}\n"],
  "mappings": "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",
  "names": ["EventNames", "knownMethods", "AttributeNames", "headers"]
}
