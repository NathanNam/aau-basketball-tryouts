{
  "version": 3,
  "sources": ["../../.pnpm/@opentelemetry+sdk-logs@0.208.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-logs/src/LogRecordImpl.ts", "../../.pnpm/@opentelemetry+sdk-logs@0.208.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-logs/src/Logger.ts", "../../.pnpm/@opentelemetry+sdk-logs@0.208.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-logs/src/config.ts", "../../.pnpm/@opentelemetry+sdk-logs@0.208.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-logs/src/export/NoopLogRecordProcessor.ts", "../../.pnpm/@opentelemetry+sdk-logs@0.208.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-logs/src/MultiLogRecordProcessor.ts", "../../.pnpm/@opentelemetry+sdk-logs@0.208.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-logs/src/internal/LoggerProviderSharedState.ts", "../../.pnpm/@opentelemetry+sdk-logs@0.208.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-logs/src/LoggerProvider.ts", "../../.pnpm/@opentelemetry+sdk-logs@0.208.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-logs/src/export/ConsoleLogRecordExporter.ts", "../../.pnpm/@opentelemetry+sdk-logs@0.208.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-logs/src/export/SimpleLogRecordProcessor.ts", "../../.pnpm/@opentelemetry+sdk-logs@0.208.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-logs/src/export/InMemoryLogRecordExporter.ts", "../../.pnpm/@opentelemetry+sdk-logs@0.208.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-logs/src/export/BatchLogRecordProcessorBase.ts", "../../.pnpm/@opentelemetry+sdk-logs@0.208.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-logs/src/platform/browser/export/BatchLogRecordProcessor.ts"],
  "sourcesContent": ["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type * as logsAPI from '@opentelemetry/api-logs';\nimport * as api from '@opentelemetry/api';\nimport {\n  timeInputToHrTime,\n  isAttributeValue,\n  InstrumentationScope,\n} from '@opentelemetry/core';\nimport type { Resource } from '@opentelemetry/resources';\n\nimport type { ReadableLogRecord } from './export/ReadableLogRecord';\nimport type { LogRecordLimits } from './types';\nimport { LoggerProviderSharedState } from './internal/LoggerProviderSharedState';\n\nexport class LogRecordImpl implements ReadableLogRecord {\n  readonly hrTime: api.HrTime;\n  readonly hrTimeObserved: api.HrTime;\n  readonly spanContext?: api.SpanContext;\n  readonly resource: Resource;\n  readonly instrumentationScope: InstrumentationScope;\n  readonly attributes: logsAPI.LogAttributes = {};\n  private _severityText?: string;\n  private _severityNumber?: logsAPI.SeverityNumber;\n  private _body?: logsAPI.LogBody;\n  private _eventName?: string;\n  private totalAttributesCount: number = 0;\n\n  private _isReadonly: boolean = false;\n  private readonly _logRecordLimits: Required<LogRecordLimits>;\n\n  set severityText(severityText: string | undefined) {\n    if (this._isLogRecordReadonly()) {\n      return;\n    }\n    this._severityText = severityText;\n  }\n  get severityText(): string | undefined {\n    return this._severityText;\n  }\n\n  set severityNumber(severityNumber: logsAPI.SeverityNumber | undefined) {\n    if (this._isLogRecordReadonly()) {\n      return;\n    }\n    this._severityNumber = severityNumber;\n  }\n  get severityNumber(): logsAPI.SeverityNumber | undefined {\n    return this._severityNumber;\n  }\n\n  set body(body: logsAPI.LogBody | undefined) {\n    if (this._isLogRecordReadonly()) {\n      return;\n    }\n    this._body = body;\n  }\n  get body(): logsAPI.LogBody | undefined {\n    return this._body;\n  }\n\n  get eventName(): string | undefined {\n    return this._eventName;\n  }\n  set eventName(eventName: string | undefined) {\n    if (this._isLogRecordReadonly()) {\n      return;\n    }\n    this._eventName = eventName;\n  }\n\n  get droppedAttributesCount(): number {\n    return this.totalAttributesCount - Object.keys(this.attributes).length;\n  }\n\n  constructor(\n    _sharedState: LoggerProviderSharedState,\n    instrumentationScope: InstrumentationScope,\n    logRecord: logsAPI.LogRecord\n  ) {\n    const {\n      timestamp,\n      observedTimestamp,\n      eventName,\n      severityNumber,\n      severityText,\n      body,\n      attributes = {},\n      context,\n    } = logRecord;\n\n    const now = Date.now();\n    this.hrTime = timeInputToHrTime(timestamp ?? now);\n    this.hrTimeObserved = timeInputToHrTime(observedTimestamp ?? now);\n\n    if (context) {\n      const spanContext = api.trace.getSpanContext(context);\n      if (spanContext && api.isSpanContextValid(spanContext)) {\n        this.spanContext = spanContext;\n      }\n    }\n    this.severityNumber = severityNumber;\n    this.severityText = severityText;\n    this.body = body;\n    this.resource = _sharedState.resource;\n    this.instrumentationScope = instrumentationScope;\n    this._logRecordLimits = _sharedState.logRecordLimits;\n    this._eventName = eventName;\n    this.setAttributes(attributes);\n  }\n\n  public setAttribute(key: string, value?: logsAPI.AnyValue) {\n    if (this._isLogRecordReadonly()) {\n      return this;\n    }\n    if (value === null) {\n      return this;\n    }\n    if (key.length === 0) {\n      api.diag.warn(`Invalid attribute key: ${key}`);\n      return this;\n    }\n    if (\n      !isAttributeValue(value) &&\n      !(\n        typeof value === 'object' &&\n        !Array.isArray(value) &&\n        Object.keys(value).length > 0\n      )\n    ) {\n      api.diag.warn(`Invalid attribute value set for key: ${key}`);\n      return this;\n    }\n    this.totalAttributesCount += 1;\n    if (\n      Object.keys(this.attributes).length >=\n        this._logRecordLimits.attributeCountLimit &&\n      !Object.prototype.hasOwnProperty.call(this.attributes, key)\n    ) {\n      // This logic is to create drop message at most once per LogRecord to prevent excessive logging.\n      if (this.droppedAttributesCount === 1) {\n        api.diag.warn('Dropping extra attributes.');\n      }\n      return this;\n    }\n    if (isAttributeValue(value)) {\n      this.attributes[key] = this._truncateToSize(value);\n    } else {\n      this.attributes[key] = value;\n    }\n    return this;\n  }\n\n  public setAttributes(attributes: logsAPI.LogAttributes) {\n    for (const [k, v] of Object.entries(attributes)) {\n      this.setAttribute(k, v);\n    }\n    return this;\n  }\n\n  public setBody(body: logsAPI.LogBody) {\n    this.body = body;\n    return this;\n  }\n\n  public setEventName(eventName: string) {\n    this.eventName = eventName;\n    return this;\n  }\n\n  public setSeverityNumber(severityNumber: logsAPI.SeverityNumber) {\n    this.severityNumber = severityNumber;\n    return this;\n  }\n\n  public setSeverityText(severityText: string) {\n    this.severityText = severityText;\n    return this;\n  }\n\n  /**\n   * @internal\n   * A LogRecordProcessor may freely modify logRecord for the duration of the OnEmit call.\n   * If logRecord is needed after OnEmit returns (i.e. for asynchronous processing) only reads are permitted.\n   */\n  _makeReadonly() {\n    this._isReadonly = true;\n  }\n\n  private _truncateToSize(value: api.AttributeValue): api.AttributeValue {\n    const limit = this._logRecordLimits.attributeValueLengthLimit;\n    // Check limit\n    if (limit <= 0) {\n      // Negative values are invalid, so do not truncate\n      api.diag.warn(`Attribute value limit must be positive, got ${limit}`);\n      return value;\n    }\n\n    // String\n    if (typeof value === 'string') {\n      return this._truncateToLimitUtil(value, limit);\n    }\n\n    // Array of strings\n    if (Array.isArray(value)) {\n      return (value as []).map(val =>\n        typeof val === 'string' ? this._truncateToLimitUtil(val, limit) : val\n      );\n    }\n\n    // Other types, no need to apply value length limit\n    return value;\n  }\n\n  private _truncateToLimitUtil(value: string, limit: number): string {\n    if (value.length <= limit) {\n      return value;\n    }\n    return value.substring(0, limit);\n  }\n\n  private _isLogRecordReadonly(): boolean {\n    if (this._isReadonly) {\n      api.diag.warn('Can not execute the operation on emitted log record');\n    }\n    return this._isReadonly;\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type * as logsAPI from '@opentelemetry/api-logs';\nimport type { InstrumentationScope } from '@opentelemetry/core';\nimport { context } from '@opentelemetry/api';\n\nimport { LogRecordImpl } from './LogRecordImpl';\nimport { LoggerProviderSharedState } from './internal/LoggerProviderSharedState';\n\nexport class Logger implements logsAPI.Logger {\n  constructor(\n    public readonly instrumentationScope: InstrumentationScope,\n    private _sharedState: LoggerProviderSharedState\n  ) {}\n\n  public emit(logRecord: logsAPI.LogRecord): void {\n    const currentContext = logRecord.context || context.active();\n    /**\n     * If a Logger was obtained with include_trace_context=true,\n     * the LogRecords it emits MUST automatically include the Trace Context from the active Context,\n     * if Context has not been explicitly set.\n     */\n    const logRecordInstance = new LogRecordImpl(\n      this._sharedState,\n      this.instrumentationScope,\n      {\n        context: currentContext,\n        ...logRecord,\n      }\n    );\n    /**\n     * the explicitly passed Context,\n     * the current Context, or an empty Context if the Logger was obtained with include_trace_context=false\n     */\n    this._sharedState.activeProcessor.onEmit(logRecordInstance, currentContext);\n    /**\n     * A LogRecordProcessor may freely modify logRecord for the duration of the OnEmit call.\n     * If logRecord is needed after OnEmit returns (i.e. for asynchronous processing) only reads are permitted.\n     */\n    logRecordInstance._makeReadonly();\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { getNumberFromEnv } from '@opentelemetry/core';\nimport { LogRecordLimits } from './types';\n\nexport function loadDefaultConfig() {\n  return {\n    forceFlushTimeoutMillis: 30000,\n    logRecordLimits: {\n      attributeValueLengthLimit:\n        getNumberFromEnv('OTEL_LOGRECORD_ATTRIBUTE_VALUE_LENGTH_LIMIT') ??\n        Infinity,\n      attributeCountLimit:\n        getNumberFromEnv('OTEL_LOGRECORD_ATTRIBUTE_COUNT_LIMIT') ?? 128,\n    },\n    includeTraceContext: true,\n  };\n}\n\n/**\n * When general limits are provided and model specific limits are not,\n * configures the model specific limits by using the values from the general ones.\n * @param logRecordLimits User provided limits configuration\n */\nexport function reconfigureLimits(\n  logRecordLimits: LogRecordLimits\n): Required<LogRecordLimits> {\n  return {\n    /**\n     * Reassign log record attribute count limit to use first non null value defined by user or use default value\n     */\n    attributeCountLimit:\n      logRecordLimits.attributeCountLimit ??\n      getNumberFromEnv('OTEL_LOGRECORD_ATTRIBUTE_COUNT_LIMIT') ??\n      getNumberFromEnv('OTEL_ATTRIBUTE_COUNT_LIMIT') ??\n      128,\n    /**\n     * Reassign log record attribute value length limit to use first non null value defined by user or use default value\n     */\n    attributeValueLengthLimit:\n      logRecordLimits.attributeValueLengthLimit ??\n      getNumberFromEnv('OTEL_LOGRECORD_ATTRIBUTE_VALUE_LENGTH_LIMIT') ??\n      getNumberFromEnv('OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT') ??\n      Infinity,\n  };\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Context } from '@opentelemetry/api';\nimport { LogRecordProcessor } from '../LogRecordProcessor';\nimport { ReadableLogRecord } from './ReadableLogRecord';\n\nexport class NoopLogRecordProcessor implements LogRecordProcessor {\n  forceFlush(): Promise<void> {\n    return Promise.resolve();\n  }\n\n  onEmit(_logRecord: ReadableLogRecord, _context: Context): void {}\n\n  shutdown(): Promise<void> {\n    return Promise.resolve();\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { callWithTimeout } from '@opentelemetry/core';\nimport type { Context } from '@opentelemetry/api';\nimport type { LogRecordProcessor } from './LogRecordProcessor';\nimport type { SdkLogRecord } from './export/SdkLogRecord';\n\n/**\n * Implementation of the {@link LogRecordProcessor} that simply forwards all\n * received events to a list of {@link LogRecordProcessor}s.\n */\nexport class MultiLogRecordProcessor implements LogRecordProcessor {\n  constructor(\n    public readonly processors: LogRecordProcessor[],\n    public readonly forceFlushTimeoutMillis: number\n  ) {}\n\n  public async forceFlush(): Promise<void> {\n    const timeout = this.forceFlushTimeoutMillis;\n    await Promise.all(\n      this.processors.map(processor =>\n        callWithTimeout(processor.forceFlush(), timeout)\n      )\n    );\n  }\n\n  public onEmit(logRecord: SdkLogRecord, context?: Context): void {\n    this.processors.forEach(processors =>\n      processors.onEmit(logRecord, context)\n    );\n  }\n\n  public async shutdown(): Promise<void> {\n    await Promise.all(this.processors.map(processor => processor.shutdown()));\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Logger } from '@opentelemetry/api-logs';\nimport { Resource } from '@opentelemetry/resources';\nimport { LogRecordProcessor } from '../LogRecordProcessor';\nimport { LogRecordLimits } from '../types';\nimport { NoopLogRecordProcessor } from '../export/NoopLogRecordProcessor';\nimport { MultiLogRecordProcessor } from '../MultiLogRecordProcessor';\n\nexport class LoggerProviderSharedState {\n  readonly loggers: Map<string, Logger> = new Map();\n  activeProcessor: LogRecordProcessor;\n  readonly registeredLogRecordProcessors: LogRecordProcessor[] = [];\n\n  constructor(\n    readonly resource: Resource,\n    readonly forceFlushTimeoutMillis: number,\n    readonly logRecordLimits: Required<LogRecordLimits>,\n    readonly processors: LogRecordProcessor[]\n  ) {\n    if (processors.length > 0) {\n      this.registeredLogRecordProcessors = processors;\n      this.activeProcessor = new MultiLogRecordProcessor(\n        this.registeredLogRecordProcessors,\n        this.forceFlushTimeoutMillis\n      );\n    } else {\n      this.activeProcessor = new NoopLogRecordProcessor();\n    }\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { diag } from '@opentelemetry/api';\nimport type * as logsAPI from '@opentelemetry/api-logs';\nimport { NOOP_LOGGER } from '@opentelemetry/api-logs';\nimport { defaultResource } from '@opentelemetry/resources';\nimport { BindOnceFuture, merge } from '@opentelemetry/core';\n\nimport type { LoggerProviderConfig } from './types';\nimport { Logger } from './Logger';\nimport { loadDefaultConfig, reconfigureLimits } from './config';\nimport { LoggerProviderSharedState } from './internal/LoggerProviderSharedState';\n\nexport const DEFAULT_LOGGER_NAME = 'unknown';\n\nexport class LoggerProvider implements logsAPI.LoggerProvider {\n  private _shutdownOnce: BindOnceFuture<void>;\n  private readonly _sharedState: LoggerProviderSharedState;\n\n  constructor(config: LoggerProviderConfig = {}) {\n    const mergedConfig = merge({}, loadDefaultConfig(), config);\n    const resource = config.resource ?? defaultResource();\n    this._sharedState = new LoggerProviderSharedState(\n      resource,\n      mergedConfig.forceFlushTimeoutMillis,\n      reconfigureLimits(mergedConfig.logRecordLimits),\n      config?.processors ?? []\n    );\n    this._shutdownOnce = new BindOnceFuture(this._shutdown, this);\n  }\n\n  /**\n   * Get a logger with the configuration of the LoggerProvider.\n   */\n  public getLogger(\n    name: string,\n    version?: string,\n    options?: logsAPI.LoggerOptions\n  ): logsAPI.Logger {\n    if (this._shutdownOnce.isCalled) {\n      diag.warn('A shutdown LoggerProvider cannot provide a Logger');\n      return NOOP_LOGGER;\n    }\n\n    if (!name) {\n      diag.warn('Logger requested without instrumentation scope name.');\n    }\n    const loggerName = name || DEFAULT_LOGGER_NAME;\n    const key = `${loggerName}@${version || ''}:${options?.schemaUrl || ''}`;\n    if (!this._sharedState.loggers.has(key)) {\n      this._sharedState.loggers.set(\n        key,\n        new Logger(\n          { name: loggerName, version, schemaUrl: options?.schemaUrl },\n          this._sharedState\n        )\n      );\n    }\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return this._sharedState.loggers.get(key)!;\n  }\n\n  /**\n   * Notifies all registered LogRecordProcessor to flush any buffered data.\n   *\n   * Returns a promise which is resolved when all flushes are complete.\n   */\n  public forceFlush(): Promise<void> {\n    // do not flush after shutdown\n    if (this._shutdownOnce.isCalled) {\n      diag.warn('invalid attempt to force flush after LoggerProvider shutdown');\n      return this._shutdownOnce.promise;\n    }\n    return this._sharedState.activeProcessor.forceFlush();\n  }\n\n  /**\n   * Flush all buffered data and shut down the LoggerProvider and all registered\n   * LogRecordProcessor.\n   *\n   * Returns a promise which is resolved when all flushes are complete.\n   */\n  public shutdown(): Promise<void> {\n    if (this._shutdownOnce.isCalled) {\n      diag.warn('shutdown may only be called once per LoggerProvider');\n      return this._shutdownOnce.promise;\n    }\n    return this._shutdownOnce.call();\n  }\n\n  private _shutdown(): Promise<void> {\n    return this._sharedState.activeProcessor.shutdown();\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  ExportResultCode,\n  ExportResult,\n  hrTimeToMicroseconds,\n} from '@opentelemetry/core';\n\nimport type { ReadableLogRecord } from './ReadableLogRecord';\nimport type { LogRecordExporter } from './LogRecordExporter';\n\n/**\n * This is implementation of {@link LogRecordExporter} that prints LogRecords to the\n * console. This class can be used for diagnostic purposes.\n *\n * NOTE: This {@link LogRecordExporter} is intended for diagnostics use only, output rendered to the console may change at any time.\n */\n\n/* eslint-disable no-console */\nexport class ConsoleLogRecordExporter implements LogRecordExporter {\n  /**\n   * Export logs.\n   * @param logs\n   * @param resultCallback\n   */\n  public export(\n    logs: ReadableLogRecord[],\n    resultCallback: (result: ExportResult) => void\n  ) {\n    this._sendLogRecords(logs, resultCallback);\n  }\n\n  /**\n   * Shutdown the exporter.\n   */\n  public shutdown(): Promise<void> {\n    return Promise.resolve();\n  }\n\n  /**\n   * converts logRecord info into more readable format\n   * @param logRecord\n   */\n  private _exportInfo(logRecord: ReadableLogRecord) {\n    return {\n      resource: {\n        attributes: logRecord.resource.attributes,\n      },\n      instrumentationScope: logRecord.instrumentationScope,\n      timestamp: hrTimeToMicroseconds(logRecord.hrTime),\n      traceId: logRecord.spanContext?.traceId,\n      spanId: logRecord.spanContext?.spanId,\n      traceFlags: logRecord.spanContext?.traceFlags,\n      severityText: logRecord.severityText,\n      severityNumber: logRecord.severityNumber,\n      body: logRecord.body,\n      attributes: logRecord.attributes,\n    };\n  }\n\n  /**\n   * Showing logs  in console\n   * @param logRecords\n   * @param done\n   */\n  private _sendLogRecords(\n    logRecords: ReadableLogRecord[],\n    done?: (result: ExportResult) => void\n  ): void {\n    for (const logRecord of logRecords) {\n      console.dir(this._exportInfo(logRecord), { depth: 3 });\n    }\n    done?.({ code: ExportResultCode.SUCCESS });\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { ExportResult } from '@opentelemetry/core';\nimport {\n  BindOnceFuture,\n  ExportResultCode,\n  globalErrorHandler,\n  internal,\n} from '@opentelemetry/core';\nimport type { LogRecordExporter } from './LogRecordExporter';\nimport type { LogRecordProcessor } from '../LogRecordProcessor';\nimport type { SdkLogRecord } from './SdkLogRecord';\n\n/**\n * An implementation of the {@link LogRecordProcessor} interface that exports\n * each {@link LogRecord} as it is emitted.\n *\n * NOTE: This {@link LogRecordProcessor} exports every {@link LogRecord}\n * individually instead of batching them together, which can cause significant\n * performance overhead with most exporters. For production use, please consider\n * using the {@link BatchLogRecordProcessor} instead.\n */\nexport class SimpleLogRecordProcessor implements LogRecordProcessor {\n  private _shutdownOnce: BindOnceFuture<void>;\n  private _unresolvedExports: Set<Promise<void>>;\n\n  constructor(private readonly _exporter: LogRecordExporter) {\n    this._shutdownOnce = new BindOnceFuture(this._shutdown, this);\n    this._unresolvedExports = new Set<Promise<void>>();\n  }\n\n  public onEmit(logRecord: SdkLogRecord): void {\n    if (this._shutdownOnce.isCalled) {\n      return;\n    }\n\n    const doExport = () =>\n      internal\n        ._export(this._exporter, [logRecord])\n        .then((result: ExportResult) => {\n          if (result.code !== ExportResultCode.SUCCESS) {\n            globalErrorHandler(\n              result.error ??\n                new Error(\n                  `SimpleLogRecordProcessor: log record export failed (status ${result})`\n                )\n            );\n          }\n        })\n        .catch(globalErrorHandler);\n\n    // Avoid scheduling a promise to make the behavior more predictable and easier to test\n    if (logRecord.resource.asyncAttributesPending) {\n      const exportPromise = logRecord.resource\n        .waitForAsyncAttributes?.()\n        .then(() => {\n          // Using TS Non-null assertion operator because exportPromise could not be null in here\n          // if waitForAsyncAttributes is not present this code will never be reached\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          this._unresolvedExports.delete(exportPromise!);\n          return doExport();\n        }, globalErrorHandler);\n\n      // store the unresolved exports\n      if (exportPromise != null) {\n        this._unresolvedExports.add(exportPromise);\n      }\n    } else {\n      void doExport();\n    }\n  }\n\n  public async forceFlush(): Promise<void> {\n    // await unresolved resources before resolving\n    await Promise.all(Array.from(this._unresolvedExports));\n  }\n\n  public shutdown(): Promise<void> {\n    return this._shutdownOnce.call();\n  }\n\n  private _shutdown(): Promise<void> {\n    return this._exporter.shutdown();\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { ExportResult } from '@opentelemetry/core';\nimport { ExportResultCode } from '@opentelemetry/core';\n\nimport type { ReadableLogRecord } from './ReadableLogRecord';\nimport type { LogRecordExporter } from './LogRecordExporter';\n\n/**\n * This class can be used for testing purposes. It stores the exported LogRecords\n * in a list in memory that can be retrieved using the `getFinishedLogRecords()`\n * method.\n */\nexport class InMemoryLogRecordExporter implements LogRecordExporter {\n  private _finishedLogRecords: ReadableLogRecord[] = [];\n\n  /**\n   * Indicates if the exporter has been \"shutdown.\"\n   * When false, exported log records will not be stored in-memory.\n   */\n  protected _stopped = false;\n\n  public export(\n    logs: ReadableLogRecord[],\n    resultCallback: (result: ExportResult) => void\n  ) {\n    if (this._stopped) {\n      return resultCallback({\n        code: ExportResultCode.FAILED,\n        error: new Error('Exporter has been stopped'),\n      });\n    }\n\n    this._finishedLogRecords.push(...logs);\n    resultCallback({ code: ExportResultCode.SUCCESS });\n  }\n\n  public shutdown(): Promise<void> {\n    this._stopped = true;\n    this.reset();\n    return Promise.resolve();\n  }\n\n  public getFinishedLogRecords(): ReadableLogRecord[] {\n    return this._finishedLogRecords;\n  }\n\n  public reset(): void {\n    this._finishedLogRecords = [];\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { diag } from '@opentelemetry/api';\nimport {\n  ExportResult,\n  ExportResultCode,\n  getNumberFromEnv,\n  globalErrorHandler,\n  BindOnceFuture,\n  internal,\n  callWithTimeout,\n} from '@opentelemetry/core';\n\nimport type { BufferConfig } from '../types';\nimport type { SdkLogRecord } from './SdkLogRecord';\nimport type { LogRecordExporter } from './LogRecordExporter';\nimport type { LogRecordProcessor } from '../LogRecordProcessor';\n\nexport abstract class BatchLogRecordProcessorBase<T extends BufferConfig>\n  implements LogRecordProcessor\n{\n  private readonly _maxExportBatchSize: number;\n  private readonly _maxQueueSize: number;\n  private readonly _scheduledDelayMillis: number;\n  private readonly _exportTimeoutMillis: number;\n\n  private _isExporting = false;\n  private _finishedLogRecords: SdkLogRecord[] = [];\n  private _timer: NodeJS.Timeout | number | undefined;\n  private _shutdownOnce: BindOnceFuture<void>;\n\n  constructor(\n    private readonly _exporter: LogRecordExporter,\n    config?: T\n  ) {\n    this._maxExportBatchSize =\n      config?.maxExportBatchSize ??\n      getNumberFromEnv('OTEL_BLRP_MAX_EXPORT_BATCH_SIZE') ??\n      512;\n    this._maxQueueSize =\n      config?.maxQueueSize ??\n      getNumberFromEnv('OTEL_BLRP_MAX_QUEUE_SIZE') ??\n      2048;\n    this._scheduledDelayMillis =\n      config?.scheduledDelayMillis ??\n      getNumberFromEnv('OTEL_BLRP_SCHEDULE_DELAY') ??\n      5000;\n    this._exportTimeoutMillis =\n      config?.exportTimeoutMillis ??\n      getNumberFromEnv('OTEL_BLRP_EXPORT_TIMEOUT') ??\n      30000;\n\n    this._shutdownOnce = new BindOnceFuture(this._shutdown, this);\n\n    if (this._maxExportBatchSize > this._maxQueueSize) {\n      diag.warn(\n        'BatchLogRecordProcessor: maxExportBatchSize must be smaller or equal to maxQueueSize, setting maxExportBatchSize to match maxQueueSize'\n      );\n      this._maxExportBatchSize = this._maxQueueSize;\n    }\n  }\n\n  public onEmit(logRecord: SdkLogRecord): void {\n    if (this._shutdownOnce.isCalled) {\n      return;\n    }\n    this._addToBuffer(logRecord);\n  }\n\n  public forceFlush(): Promise<void> {\n    if (this._shutdownOnce.isCalled) {\n      return this._shutdownOnce.promise;\n    }\n    return this._flushAll();\n  }\n\n  public shutdown(): Promise<void> {\n    return this._shutdownOnce.call();\n  }\n\n  private async _shutdown(): Promise<void> {\n    this.onShutdown();\n    await this._flushAll();\n    await this._exporter.shutdown();\n  }\n\n  /** Add a LogRecord in the buffer. */\n  private _addToBuffer(logRecord: SdkLogRecord) {\n    if (this._finishedLogRecords.length >= this._maxQueueSize) {\n      return;\n    }\n    this._finishedLogRecords.push(logRecord);\n    this._maybeStartTimer();\n  }\n\n  /**\n   * Send all LogRecords to the exporter respecting the batch size limit\n   * This function is used only on forceFlush or shutdown,\n   * for all other cases _flush should be used\n   * */\n  private _flushAll(): Promise<void> {\n    return new Promise((resolve, reject) => {\n      const promises = [];\n      const batchCount = Math.ceil(\n        this._finishedLogRecords.length / this._maxExportBatchSize\n      );\n      for (let i = 0; i < batchCount; i++) {\n        promises.push(this._flushOneBatch());\n      }\n      Promise.all(promises)\n        .then(() => {\n          resolve();\n        })\n        .catch(reject);\n    });\n  }\n\n  private _flushOneBatch(): Promise<void> {\n    this._clearTimer();\n    if (this._finishedLogRecords.length === 0) {\n      return Promise.resolve();\n    }\n    return new Promise((resolve, reject) => {\n      callWithTimeout(\n        this._export(\n          this._finishedLogRecords.splice(0, this._maxExportBatchSize)\n        ),\n        this._exportTimeoutMillis\n      )\n        .then(() => resolve())\n        .catch(reject);\n    });\n  }\n\n  private _maybeStartTimer() {\n    if (this._isExporting) return;\n    const flush = () => {\n      this._isExporting = true;\n      this._flushOneBatch()\n        .then(() => {\n          this._isExporting = false;\n          if (this._finishedLogRecords.length > 0) {\n            this._clearTimer();\n            this._maybeStartTimer();\n          }\n        })\n        .catch(e => {\n          this._isExporting = false;\n          globalErrorHandler(e);\n        });\n    };\n    // we only wait if the queue doesn't have enough elements yet\n    if (this._finishedLogRecords.length >= this._maxExportBatchSize) {\n      return flush();\n    }\n    if (this._timer !== undefined) return;\n    this._timer = setTimeout(() => flush(), this._scheduledDelayMillis);\n    // depending on runtime, this may be a 'number' or NodeJS.Timeout\n    if (typeof this._timer !== 'number') {\n      this._timer.unref();\n    }\n  }\n\n  private _clearTimer() {\n    if (this._timer !== undefined) {\n      clearTimeout(this._timer);\n      this._timer = undefined;\n    }\n  }\n\n  private _export(logRecords: SdkLogRecord[]): Promise<void> {\n    const doExport = () =>\n      internal\n        ._export(this._exporter, logRecords)\n        .then((result: ExportResult) => {\n          if (result.code !== ExportResultCode.SUCCESS) {\n            globalErrorHandler(\n              result.error ??\n                new Error(\n                  `BatchLogRecordProcessor: log record export failed (status ${result})`\n                )\n            );\n          }\n        })\n        .catch(globalErrorHandler);\n\n    const pendingResources = logRecords\n      .map(logRecord => logRecord.resource)\n      .filter(resource => resource.asyncAttributesPending);\n\n    // Avoid scheduling a promise to make the behavior more predictable and easier to test\n    if (pendingResources.length === 0) {\n      return doExport();\n    } else {\n      return Promise.all(\n        pendingResources.map(resource => resource.waitForAsyncAttributes?.())\n      ).then(doExport, globalErrorHandler);\n    }\n  }\n\n  protected abstract onShutdown(): void;\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { LogRecordExporter } from './../../../export/LogRecordExporter';\nimport type { BatchLogRecordProcessorBrowserConfig } from '../../../types';\nimport { BatchLogRecordProcessorBase } from '../../../export/BatchLogRecordProcessorBase';\n\nexport class BatchLogRecordProcessor extends BatchLogRecordProcessorBase<BatchLogRecordProcessorBrowserConfig> {\n  private _visibilityChangeListener?: () => void;\n  private _pageHideListener?: () => void;\n\n  constructor(\n    exporter: LogRecordExporter,\n    config?: BatchLogRecordProcessorBrowserConfig\n  ) {\n    super(exporter, config);\n    this._onInit(config);\n  }\n\n  protected onShutdown(): void {\n    if (typeof document === 'undefined') {\n      return;\n    }\n    if (this._visibilityChangeListener) {\n      document.removeEventListener(\n        'visibilitychange',\n        this._visibilityChangeListener\n      );\n    }\n    if (this._pageHideListener) {\n      document.removeEventListener('pagehide', this._pageHideListener);\n    }\n  }\n\n  private _onInit(config?: BatchLogRecordProcessorBrowserConfig): void {\n    if (\n      config?.disableAutoFlushOnDocumentHide === true ||\n      typeof document === 'undefined'\n    ) {\n      return;\n    }\n    this._visibilityChangeListener = () => {\n      if (document.visibilityState === 'hidden') {\n        void this.forceFlush();\n      }\n    };\n    this._pageHideListener = () => {\n      void this.forceFlush();\n    };\n    document.addEventListener(\n      'visibilitychange',\n      this._visibilityChangeListener\n    );\n\n    // use 'pagehide' event as a fallback for Safari; see https://bugs.webkit.org/show_bug.cgi?id=116769\n    document.addEventListener('pagehide', this._pageHideListener);\n  }\n}\n"],
  "mappings": "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",
  "names": ["context", "context"]
}
