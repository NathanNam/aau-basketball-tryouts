import {
  BindOnceFuture,
  ExportResultCode,
  callWithTimeout,
  defaultResource,
  getNumberFromEnv,
  globalErrorHandler,
  hrTimeToMicroseconds,
  internal,
  isAttributeValue,
  merge,
  timeInputToHrTime
} from "./chunk-MUUYURUO.js";
import "./chunk-JOJVESY7.js";
import {
  context,
  diag,
  isSpanContextValid,
  trace
} from "./chunk-WWXHSA53.js";
import {
  NOOP_LOGGER
} from "./chunk-CXVDPRWL.js";
import "./chunk-G3PMV62Z.js";

// node_modules/.pnpm/@opentelemetry+sdk-logs@0.208.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-logs/build/esm/LogRecordImpl.js
var LogRecordImpl = class {
  hrTime;
  hrTimeObserved;
  spanContext;
  resource;
  instrumentationScope;
  attributes = {};
  _severityText;
  _severityNumber;
  _body;
  _eventName;
  totalAttributesCount = 0;
  _isReadonly = false;
  _logRecordLimits;
  set severityText(severityText) {
    if (this._isLogRecordReadonly()) {
      return;
    }
    this._severityText = severityText;
  }
  get severityText() {
    return this._severityText;
  }
  set severityNumber(severityNumber) {
    if (this._isLogRecordReadonly()) {
      return;
    }
    this._severityNumber = severityNumber;
  }
  get severityNumber() {
    return this._severityNumber;
  }
  set body(body) {
    if (this._isLogRecordReadonly()) {
      return;
    }
    this._body = body;
  }
  get body() {
    return this._body;
  }
  get eventName() {
    return this._eventName;
  }
  set eventName(eventName) {
    if (this._isLogRecordReadonly()) {
      return;
    }
    this._eventName = eventName;
  }
  get droppedAttributesCount() {
    return this.totalAttributesCount - Object.keys(this.attributes).length;
  }
  constructor(_sharedState, instrumentationScope, logRecord) {
    const { timestamp, observedTimestamp, eventName, severityNumber, severityText, body, attributes = {}, context: context2 } = logRecord;
    const now = Date.now();
    this.hrTime = timeInputToHrTime(timestamp ?? now);
    this.hrTimeObserved = timeInputToHrTime(observedTimestamp ?? now);
    if (context2) {
      const spanContext = trace.getSpanContext(context2);
      if (spanContext && isSpanContextValid(spanContext)) {
        this.spanContext = spanContext;
      }
    }
    this.severityNumber = severityNumber;
    this.severityText = severityText;
    this.body = body;
    this.resource = _sharedState.resource;
    this.instrumentationScope = instrumentationScope;
    this._logRecordLimits = _sharedState.logRecordLimits;
    this._eventName = eventName;
    this.setAttributes(attributes);
  }
  setAttribute(key, value) {
    if (this._isLogRecordReadonly()) {
      return this;
    }
    if (value === null) {
      return this;
    }
    if (key.length === 0) {
      diag.warn(`Invalid attribute key: ${key}`);
      return this;
    }
    if (!isAttributeValue(value) && !(typeof value === "object" && !Array.isArray(value) && Object.keys(value).length > 0)) {
      diag.warn(`Invalid attribute value set for key: ${key}`);
      return this;
    }
    this.totalAttributesCount += 1;
    if (Object.keys(this.attributes).length >= this._logRecordLimits.attributeCountLimit && !Object.prototype.hasOwnProperty.call(this.attributes, key)) {
      if (this.droppedAttributesCount === 1) {
        diag.warn("Dropping extra attributes.");
      }
      return this;
    }
    if (isAttributeValue(value)) {
      this.attributes[key] = this._truncateToSize(value);
    } else {
      this.attributes[key] = value;
    }
    return this;
  }
  setAttributes(attributes) {
    for (const [k, v] of Object.entries(attributes)) {
      this.setAttribute(k, v);
    }
    return this;
  }
  setBody(body) {
    this.body = body;
    return this;
  }
  setEventName(eventName) {
    this.eventName = eventName;
    return this;
  }
  setSeverityNumber(severityNumber) {
    this.severityNumber = severityNumber;
    return this;
  }
  setSeverityText(severityText) {
    this.severityText = severityText;
    return this;
  }
  /**
   * @internal
   * A LogRecordProcessor may freely modify logRecord for the duration of the OnEmit call.
   * If logRecord is needed after OnEmit returns (i.e. for asynchronous processing) only reads are permitted.
   */
  _makeReadonly() {
    this._isReadonly = true;
  }
  _truncateToSize(value) {
    const limit = this._logRecordLimits.attributeValueLengthLimit;
    if (limit <= 0) {
      diag.warn(`Attribute value limit must be positive, got ${limit}`);
      return value;
    }
    if (typeof value === "string") {
      return this._truncateToLimitUtil(value, limit);
    }
    if (Array.isArray(value)) {
      return value.map((val) => typeof val === "string" ? this._truncateToLimitUtil(val, limit) : val);
    }
    return value;
  }
  _truncateToLimitUtil(value, limit) {
    if (value.length <= limit) {
      return value;
    }
    return value.substring(0, limit);
  }
  _isLogRecordReadonly() {
    if (this._isReadonly) {
      diag.warn("Can not execute the operation on emitted log record");
    }
    return this._isReadonly;
  }
};

// node_modules/.pnpm/@opentelemetry+sdk-logs@0.208.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-logs/build/esm/Logger.js
var Logger = class {
  instrumentationScope;
  _sharedState;
  constructor(instrumentationScope, _sharedState) {
    this.instrumentationScope = instrumentationScope;
    this._sharedState = _sharedState;
  }
  emit(logRecord) {
    const currentContext = logRecord.context || context.active();
    const logRecordInstance = new LogRecordImpl(this._sharedState, this.instrumentationScope, {
      context: currentContext,
      ...logRecord
    });
    this._sharedState.activeProcessor.onEmit(logRecordInstance, currentContext);
    logRecordInstance._makeReadonly();
  }
};

// node_modules/.pnpm/@opentelemetry+sdk-logs@0.208.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-logs/build/esm/config.js
function loadDefaultConfig() {
  return {
    forceFlushTimeoutMillis: 3e4,
    logRecordLimits: {
      attributeValueLengthLimit: getNumberFromEnv("OTEL_LOGRECORD_ATTRIBUTE_VALUE_LENGTH_LIMIT") ?? Infinity,
      attributeCountLimit: getNumberFromEnv("OTEL_LOGRECORD_ATTRIBUTE_COUNT_LIMIT") ?? 128
    },
    includeTraceContext: true
  };
}
function reconfigureLimits(logRecordLimits) {
  return {
    /**
     * Reassign log record attribute count limit to use first non null value defined by user or use default value
     */
    attributeCountLimit: logRecordLimits.attributeCountLimit ?? getNumberFromEnv("OTEL_LOGRECORD_ATTRIBUTE_COUNT_LIMIT") ?? getNumberFromEnv("OTEL_ATTRIBUTE_COUNT_LIMIT") ?? 128,
    /**
     * Reassign log record attribute value length limit to use first non null value defined by user or use default value
     */
    attributeValueLengthLimit: logRecordLimits.attributeValueLengthLimit ?? getNumberFromEnv("OTEL_LOGRECORD_ATTRIBUTE_VALUE_LENGTH_LIMIT") ?? getNumberFromEnv("OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT") ?? Infinity
  };
}

// node_modules/.pnpm/@opentelemetry+sdk-logs@0.208.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-logs/build/esm/export/NoopLogRecordProcessor.js
var NoopLogRecordProcessor = class {
  forceFlush() {
    return Promise.resolve();
  }
  onEmit(_logRecord, _context) {
  }
  shutdown() {
    return Promise.resolve();
  }
};

// node_modules/.pnpm/@opentelemetry+sdk-logs@0.208.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-logs/build/esm/MultiLogRecordProcessor.js
var MultiLogRecordProcessor = class {
  processors;
  forceFlushTimeoutMillis;
  constructor(processors, forceFlushTimeoutMillis) {
    this.processors = processors;
    this.forceFlushTimeoutMillis = forceFlushTimeoutMillis;
  }
  async forceFlush() {
    const timeout = this.forceFlushTimeoutMillis;
    await Promise.all(this.processors.map((processor) => callWithTimeout(processor.forceFlush(), timeout)));
  }
  onEmit(logRecord, context2) {
    this.processors.forEach((processors) => processors.onEmit(logRecord, context2));
  }
  async shutdown() {
    await Promise.all(this.processors.map((processor) => processor.shutdown()));
  }
};

// node_modules/.pnpm/@opentelemetry+sdk-logs@0.208.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-logs/build/esm/internal/LoggerProviderSharedState.js
var LoggerProviderSharedState = class {
  resource;
  forceFlushTimeoutMillis;
  logRecordLimits;
  processors;
  loggers = /* @__PURE__ */ new Map();
  activeProcessor;
  registeredLogRecordProcessors = [];
  constructor(resource, forceFlushTimeoutMillis, logRecordLimits, processors) {
    this.resource = resource;
    this.forceFlushTimeoutMillis = forceFlushTimeoutMillis;
    this.logRecordLimits = logRecordLimits;
    this.processors = processors;
    if (processors.length > 0) {
      this.registeredLogRecordProcessors = processors;
      this.activeProcessor = new MultiLogRecordProcessor(this.registeredLogRecordProcessors, this.forceFlushTimeoutMillis);
    } else {
      this.activeProcessor = new NoopLogRecordProcessor();
    }
  }
};

// node_modules/.pnpm/@opentelemetry+sdk-logs@0.208.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-logs/build/esm/LoggerProvider.js
var DEFAULT_LOGGER_NAME = "unknown";
var LoggerProvider = class {
  _shutdownOnce;
  _sharedState;
  constructor(config = {}) {
    const mergedConfig = merge({}, loadDefaultConfig(), config);
    const resource = config.resource ?? defaultResource();
    this._sharedState = new LoggerProviderSharedState(resource, mergedConfig.forceFlushTimeoutMillis, reconfigureLimits(mergedConfig.logRecordLimits), config?.processors ?? []);
    this._shutdownOnce = new BindOnceFuture(this._shutdown, this);
  }
  /**
   * Get a logger with the configuration of the LoggerProvider.
   */
  getLogger(name, version, options) {
    if (this._shutdownOnce.isCalled) {
      diag.warn("A shutdown LoggerProvider cannot provide a Logger");
      return NOOP_LOGGER;
    }
    if (!name) {
      diag.warn("Logger requested without instrumentation scope name.");
    }
    const loggerName = name || DEFAULT_LOGGER_NAME;
    const key = `${loggerName}@${version || ""}:${options?.schemaUrl || ""}`;
    if (!this._sharedState.loggers.has(key)) {
      this._sharedState.loggers.set(key, new Logger({ name: loggerName, version, schemaUrl: options?.schemaUrl }, this._sharedState));
    }
    return this._sharedState.loggers.get(key);
  }
  /**
   * Notifies all registered LogRecordProcessor to flush any buffered data.
   *
   * Returns a promise which is resolved when all flushes are complete.
   */
  forceFlush() {
    if (this._shutdownOnce.isCalled) {
      diag.warn("invalid attempt to force flush after LoggerProvider shutdown");
      return this._shutdownOnce.promise;
    }
    return this._sharedState.activeProcessor.forceFlush();
  }
  /**
   * Flush all buffered data and shut down the LoggerProvider and all registered
   * LogRecordProcessor.
   *
   * Returns a promise which is resolved when all flushes are complete.
   */
  shutdown() {
    if (this._shutdownOnce.isCalled) {
      diag.warn("shutdown may only be called once per LoggerProvider");
      return this._shutdownOnce.promise;
    }
    return this._shutdownOnce.call();
  }
  _shutdown() {
    return this._sharedState.activeProcessor.shutdown();
  }
};

// node_modules/.pnpm/@opentelemetry+sdk-logs@0.208.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-logs/build/esm/export/ConsoleLogRecordExporter.js
var ConsoleLogRecordExporter = class {
  /**
   * Export logs.
   * @param logs
   * @param resultCallback
   */
  export(logs, resultCallback) {
    this._sendLogRecords(logs, resultCallback);
  }
  /**
   * Shutdown the exporter.
   */
  shutdown() {
    return Promise.resolve();
  }
  /**
   * converts logRecord info into more readable format
   * @param logRecord
   */
  _exportInfo(logRecord) {
    return {
      resource: {
        attributes: logRecord.resource.attributes
      },
      instrumentationScope: logRecord.instrumentationScope,
      timestamp: hrTimeToMicroseconds(logRecord.hrTime),
      traceId: logRecord.spanContext?.traceId,
      spanId: logRecord.spanContext?.spanId,
      traceFlags: logRecord.spanContext?.traceFlags,
      severityText: logRecord.severityText,
      severityNumber: logRecord.severityNumber,
      body: logRecord.body,
      attributes: logRecord.attributes
    };
  }
  /**
   * Showing logs  in console
   * @param logRecords
   * @param done
   */
  _sendLogRecords(logRecords, done) {
    for (const logRecord of logRecords) {
      console.dir(this._exportInfo(logRecord), { depth: 3 });
    }
    done?.({ code: ExportResultCode.SUCCESS });
  }
};

// node_modules/.pnpm/@opentelemetry+sdk-logs@0.208.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-logs/build/esm/export/SimpleLogRecordProcessor.js
var SimpleLogRecordProcessor = class {
  _exporter;
  _shutdownOnce;
  _unresolvedExports;
  constructor(_exporter) {
    this._exporter = _exporter;
    this._shutdownOnce = new BindOnceFuture(this._shutdown, this);
    this._unresolvedExports = /* @__PURE__ */ new Set();
  }
  onEmit(logRecord) {
    if (this._shutdownOnce.isCalled) {
      return;
    }
    const doExport = () => internal._export(this._exporter, [logRecord]).then((result) => {
      if (result.code !== ExportResultCode.SUCCESS) {
        globalErrorHandler(result.error ?? new Error(`SimpleLogRecordProcessor: log record export failed (status ${result})`));
      }
    }).catch(globalErrorHandler);
    if (logRecord.resource.asyncAttributesPending) {
      const exportPromise = logRecord.resource.waitForAsyncAttributes?.().then(() => {
        this._unresolvedExports.delete(exportPromise);
        return doExport();
      }, globalErrorHandler);
      if (exportPromise != null) {
        this._unresolvedExports.add(exportPromise);
      }
    } else {
      void doExport();
    }
  }
  async forceFlush() {
    await Promise.all(Array.from(this._unresolvedExports));
  }
  shutdown() {
    return this._shutdownOnce.call();
  }
  _shutdown() {
    return this._exporter.shutdown();
  }
};

// node_modules/.pnpm/@opentelemetry+sdk-logs@0.208.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-logs/build/esm/export/InMemoryLogRecordExporter.js
var InMemoryLogRecordExporter = class {
  _finishedLogRecords = [];
  /**
   * Indicates if the exporter has been "shutdown."
   * When false, exported log records will not be stored in-memory.
   */
  _stopped = false;
  export(logs, resultCallback) {
    if (this._stopped) {
      return resultCallback({
        code: ExportResultCode.FAILED,
        error: new Error("Exporter has been stopped")
      });
    }
    this._finishedLogRecords.push(...logs);
    resultCallback({ code: ExportResultCode.SUCCESS });
  }
  shutdown() {
    this._stopped = true;
    this.reset();
    return Promise.resolve();
  }
  getFinishedLogRecords() {
    return this._finishedLogRecords;
  }
  reset() {
    this._finishedLogRecords = [];
  }
};

// node_modules/.pnpm/@opentelemetry+sdk-logs@0.208.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-logs/build/esm/export/BatchLogRecordProcessorBase.js
var BatchLogRecordProcessorBase = class {
  _exporter;
  _maxExportBatchSize;
  _maxQueueSize;
  _scheduledDelayMillis;
  _exportTimeoutMillis;
  _isExporting = false;
  _finishedLogRecords = [];
  _timer;
  _shutdownOnce;
  constructor(_exporter, config) {
    this._exporter = _exporter;
    this._maxExportBatchSize = config?.maxExportBatchSize ?? getNumberFromEnv("OTEL_BLRP_MAX_EXPORT_BATCH_SIZE") ?? 512;
    this._maxQueueSize = config?.maxQueueSize ?? getNumberFromEnv("OTEL_BLRP_MAX_QUEUE_SIZE") ?? 2048;
    this._scheduledDelayMillis = config?.scheduledDelayMillis ?? getNumberFromEnv("OTEL_BLRP_SCHEDULE_DELAY") ?? 5e3;
    this._exportTimeoutMillis = config?.exportTimeoutMillis ?? getNumberFromEnv("OTEL_BLRP_EXPORT_TIMEOUT") ?? 3e4;
    this._shutdownOnce = new BindOnceFuture(this._shutdown, this);
    if (this._maxExportBatchSize > this._maxQueueSize) {
      diag.warn("BatchLogRecordProcessor: maxExportBatchSize must be smaller or equal to maxQueueSize, setting maxExportBatchSize to match maxQueueSize");
      this._maxExportBatchSize = this._maxQueueSize;
    }
  }
  onEmit(logRecord) {
    if (this._shutdownOnce.isCalled) {
      return;
    }
    this._addToBuffer(logRecord);
  }
  forceFlush() {
    if (this._shutdownOnce.isCalled) {
      return this._shutdownOnce.promise;
    }
    return this._flushAll();
  }
  shutdown() {
    return this._shutdownOnce.call();
  }
  async _shutdown() {
    this.onShutdown();
    await this._flushAll();
    await this._exporter.shutdown();
  }
  /** Add a LogRecord in the buffer. */
  _addToBuffer(logRecord) {
    if (this._finishedLogRecords.length >= this._maxQueueSize) {
      return;
    }
    this._finishedLogRecords.push(logRecord);
    this._maybeStartTimer();
  }
  /**
   * Send all LogRecords to the exporter respecting the batch size limit
   * This function is used only on forceFlush or shutdown,
   * for all other cases _flush should be used
   * */
  _flushAll() {
    return new Promise((resolve, reject) => {
      const promises = [];
      const batchCount = Math.ceil(this._finishedLogRecords.length / this._maxExportBatchSize);
      for (let i = 0; i < batchCount; i++) {
        promises.push(this._flushOneBatch());
      }
      Promise.all(promises).then(() => {
        resolve();
      }).catch(reject);
    });
  }
  _flushOneBatch() {
    this._clearTimer();
    if (this._finishedLogRecords.length === 0) {
      return Promise.resolve();
    }
    return new Promise((resolve, reject) => {
      callWithTimeout(this._export(this._finishedLogRecords.splice(0, this._maxExportBatchSize)), this._exportTimeoutMillis).then(() => resolve()).catch(reject);
    });
  }
  _maybeStartTimer() {
    if (this._isExporting)
      return;
    const flush = () => {
      this._isExporting = true;
      this._flushOneBatch().then(() => {
        this._isExporting = false;
        if (this._finishedLogRecords.length > 0) {
          this._clearTimer();
          this._maybeStartTimer();
        }
      }).catch((e) => {
        this._isExporting = false;
        globalErrorHandler(e);
      });
    };
    if (this._finishedLogRecords.length >= this._maxExportBatchSize) {
      return flush();
    }
    if (this._timer !== void 0)
      return;
    this._timer = setTimeout(() => flush(), this._scheduledDelayMillis);
    if (typeof this._timer !== "number") {
      this._timer.unref();
    }
  }
  _clearTimer() {
    if (this._timer !== void 0) {
      clearTimeout(this._timer);
      this._timer = void 0;
    }
  }
  _export(logRecords) {
    const doExport = () => internal._export(this._exporter, logRecords).then((result) => {
      if (result.code !== ExportResultCode.SUCCESS) {
        globalErrorHandler(result.error ?? new Error(`BatchLogRecordProcessor: log record export failed (status ${result})`));
      }
    }).catch(globalErrorHandler);
    const pendingResources = logRecords.map((logRecord) => logRecord.resource).filter((resource) => resource.asyncAttributesPending);
    if (pendingResources.length === 0) {
      return doExport();
    } else {
      return Promise.all(pendingResources.map((resource) => resource.waitForAsyncAttributes?.())).then(doExport, globalErrorHandler);
    }
  }
};

// node_modules/.pnpm/@opentelemetry+sdk-logs@0.208.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-logs/build/esm/platform/browser/export/BatchLogRecordProcessor.js
var BatchLogRecordProcessor = class extends BatchLogRecordProcessorBase {
  _visibilityChangeListener;
  _pageHideListener;
  constructor(exporter, config) {
    super(exporter, config);
    this._onInit(config);
  }
  onShutdown() {
    if (typeof document === "undefined") {
      return;
    }
    if (this._visibilityChangeListener) {
      document.removeEventListener("visibilitychange", this._visibilityChangeListener);
    }
    if (this._pageHideListener) {
      document.removeEventListener("pagehide", this._pageHideListener);
    }
  }
  _onInit(config) {
    if (config?.disableAutoFlushOnDocumentHide === true || typeof document === "undefined") {
      return;
    }
    this._visibilityChangeListener = () => {
      if (document.visibilityState === "hidden") {
        void this.forceFlush();
      }
    };
    this._pageHideListener = () => {
      void this.forceFlush();
    };
    document.addEventListener("visibilitychange", this._visibilityChangeListener);
    document.addEventListener("pagehide", this._pageHideListener);
  }
};
export {
  BatchLogRecordProcessor,
  ConsoleLogRecordExporter,
  InMemoryLogRecordExporter,
  LoggerProvider,
  SimpleLogRecordProcessor
};
//# sourceMappingURL=@opentelemetry_sdk-logs.js.map
