{
  "version": 3,
  "sources": ["../../.pnpm/@opentelemetry+sdk-trace-base@2.2.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-trace-base/src/enums.ts", "../../.pnpm/@opentelemetry+sdk-trace-base@2.2.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-trace-base/src/Span.ts", "../../.pnpm/@opentelemetry+sdk-trace-base@2.2.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-trace-base/src/Sampler.ts", "../../.pnpm/@opentelemetry+sdk-trace-base@2.2.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-trace-base/src/sampler/AlwaysOffSampler.ts", "../../.pnpm/@opentelemetry+sdk-trace-base@2.2.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-trace-base/src/sampler/AlwaysOnSampler.ts", "../../.pnpm/@opentelemetry+sdk-trace-base@2.2.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-trace-base/src/sampler/ParentBasedSampler.ts", "../../.pnpm/@opentelemetry+sdk-trace-base@2.2.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-trace-base/src/sampler/TraceIdRatioBasedSampler.ts", "../../.pnpm/@opentelemetry+sdk-trace-base@2.2.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-trace-base/src/config.ts", "../../.pnpm/@opentelemetry+sdk-trace-base@2.2.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-trace-base/src/utility.ts", "../../.pnpm/@opentelemetry+sdk-trace-base@2.2.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-trace-base/src/export/BatchSpanProcessorBase.ts", "../../.pnpm/@opentelemetry+sdk-trace-base@2.2.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-trace-base/src/platform/browser/export/BatchSpanProcessor.ts", "../../.pnpm/@opentelemetry+sdk-trace-base@2.2.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-trace-base/src/platform/browser/RandomIdGenerator.ts", "../../.pnpm/@opentelemetry+sdk-trace-base@2.2.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-trace-base/src/Tracer.ts", "../../.pnpm/@opentelemetry+sdk-trace-base@2.2.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-trace-base/src/MultiSpanProcessor.ts", "../../.pnpm/@opentelemetry+sdk-trace-base@2.2.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-trace-base/src/BasicTracerProvider.ts", "../../.pnpm/@opentelemetry+sdk-trace-base@2.2.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-trace-base/src/export/ConsoleSpanExporter.ts", "../../.pnpm/@opentelemetry+sdk-trace-base@2.2.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-trace-base/src/export/InMemorySpanExporter.ts", "../../.pnpm/@opentelemetry+sdk-trace-base@2.2.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-trace-base/src/export/SimpleSpanProcessor.ts", "../../.pnpm/@opentelemetry+sdk-trace-base@2.2.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-trace-base/src/export/NoopSpanProcessor.ts", "../../.pnpm/@opentelemetry+sdk-trace-web@2.2.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-trace-web/src/StackContextManager.ts", "../../.pnpm/@opentelemetry+sdk-trace-web@2.2.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-trace-web/src/WebTracerProvider.ts", "../../.pnpm/@opentelemetry+sdk-trace-web@2.2.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-trace-web/src/enums/PerformanceTimingNames.ts", "../../.pnpm/@opentelemetry+sdk-trace-web@2.2.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-trace-web/src/semconv.ts", "../../.pnpm/@opentelemetry+sdk-trace-web@2.2.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-trace-web/src/utils.ts"],
  "sourcesContent": ["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// Event name definitions\nexport const ExceptionEventName = 'exception';\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Context,\n  diag,\n  Exception,\n  HrTime,\n  Link,\n  Span as APISpan,\n  Attributes,\n  AttributeValue,\n  SpanContext,\n  SpanKind,\n  SpanStatus,\n  SpanStatusCode,\n  TimeInput,\n} from '@opentelemetry/api';\nimport {\n  addHrTimes,\n  millisToHrTime,\n  getTimeOrigin,\n  hrTime,\n  hrTimeDuration,\n  InstrumentationScope,\n  isAttributeValue,\n  isTimeInput,\n  isTimeInputHrTime,\n  otperformance,\n  sanitizeAttributes,\n} from '@opentelemetry/core';\nimport { Resource } from '@opentelemetry/resources';\nimport {\n  ATTR_EXCEPTION_MESSAGE,\n  ATTR_EXCEPTION_STACKTRACE,\n  ATTR_EXCEPTION_TYPE,\n} from '@opentelemetry/semantic-conventions';\nimport { ReadableSpan } from './export/ReadableSpan';\nimport { ExceptionEventName } from './enums';\nimport { SpanProcessor } from './SpanProcessor';\nimport { TimedEvent } from './TimedEvent';\nimport { SpanLimits } from './types';\n\n/**\n * This type provides the properties of @link{ReadableSpan} at the same time\n * of the Span API\n */\nexport type Span = APISpan & ReadableSpan;\n\ninterface SpanOptions {\n  resource: Resource;\n  scope: InstrumentationScope;\n  context: Context;\n  spanContext: SpanContext;\n  name: string;\n  kind: SpanKind;\n  parentSpanContext?: SpanContext;\n  links?: Link[];\n  startTime?: TimeInput;\n  attributes?: Attributes;\n  spanLimits: SpanLimits;\n  spanProcessor: SpanProcessor;\n}\n\n/**\n * This class represents a span.\n */\nexport class SpanImpl implements Span {\n  // Below properties are included to implement ReadableSpan for export\n  // purposes but are not intended to be written-to directly.\n  private readonly _spanContext: SpanContext;\n  readonly kind: SpanKind;\n  readonly parentSpanContext?: SpanContext;\n  readonly attributes: Attributes = {};\n  readonly links: Link[] = [];\n  readonly events: TimedEvent[] = [];\n  readonly startTime: HrTime;\n  readonly resource: Resource;\n  readonly instrumentationScope: InstrumentationScope;\n\n  private _droppedAttributesCount = 0;\n  private _droppedEventsCount: number = 0;\n  private _droppedLinksCount: number = 0;\n\n  name: string;\n  status: SpanStatus = {\n    code: SpanStatusCode.UNSET,\n  };\n  endTime: HrTime = [0, 0];\n  private _ended = false;\n  private _duration: HrTime = [-1, -1];\n  private readonly _spanProcessor: SpanProcessor;\n  private readonly _spanLimits: SpanLimits;\n  private readonly _attributeValueLengthLimit: number;\n\n  private readonly _performanceStartTime: number;\n  private readonly _performanceOffset: number;\n  private readonly _startTimeProvided: boolean;\n\n  /**\n   * Constructs a new SpanImpl instance.\n   */\n  constructor(opts: SpanOptions) {\n    const now = Date.now();\n\n    this._spanContext = opts.spanContext;\n    this._performanceStartTime = otperformance.now();\n    this._performanceOffset =\n      now - (this._performanceStartTime + getTimeOrigin());\n    this._startTimeProvided = opts.startTime != null;\n    this._spanLimits = opts.spanLimits;\n    this._attributeValueLengthLimit =\n      this._spanLimits.attributeValueLengthLimit || 0;\n    this._spanProcessor = opts.spanProcessor;\n\n    this.name = opts.name;\n    this.parentSpanContext = opts.parentSpanContext;\n    this.kind = opts.kind;\n    this.links = opts.links || [];\n    this.startTime = this._getTime(opts.startTime ?? now);\n    this.resource = opts.resource;\n    this.instrumentationScope = opts.scope;\n\n    if (opts.attributes != null) {\n      this.setAttributes(opts.attributes);\n    }\n\n    this._spanProcessor.onStart(this, opts.context);\n  }\n\n  spanContext(): SpanContext {\n    return this._spanContext;\n  }\n\n  setAttribute(key: string, value?: AttributeValue): this;\n  setAttribute(key: string, value: unknown): this {\n    if (value == null || this._isSpanEnded()) return this;\n    if (key.length === 0) {\n      diag.warn(`Invalid attribute key: ${key}`);\n      return this;\n    }\n    if (!isAttributeValue(value)) {\n      diag.warn(`Invalid attribute value set for key: ${key}`);\n      return this;\n    }\n\n    const { attributeCountLimit } = this._spanLimits;\n\n    if (\n      attributeCountLimit !== undefined &&\n      Object.keys(this.attributes).length >= attributeCountLimit &&\n      !Object.prototype.hasOwnProperty.call(this.attributes, key)\n    ) {\n      this._droppedAttributesCount++;\n      return this;\n    }\n    this.attributes[key] = this._truncateToSize(value);\n    return this;\n  }\n\n  setAttributes(attributes: Attributes): this {\n    for (const [k, v] of Object.entries(attributes)) {\n      this.setAttribute(k, v);\n    }\n    return this;\n  }\n\n  /**\n   *\n   * @param name Span Name\n   * @param [attributesOrStartTime] Span attributes or start time\n   *     if type is {@type TimeInput} and 3rd param is undefined\n   * @param [timeStamp] Specified time stamp for the event\n   */\n  addEvent(\n    name: string,\n    attributesOrStartTime?: Attributes | TimeInput,\n    timeStamp?: TimeInput\n  ): this {\n    if (this._isSpanEnded()) return this;\n\n    const { eventCountLimit } = this._spanLimits;\n\n    if (eventCountLimit === 0) {\n      diag.warn('No events allowed.');\n      this._droppedEventsCount++;\n      return this;\n    }\n\n    if (\n      eventCountLimit !== undefined &&\n      this.events.length >= eventCountLimit\n    ) {\n      if (this._droppedEventsCount === 0) {\n        diag.debug('Dropping extra events.');\n      }\n      this.events.shift();\n      this._droppedEventsCount++;\n    }\n\n    if (isTimeInput(attributesOrStartTime)) {\n      if (!isTimeInput(timeStamp)) {\n        timeStamp = attributesOrStartTime;\n      }\n      attributesOrStartTime = undefined;\n    }\n\n    const attributes = sanitizeAttributes(attributesOrStartTime);\n\n    this.events.push({\n      name,\n      attributes,\n      time: this._getTime(timeStamp),\n      droppedAttributesCount: 0,\n    });\n    return this;\n  }\n\n  addLink(link: Link): this {\n    this.links.push(link);\n    return this;\n  }\n\n  addLinks(links: Link[]): this {\n    this.links.push(...links);\n    return this;\n  }\n\n  setStatus(status: SpanStatus): this {\n    if (this._isSpanEnded()) return this;\n    this.status = { ...status };\n\n    // When using try-catch, the caught \"error\" is of type `any`. When then assigning `any` to `status.message`,\n    // TypeScript will not error. While this can happen during use of any API, it is more common on Span#setStatus()\n    // as it's likely used in a catch-block. Therefore, we validate if `status.message` is actually a string, null, or\n    // undefined to avoid an incorrect type causing issues downstream.\n    if (this.status.message != null && typeof status.message !== 'string') {\n      diag.warn(\n        `Dropping invalid status.message of type '${typeof status.message}', expected 'string'`\n      );\n      delete this.status.message;\n    }\n\n    return this;\n  }\n\n  updateName(name: string): this {\n    if (this._isSpanEnded()) return this;\n    this.name = name;\n    return this;\n  }\n\n  end(endTime?: TimeInput): void {\n    if (this._isSpanEnded()) {\n      diag.error(\n        `${this.name} ${this._spanContext.traceId}-${this._spanContext.spanId} - You can only call end() on a span once.`\n      );\n      return;\n    }\n    this._ended = true;\n\n    this.endTime = this._getTime(endTime);\n    this._duration = hrTimeDuration(this.startTime, this.endTime);\n\n    if (this._duration[0] < 0) {\n      diag.warn(\n        'Inconsistent start and end time, startTime > endTime. Setting span duration to 0ms.',\n        this.startTime,\n        this.endTime\n      );\n      this.endTime = this.startTime.slice() as HrTime;\n      this._duration = [0, 0];\n    }\n\n    if (this._droppedEventsCount > 0) {\n      diag.warn(\n        `Dropped ${this._droppedEventsCount} events because eventCountLimit reached`\n      );\n    }\n\n    this._spanProcessor.onEnd(this);\n  }\n\n  private _getTime(inp?: TimeInput): HrTime {\n    if (typeof inp === 'number' && inp <= otperformance.now()) {\n      // must be a performance timestamp\n      // apply correction and convert to hrtime\n      return hrTime(inp + this._performanceOffset);\n    }\n\n    if (typeof inp === 'number') {\n      return millisToHrTime(inp);\n    }\n\n    if (inp instanceof Date) {\n      return millisToHrTime(inp.getTime());\n    }\n\n    if (isTimeInputHrTime(inp)) {\n      return inp;\n    }\n\n    if (this._startTimeProvided) {\n      // if user provided a time for the start manually\n      // we can't use duration to calculate event/end times\n      return millisToHrTime(Date.now());\n    }\n\n    const msDuration = otperformance.now() - this._performanceStartTime;\n    return addHrTimes(this.startTime, millisToHrTime(msDuration));\n  }\n\n  isRecording(): boolean {\n    return this._ended === false;\n  }\n\n  recordException(exception: Exception, time?: TimeInput): void {\n    const attributes: Attributes = {};\n    if (typeof exception === 'string') {\n      attributes[ATTR_EXCEPTION_MESSAGE] = exception;\n    } else if (exception) {\n      if (exception.code) {\n        attributes[ATTR_EXCEPTION_TYPE] = exception.code.toString();\n      } else if (exception.name) {\n        attributes[ATTR_EXCEPTION_TYPE] = exception.name;\n      }\n      if (exception.message) {\n        attributes[ATTR_EXCEPTION_MESSAGE] = exception.message;\n      }\n      if (exception.stack) {\n        attributes[ATTR_EXCEPTION_STACKTRACE] = exception.stack;\n      }\n    }\n\n    // these are minimum requirements from spec\n    if (attributes[ATTR_EXCEPTION_TYPE] || attributes[ATTR_EXCEPTION_MESSAGE]) {\n      this.addEvent(ExceptionEventName, attributes, time);\n    } else {\n      diag.warn(`Failed to record an exception ${exception}`);\n    }\n  }\n\n  get duration(): HrTime {\n    return this._duration;\n  }\n\n  get ended(): boolean {\n    return this._ended;\n  }\n\n  get droppedAttributesCount(): number {\n    return this._droppedAttributesCount;\n  }\n\n  get droppedEventsCount(): number {\n    return this._droppedEventsCount;\n  }\n\n  get droppedLinksCount(): number {\n    return this._droppedLinksCount;\n  }\n\n  private _isSpanEnded(): boolean {\n    if (this._ended) {\n      const error = new Error(\n        `Operation attempted on ended Span {traceId: ${this._spanContext.traceId}, spanId: ${this._spanContext.spanId}}`\n      );\n\n      diag.warn(\n        `Cannot execute the operation on ended Span {traceId: ${this._spanContext.traceId}, spanId: ${this._spanContext.spanId}}`,\n        error\n      );\n    }\n    return this._ended;\n  }\n\n  // Utility function to truncate given value within size\n  // for value type of string, will truncate to given limit\n  // for type of non-string, will return same value\n  private _truncateToLimitUtil(value: string, limit: number): string {\n    if (value.length <= limit) {\n      return value;\n    }\n    return value.substring(0, limit);\n  }\n\n  /**\n   * If the given attribute value is of type string and has more characters than given {@code attributeValueLengthLimit} then\n   * return string with truncated to {@code attributeValueLengthLimit} characters\n   *\n   * If the given attribute value is array of strings then\n   * return new array of strings with each element truncated to {@code attributeValueLengthLimit} characters\n   *\n   * Otherwise return same Attribute {@code value}\n   *\n   * @param value Attribute value\n   * @returns truncated attribute value if required, otherwise same value\n   */\n  private _truncateToSize(value: AttributeValue): AttributeValue {\n    const limit = this._attributeValueLengthLimit;\n    // Check limit\n    if (limit <= 0) {\n      // Negative values are invalid, so do not truncate\n      diag.warn(`Attribute value limit must be positive, got ${limit}`);\n      return value;\n    }\n\n    // String\n    if (typeof value === 'string') {\n      return this._truncateToLimitUtil(value, limit);\n    }\n\n    // Array of strings\n    if (Array.isArray(value)) {\n      return (value as []).map(val =>\n        typeof val === 'string' ? this._truncateToLimitUtil(val, limit) : val\n      );\n    }\n\n    // Other types, no need to apply value length limit\n    return value;\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Context,\n  Link,\n  Attributes,\n  SpanKind,\n  TraceState,\n} from '@opentelemetry/api';\n\n/**\n * A sampling decision that determines how a {@link Span} will be recorded\n * and collected.\n */\nexport enum SamplingDecision {\n  /**\n   * `Span.isRecording() === false`, span will not be recorded and all events\n   * and attributes will be dropped.\n   */\n  NOT_RECORD,\n  /**\n   * `Span.isRecording() === true`, but `Sampled` flag in {@link TraceFlags}\n   * MUST NOT be set.\n   */\n  RECORD,\n  /**\n   * `Span.isRecording() === true` AND `Sampled` flag in {@link TraceFlags}\n   * MUST be set.\n   */\n  RECORD_AND_SAMPLED,\n}\n\n/**\n * A sampling result contains a decision for a {@link Span} and additional\n * attributes the sampler would like to added to the Span.\n */\nexport interface SamplingResult {\n  /**\n   * A sampling decision, refer to {@link SamplingDecision} for details.\n   */\n  decision: SamplingDecision;\n  /**\n   * The list of attributes returned by SamplingResult MUST be immutable.\n   * Caller may call {@link Sampler}.shouldSample any number of times and\n   * can safely cache the returned value.\n   */\n  attributes?: Readonly<Attributes>;\n  /**\n   * A {@link TraceState} that will be associated with the {@link Span} through\n   * the new {@link SpanContext}. Samplers SHOULD return the TraceState from\n   * the passed-in {@link Context} if they do not intend to change it. Leaving\n   * the value undefined will also leave the TraceState unchanged.\n   */\n  traceState?: TraceState;\n}\n\n/**\n * This interface represent a sampler. Sampling is a mechanism to control the\n * noise and overhead introduced by OpenTelemetry by reducing the number of\n * samples of traces collected and sent to the backend.\n */\nexport interface Sampler {\n  /**\n   * Checks whether span needs to be created and tracked.\n   *\n   * @param context Parent Context which may contain a span.\n   * @param traceId of the span to be created. It can be different from the\n   *     traceId in the {@link SpanContext}. Typically in situations when the\n   *     span to be created starts a new trace.\n   * @param spanName of the span to be created.\n   * @param spanKind of the span to be created.\n   * @param attributes Initial set of Attributes for the Span being constructed.\n   * @param links Collection of links that will be associated with the Span to\n   *     be created. Typically useful for batch operations.\n   * @returns a {@link SamplingResult}.\n   */\n  shouldSample(\n    context: Context,\n    traceId: string,\n    spanName: string,\n    spanKind: SpanKind,\n    attributes: Attributes,\n    links: Link[]\n  ): SamplingResult;\n\n  /** Returns the sampler name or short description with the configuration. */\n  toString(): string;\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Sampler, SamplingDecision, SamplingResult } from '../Sampler';\n\n/** Sampler that samples no traces. */\nexport class AlwaysOffSampler implements Sampler {\n  shouldSample(): SamplingResult {\n    return {\n      decision: SamplingDecision.NOT_RECORD,\n    };\n  }\n\n  toString(): string {\n    return 'AlwaysOffSampler';\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Sampler, SamplingDecision, SamplingResult } from '../Sampler';\n\n/** Sampler that samples all traces. */\nexport class AlwaysOnSampler implements Sampler {\n  shouldSample(): SamplingResult {\n    return {\n      decision: SamplingDecision.RECORD_AND_SAMPLED,\n    };\n  }\n\n  toString(): string {\n    return 'AlwaysOnSampler';\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Context,\n  isSpanContextValid,\n  Link,\n  Attributes,\n  SpanKind,\n  TraceFlags,\n  trace,\n} from '@opentelemetry/api';\nimport { globalErrorHandler } from '@opentelemetry/core';\nimport { AlwaysOffSampler } from './AlwaysOffSampler';\nimport { AlwaysOnSampler } from './AlwaysOnSampler';\nimport { Sampler, SamplingResult } from '../Sampler';\n\n/**\n * A composite sampler that either respects the parent span's sampling decision\n * or delegates to `delegateSampler` for root spans.\n */\nexport class ParentBasedSampler implements Sampler {\n  private _root: Sampler;\n  private _remoteParentSampled: Sampler;\n  private _remoteParentNotSampled: Sampler;\n  private _localParentSampled: Sampler;\n  private _localParentNotSampled: Sampler;\n\n  constructor(config: ParentBasedSamplerConfig) {\n    this._root = config.root;\n\n    if (!this._root) {\n      globalErrorHandler(\n        new Error('ParentBasedSampler must have a root sampler configured')\n      );\n      this._root = new AlwaysOnSampler();\n    }\n\n    this._remoteParentSampled =\n      config.remoteParentSampled ?? new AlwaysOnSampler();\n    this._remoteParentNotSampled =\n      config.remoteParentNotSampled ?? new AlwaysOffSampler();\n    this._localParentSampled =\n      config.localParentSampled ?? new AlwaysOnSampler();\n    this._localParentNotSampled =\n      config.localParentNotSampled ?? new AlwaysOffSampler();\n  }\n\n  shouldSample(\n    context: Context,\n    traceId: string,\n    spanName: string,\n    spanKind: SpanKind,\n    attributes: Attributes,\n    links: Link[]\n  ): SamplingResult {\n    const parentContext = trace.getSpanContext(context);\n\n    if (!parentContext || !isSpanContextValid(parentContext)) {\n      return this._root.shouldSample(\n        context,\n        traceId,\n        spanName,\n        spanKind,\n        attributes,\n        links\n      );\n    }\n\n    if (parentContext.isRemote) {\n      if (parentContext.traceFlags & TraceFlags.SAMPLED) {\n        return this._remoteParentSampled.shouldSample(\n          context,\n          traceId,\n          spanName,\n          spanKind,\n          attributes,\n          links\n        );\n      }\n      return this._remoteParentNotSampled.shouldSample(\n        context,\n        traceId,\n        spanName,\n        spanKind,\n        attributes,\n        links\n      );\n    }\n\n    if (parentContext.traceFlags & TraceFlags.SAMPLED) {\n      return this._localParentSampled.shouldSample(\n        context,\n        traceId,\n        spanName,\n        spanKind,\n        attributes,\n        links\n      );\n    }\n\n    return this._localParentNotSampled.shouldSample(\n      context,\n      traceId,\n      spanName,\n      spanKind,\n      attributes,\n      links\n    );\n  }\n\n  toString(): string {\n    return `ParentBased{root=${this._root.toString()}, remoteParentSampled=${this._remoteParentSampled.toString()}, remoteParentNotSampled=${this._remoteParentNotSampled.toString()}, localParentSampled=${this._localParentSampled.toString()}, localParentNotSampled=${this._localParentNotSampled.toString()}}`;\n  }\n}\n\ninterface ParentBasedSamplerConfig {\n  /** Sampler called for spans with no parent */\n  root: Sampler;\n  /** Sampler called for spans with a remote parent which was sampled. Default AlwaysOn */\n  remoteParentSampled?: Sampler;\n  /** Sampler called for spans with a remote parent which was not sampled. Default AlwaysOff */\n  remoteParentNotSampled?: Sampler;\n  /** Sampler called for spans with a local parent which was sampled. Default AlwaysOn */\n  localParentSampled?: Sampler;\n  /** Sampler called for spans with a local parent which was not sampled. Default AlwaysOff */\n  localParentNotSampled?: Sampler;\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { isValidTraceId } from '@opentelemetry/api';\nimport { Sampler, SamplingDecision, SamplingResult } from '../Sampler';\n\n/** Sampler that samples a given fraction of traces based of trace id deterministically. */\nexport class TraceIdRatioBasedSampler implements Sampler {\n  private _upperBound: number;\n\n  constructor(private readonly _ratio = 0) {\n    this._ratio = this._normalize(_ratio);\n    this._upperBound = Math.floor(this._ratio * 0xffffffff);\n  }\n\n  shouldSample(context: unknown, traceId: string): SamplingResult {\n    return {\n      decision:\n        isValidTraceId(traceId) && this._accumulate(traceId) < this._upperBound\n          ? SamplingDecision.RECORD_AND_SAMPLED\n          : SamplingDecision.NOT_RECORD,\n    };\n  }\n\n  toString(): string {\n    return `TraceIdRatioBased{${this._ratio}}`;\n  }\n\n  private _normalize(ratio: number): number {\n    if (typeof ratio !== 'number' || isNaN(ratio)) return 0;\n    return ratio >= 1 ? 1 : ratio <= 0 ? 0 : ratio;\n  }\n\n  private _accumulate(traceId: string): number {\n    let accumulation = 0;\n    for (let i = 0; i < traceId.length / 8; i++) {\n      const pos = i * 8;\n      const part = parseInt(traceId.slice(pos, pos + 8), 16);\n      accumulation = (accumulation ^ part) >>> 0;\n    }\n    return accumulation;\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { diag } from '@opentelemetry/api';\nimport { getNumberFromEnv, getStringFromEnv } from '@opentelemetry/core';\nimport { Sampler } from './Sampler';\nimport { AlwaysOffSampler } from './sampler/AlwaysOffSampler';\nimport { AlwaysOnSampler } from './sampler/AlwaysOnSampler';\nimport { ParentBasedSampler } from './sampler/ParentBasedSampler';\nimport { TraceIdRatioBasedSampler } from './sampler/TraceIdRatioBasedSampler';\n\nconst enum TracesSamplerValues {\n  AlwaysOff = 'always_off',\n  AlwaysOn = 'always_on',\n  ParentBasedAlwaysOff = 'parentbased_always_off',\n  ParentBasedAlwaysOn = 'parentbased_always_on',\n  ParentBasedTraceIdRatio = 'parentbased_traceidratio',\n  TraceIdRatio = 'traceidratio',\n}\n\nconst DEFAULT_RATIO = 1;\n\n/**\n * Load default configuration. For fields with primitive values, any user-provided\n * value will override the corresponding default value. For fields with\n * non-primitive values (like `spanLimits`), the user-provided value will be\n * used to extend the default value.\n */\n\n// object needs to be wrapped in this function and called when needed otherwise\n// envs are parsed before tests are ran - causes tests using these envs to fail\nexport function loadDefaultConfig() {\n  return {\n    sampler: buildSamplerFromEnv(),\n    forceFlushTimeoutMillis: 30000,\n    generalLimits: {\n      attributeValueLengthLimit:\n        getNumberFromEnv('OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT') ?? Infinity,\n      attributeCountLimit:\n        getNumberFromEnv('OTEL_ATTRIBUTE_COUNT_LIMIT') ?? 128,\n    },\n    spanLimits: {\n      attributeValueLengthLimit:\n        getNumberFromEnv('OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT') ?? Infinity,\n      attributeCountLimit:\n        getNumberFromEnv('OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT') ?? 128,\n      linkCountLimit: getNumberFromEnv('OTEL_SPAN_LINK_COUNT_LIMIT') ?? 128,\n      eventCountLimit: getNumberFromEnv('OTEL_SPAN_EVENT_COUNT_LIMIT') ?? 128,\n      attributePerEventCountLimit:\n        getNumberFromEnv('OTEL_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT') ?? 128,\n      attributePerLinkCountLimit:\n        getNumberFromEnv('OTEL_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT') ?? 128,\n    },\n  };\n}\n\n/**\n * Based on environment, builds a sampler, complies with specification.\n */\nexport function buildSamplerFromEnv(): Sampler {\n  const sampler =\n    getStringFromEnv('OTEL_TRACES_SAMPLER') ??\n    TracesSamplerValues.ParentBasedAlwaysOn;\n  switch (sampler) {\n    case TracesSamplerValues.AlwaysOn:\n      return new AlwaysOnSampler();\n    case TracesSamplerValues.AlwaysOff:\n      return new AlwaysOffSampler();\n    case TracesSamplerValues.ParentBasedAlwaysOn:\n      return new ParentBasedSampler({\n        root: new AlwaysOnSampler(),\n      });\n    case TracesSamplerValues.ParentBasedAlwaysOff:\n      return new ParentBasedSampler({\n        root: new AlwaysOffSampler(),\n      });\n    case TracesSamplerValues.TraceIdRatio:\n      return new TraceIdRatioBasedSampler(getSamplerProbabilityFromEnv());\n    case TracesSamplerValues.ParentBasedTraceIdRatio:\n      return new ParentBasedSampler({\n        root: new TraceIdRatioBasedSampler(getSamplerProbabilityFromEnv()),\n      });\n    default:\n      diag.error(\n        `OTEL_TRACES_SAMPLER value \"${sampler}\" invalid, defaulting to \"${TracesSamplerValues.ParentBasedAlwaysOn}\".`\n      );\n      return new ParentBasedSampler({\n        root: new AlwaysOnSampler(),\n      });\n  }\n}\n\nfunction getSamplerProbabilityFromEnv(): number | undefined {\n  const probability = getNumberFromEnv('OTEL_TRACES_SAMPLER_ARG');\n  if (probability == null) {\n    diag.error(\n      `OTEL_TRACES_SAMPLER_ARG is blank, defaulting to ${DEFAULT_RATIO}.`\n    );\n    return DEFAULT_RATIO;\n  }\n\n  if (probability < 0 || probability > 1) {\n    diag.error(\n      `OTEL_TRACES_SAMPLER_ARG=${probability} was given, but it is out of range ([0..1]), defaulting to ${DEFAULT_RATIO}.`\n    );\n    return DEFAULT_RATIO;\n  }\n\n  return probability;\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { buildSamplerFromEnv, loadDefaultConfig } from './config';\nimport { Sampler } from './Sampler';\nimport { SpanLimits, TracerConfig, GeneralLimits } from './types';\nimport { getNumberFromEnv } from '@opentelemetry/core';\n\nexport const DEFAULT_ATTRIBUTE_COUNT_LIMIT = 128;\nexport const DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT = Infinity;\n\n/**\n * Function to merge Default configuration (as specified in './config') with\n * user provided configurations.\n */\nexport function mergeConfig(userConfig: TracerConfig): TracerConfig & {\n  sampler: Sampler;\n  spanLimits: SpanLimits;\n  generalLimits: GeneralLimits;\n} {\n  const perInstanceDefaults: Partial<TracerConfig> = {\n    sampler: buildSamplerFromEnv(),\n  };\n\n  const DEFAULT_CONFIG = loadDefaultConfig();\n\n  const target = Object.assign(\n    {},\n    DEFAULT_CONFIG,\n    perInstanceDefaults,\n    userConfig\n  );\n\n  target.generalLimits = Object.assign(\n    {},\n    DEFAULT_CONFIG.generalLimits,\n    userConfig.generalLimits || {}\n  );\n\n  target.spanLimits = Object.assign(\n    {},\n    DEFAULT_CONFIG.spanLimits,\n    userConfig.spanLimits || {}\n  );\n\n  return target;\n}\n\n/**\n * When general limits are provided and model specific limits are not,\n * configures the model specific limits by using the values from the general ones.\n * @param userConfig User provided tracer configuration\n */\nexport function reconfigureLimits(userConfig: TracerConfig): TracerConfig {\n  const spanLimits = Object.assign({}, userConfig.spanLimits);\n\n  /**\n   * Reassign span attribute count limit to use first non null value defined by user or use default value\n   */\n  spanLimits.attributeCountLimit =\n    userConfig.spanLimits?.attributeCountLimit ??\n    userConfig.generalLimits?.attributeCountLimit ??\n    getNumberFromEnv('OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT') ??\n    getNumberFromEnv('OTEL_ATTRIBUTE_COUNT_LIMIT') ??\n    DEFAULT_ATTRIBUTE_COUNT_LIMIT;\n\n  /**\n   * Reassign span attribute value length limit to use first non null value defined by user or use default value\n   */\n  spanLimits.attributeValueLengthLimit =\n    userConfig.spanLimits?.attributeValueLengthLimit ??\n    userConfig.generalLimits?.attributeValueLengthLimit ??\n    getNumberFromEnv('OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT') ??\n    getNumberFromEnv('OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT') ??\n    DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT;\n\n  return Object.assign({}, userConfig, { spanLimits });\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { context, Context, diag, TraceFlags } from '@opentelemetry/api';\nimport {\n  BindOnceFuture,\n  ExportResultCode,\n  getNumberFromEnv,\n  globalErrorHandler,\n  suppressTracing,\n} from '@opentelemetry/core';\nimport { Span } from '../Span';\nimport { SpanProcessor } from '../SpanProcessor';\nimport { BufferConfig } from '../types';\nimport { ReadableSpan } from './ReadableSpan';\nimport { SpanExporter } from './SpanExporter';\n\n/**\n * Implementation of the {@link SpanProcessor} that batches spans exported by\n * the SDK then pushes them to the exporter pipeline.\n */\nexport abstract class BatchSpanProcessorBase<T extends BufferConfig>\n  implements SpanProcessor\n{\n  private readonly _maxExportBatchSize: number;\n  private readonly _maxQueueSize: number;\n  private readonly _scheduledDelayMillis: number;\n  private readonly _exportTimeoutMillis: number;\n\n  private _isExporting = false;\n  private _finishedSpans: ReadableSpan[] = [];\n  private _timer: NodeJS.Timeout | number | undefined;\n  private _shutdownOnce: BindOnceFuture<void>;\n  private _droppedSpansCount: number = 0;\n\n  constructor(\n    private readonly _exporter: SpanExporter,\n    config?: T\n  ) {\n    this._maxExportBatchSize =\n      typeof config?.maxExportBatchSize === 'number'\n        ? config.maxExportBatchSize\n        : (getNumberFromEnv('OTEL_BSP_MAX_EXPORT_BATCH_SIZE') ?? 512);\n    this._maxQueueSize =\n      typeof config?.maxQueueSize === 'number'\n        ? config.maxQueueSize\n        : (getNumberFromEnv('OTEL_BSP_MAX_QUEUE_SIZE') ?? 2048);\n    this._scheduledDelayMillis =\n      typeof config?.scheduledDelayMillis === 'number'\n        ? config.scheduledDelayMillis\n        : (getNumberFromEnv('OTEL_BSP_SCHEDULE_DELAY') ?? 5000);\n    this._exportTimeoutMillis =\n      typeof config?.exportTimeoutMillis === 'number'\n        ? config.exportTimeoutMillis\n        : (getNumberFromEnv('OTEL_BSP_EXPORT_TIMEOUT') ?? 30000);\n\n    this._shutdownOnce = new BindOnceFuture(this._shutdown, this);\n\n    if (this._maxExportBatchSize > this._maxQueueSize) {\n      diag.warn(\n        'BatchSpanProcessor: maxExportBatchSize must be smaller or equal to maxQueueSize, setting maxExportBatchSize to match maxQueueSize'\n      );\n      this._maxExportBatchSize = this._maxQueueSize;\n    }\n  }\n\n  forceFlush(): Promise<void> {\n    if (this._shutdownOnce.isCalled) {\n      return this._shutdownOnce.promise;\n    }\n    return this._flushAll();\n  }\n\n  // does nothing.\n  onStart(_span: Span, _parentContext: Context): void {}\n\n  onEnd(span: ReadableSpan): void {\n    if (this._shutdownOnce.isCalled) {\n      return;\n    }\n\n    if ((span.spanContext().traceFlags & TraceFlags.SAMPLED) === 0) {\n      return;\n    }\n\n    this._addToBuffer(span);\n  }\n\n  shutdown(): Promise<void> {\n    return this._shutdownOnce.call();\n  }\n\n  private _shutdown() {\n    return Promise.resolve()\n      .then(() => {\n        return this.onShutdown();\n      })\n      .then(() => {\n        return this._flushAll();\n      })\n      .then(() => {\n        return this._exporter.shutdown();\n      });\n  }\n\n  /** Add a span in the buffer. */\n  private _addToBuffer(span: ReadableSpan) {\n    if (this._finishedSpans.length >= this._maxQueueSize) {\n      // limit reached, drop span\n\n      if (this._droppedSpansCount === 0) {\n        diag.debug('maxQueueSize reached, dropping spans');\n      }\n      this._droppedSpansCount++;\n\n      return;\n    }\n\n    if (this._droppedSpansCount > 0) {\n      // some spans were dropped, log once with count of spans dropped\n      diag.warn(\n        `Dropped ${this._droppedSpansCount} spans because maxQueueSize reached`\n      );\n      this._droppedSpansCount = 0;\n    }\n\n    this._finishedSpans.push(span);\n    this._maybeStartTimer();\n  }\n\n  /**\n   * Send all spans to the exporter respecting the batch size limit\n   * This function is used only on forceFlush or shutdown,\n   * for all other cases _flush should be used\n   * */\n  private _flushAll(): Promise<void> {\n    return new Promise((resolve, reject) => {\n      const promises = [];\n      // calculate number of batches\n      const count = Math.ceil(\n        this._finishedSpans.length / this._maxExportBatchSize\n      );\n      for (let i = 0, j = count; i < j; i++) {\n        promises.push(this._flushOneBatch());\n      }\n      Promise.all(promises)\n        .then(() => {\n          resolve();\n        })\n        .catch(reject);\n    });\n  }\n\n  private _flushOneBatch(): Promise<void> {\n    this._clearTimer();\n    if (this._finishedSpans.length === 0) {\n      return Promise.resolve();\n    }\n    return new Promise((resolve, reject) => {\n      const timer = setTimeout(() => {\n        // don't wait anymore for export, this way the next batch can start\n        reject(new Error('Timeout'));\n      }, this._exportTimeoutMillis);\n      // prevent downstream exporter calls from generating spans\n      context.with(suppressTracing(context.active()), () => {\n        // Reset the finished spans buffer here because the next invocations of the _flush method\n        // could pass the same finished spans to the exporter if the buffer is cleared\n        // outside the execution of this callback.\n        let spans: ReadableSpan[];\n        if (this._finishedSpans.length <= this._maxExportBatchSize) {\n          spans = this._finishedSpans;\n          this._finishedSpans = [];\n        } else {\n          spans = this._finishedSpans.splice(0, this._maxExportBatchSize);\n        }\n\n        const doExport = () =>\n          this._exporter.export(spans, result => {\n            clearTimeout(timer);\n            if (result.code === ExportResultCode.SUCCESS) {\n              resolve();\n            } else {\n              reject(\n                result.error ??\n                  new Error('BatchSpanProcessor: span export failed')\n              );\n            }\n          });\n\n        let pendingResources: Array<Promise<void>> | null = null;\n        for (let i = 0, len = spans.length; i < len; i++) {\n          const span = spans[i];\n          if (\n            span.resource.asyncAttributesPending &&\n            span.resource.waitForAsyncAttributes\n          ) {\n            pendingResources ??= [];\n            pendingResources.push(span.resource.waitForAsyncAttributes());\n          }\n        }\n\n        // Avoid scheduling a promise to make the behavior more predictable and easier to test\n        if (pendingResources === null) {\n          doExport();\n        } else {\n          Promise.all(pendingResources).then(doExport, err => {\n            globalErrorHandler(err);\n            reject(err);\n          });\n        }\n      });\n    });\n  }\n\n  private _maybeStartTimer() {\n    if (this._isExporting) return;\n    const flush = () => {\n      this._isExporting = true;\n      this._flushOneBatch()\n        .finally(() => {\n          this._isExporting = false;\n          if (this._finishedSpans.length > 0) {\n            this._clearTimer();\n            this._maybeStartTimer();\n          }\n        })\n        .catch(e => {\n          this._isExporting = false;\n          globalErrorHandler(e);\n        });\n    };\n    // we only wait if the queue doesn't have enough elements yet\n    if (this._finishedSpans.length >= this._maxExportBatchSize) {\n      return flush();\n    }\n    if (this._timer !== undefined) return;\n    this._timer = setTimeout(() => flush(), this._scheduledDelayMillis);\n\n    // depending on runtime, this may be a 'number' or NodeJS.Timeout\n    if (typeof this._timer !== 'number') {\n      this._timer.unref();\n    }\n  }\n\n  private _clearTimer() {\n    if (this._timer !== undefined) {\n      clearTimeout(this._timer);\n      this._timer = undefined;\n    }\n  }\n\n  protected abstract onShutdown(): void;\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { BatchSpanProcessorBase } from '../../../export/BatchSpanProcessorBase';\nimport { SpanExporter } from '../../../export/SpanExporter';\nimport { BatchSpanProcessorBrowserConfig } from '../../../types';\nimport { globalErrorHandler } from '@opentelemetry/core';\n\nexport class BatchSpanProcessor extends BatchSpanProcessorBase<BatchSpanProcessorBrowserConfig> {\n  private _visibilityChangeListener?: () => void;\n  private _pageHideListener?: () => void;\n\n  constructor(\n    _exporter: SpanExporter,\n    config?: BatchSpanProcessorBrowserConfig\n  ) {\n    super(_exporter, config);\n    this.onInit(config);\n  }\n\n  private onInit(config?: BatchSpanProcessorBrowserConfig): void {\n    if (\n      config?.disableAutoFlushOnDocumentHide !== true &&\n      typeof document !== 'undefined'\n    ) {\n      this._visibilityChangeListener = () => {\n        if (document.visibilityState === 'hidden') {\n          this.forceFlush().catch(error => {\n            globalErrorHandler(error);\n          });\n        }\n      };\n      this._pageHideListener = () => {\n        this.forceFlush().catch(error => {\n          globalErrorHandler(error);\n        });\n      };\n      document.addEventListener(\n        'visibilitychange',\n        this._visibilityChangeListener\n      );\n\n      // use 'pagehide' event as a fallback for Safari; see https://bugs.webkit.org/show_bug.cgi?id=116769\n      document.addEventListener('pagehide', this._pageHideListener);\n    }\n  }\n\n  protected onShutdown(): void {\n    if (typeof document !== 'undefined') {\n      if (this._visibilityChangeListener) {\n        document.removeEventListener(\n          'visibilitychange',\n          this._visibilityChangeListener\n        );\n      }\n      if (this._pageHideListener) {\n        document.removeEventListener('pagehide', this._pageHideListener);\n      }\n    }\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { IdGenerator } from '../../IdGenerator';\n\nconst SPAN_ID_BYTES = 8;\nconst TRACE_ID_BYTES = 16;\n\nexport class RandomIdGenerator implements IdGenerator {\n  /**\n   * Returns a random 16-byte trace ID formatted/encoded as a 32 lowercase hex\n   * characters corresponding to 128 bits.\n   */\n  generateTraceId = getIdGenerator(TRACE_ID_BYTES);\n\n  /**\n   * Returns a random 8-byte span ID formatted/encoded as a 16 lowercase hex\n   * characters corresponding to 64 bits.\n   */\n  generateSpanId = getIdGenerator(SPAN_ID_BYTES);\n}\n\nconst SHARED_CHAR_CODES_ARRAY = Array(32);\nfunction getIdGenerator(bytes: number): () => string {\n  return function generateId() {\n    for (let i = 0; i < bytes * 2; i++) {\n      SHARED_CHAR_CODES_ARRAY[i] = Math.floor(Math.random() * 16) + 48;\n      // valid hex characters in the range 48-57 and 97-102\n      if (SHARED_CHAR_CODES_ARRAY[i] >= 58) {\n        SHARED_CHAR_CODES_ARRAY[i] += 39;\n      }\n    }\n    return String.fromCharCode.apply(\n      null,\n      SHARED_CHAR_CODES_ARRAY.slice(0, bytes * 2)\n    );\n  };\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as api from '@opentelemetry/api';\nimport {\n  InstrumentationScope,\n  sanitizeAttributes,\n  isTracingSuppressed,\n} from '@opentelemetry/core';\nimport { SpanImpl } from './Span';\nimport { GeneralLimits, SpanLimits, TracerConfig } from './types';\nimport { mergeConfig } from './utility';\nimport { SpanProcessor } from './SpanProcessor';\nimport { Sampler } from './Sampler';\nimport { IdGenerator } from './IdGenerator';\nimport { RandomIdGenerator } from './platform';\nimport { Resource } from '@opentelemetry/resources';\n\n/**\n * This class represents a basic tracer.\n */\nexport class Tracer implements api.Tracer {\n  private readonly _sampler: Sampler;\n  private readonly _generalLimits: GeneralLimits;\n  private readonly _spanLimits: SpanLimits;\n  private readonly _idGenerator: IdGenerator;\n  readonly instrumentationScope: InstrumentationScope;\n\n  private readonly _resource: Resource;\n  private readonly _spanProcessor: SpanProcessor;\n\n  /**\n   * Constructs a new Tracer instance.\n   */\n  constructor(\n    instrumentationScope: InstrumentationScope,\n    config: TracerConfig,\n    resource: Resource,\n    spanProcessor: SpanProcessor\n  ) {\n    const localConfig = mergeConfig(config);\n    this._sampler = localConfig.sampler;\n    this._generalLimits = localConfig.generalLimits;\n    this._spanLimits = localConfig.spanLimits;\n    this._idGenerator = config.idGenerator || new RandomIdGenerator();\n    this._resource = resource;\n    this._spanProcessor = spanProcessor;\n    this.instrumentationScope = instrumentationScope;\n  }\n\n  /**\n   * Starts a new Span or returns the default NoopSpan based on the sampling\n   * decision.\n   */\n  startSpan(\n    name: string,\n    options: api.SpanOptions = {},\n    context = api.context.active()\n  ): api.Span {\n    // remove span from context in case a root span is requested via options\n    if (options.root) {\n      context = api.trace.deleteSpan(context);\n    }\n    const parentSpan = api.trace.getSpan(context);\n\n    if (isTracingSuppressed(context)) {\n      api.diag.debug('Instrumentation suppressed, returning Noop Span');\n      const nonRecordingSpan = api.trace.wrapSpanContext(\n        api.INVALID_SPAN_CONTEXT\n      );\n      return nonRecordingSpan;\n    }\n\n    const parentSpanContext = parentSpan?.spanContext();\n    const spanId = this._idGenerator.generateSpanId();\n    let validParentSpanContext;\n    let traceId;\n    let traceState;\n    if (\n      !parentSpanContext ||\n      !api.trace.isSpanContextValid(parentSpanContext)\n    ) {\n      // New root span.\n      traceId = this._idGenerator.generateTraceId();\n    } else {\n      // New child span.\n      traceId = parentSpanContext.traceId;\n      traceState = parentSpanContext.traceState;\n      validParentSpanContext = parentSpanContext;\n    }\n\n    const spanKind = options.kind ?? api.SpanKind.INTERNAL;\n    const links = (options.links ?? []).map(link => {\n      return {\n        context: link.context,\n        attributes: sanitizeAttributes(link.attributes),\n      };\n    });\n    const attributes = sanitizeAttributes(options.attributes);\n    // make sampling decision\n    const samplingResult = this._sampler.shouldSample(\n      context,\n      traceId,\n      name,\n      spanKind,\n      attributes,\n      links\n    );\n\n    traceState = samplingResult.traceState ?? traceState;\n\n    const traceFlags =\n      samplingResult.decision === api.SamplingDecision.RECORD_AND_SAMPLED\n        ? api.TraceFlags.SAMPLED\n        : api.TraceFlags.NONE;\n    const spanContext = { traceId, spanId, traceFlags, traceState };\n    if (samplingResult.decision === api.SamplingDecision.NOT_RECORD) {\n      api.diag.debug(\n        'Recording is off, propagating context in a non-recording span'\n      );\n      const nonRecordingSpan = api.trace.wrapSpanContext(spanContext);\n      return nonRecordingSpan;\n    }\n\n    // Set initial span attributes. The attributes object may have been mutated\n    // by the sampler, so we sanitize the merged attributes before setting them.\n    const initAttributes = sanitizeAttributes(\n      Object.assign(attributes, samplingResult.attributes)\n    );\n\n    const span = new SpanImpl({\n      resource: this._resource,\n      scope: this.instrumentationScope,\n      context,\n      spanContext,\n      name,\n      kind: spanKind,\n      links,\n      parentSpanContext: validParentSpanContext,\n      attributes: initAttributes,\n      startTime: options.startTime,\n      spanProcessor: this._spanProcessor,\n      spanLimits: this._spanLimits,\n    });\n    return span;\n  }\n\n  /**\n   * Starts a new {@link Span} and calls the given function passing it the\n   * created span as first argument.\n   * Additionally the new span gets set in context and this context is activated\n   * for the duration of the function call.\n   *\n   * @param name The name of the span\n   * @param [options] SpanOptions used for span creation\n   * @param [context] Context to use to extract parent\n   * @param fn function called in the context of the span and receives the newly created span as an argument\n   * @returns return value of fn\n   * @example\n   *   const something = tracer.startActiveSpan('op', span => {\n   *     try {\n   *       do some work\n   *       span.setStatus({code: SpanStatusCode.OK});\n   *       return something;\n   *     } catch (err) {\n   *       span.setStatus({\n   *         code: SpanStatusCode.ERROR,\n   *         message: err.message,\n   *       });\n   *       throw err;\n   *     } finally {\n   *       span.end();\n   *     }\n   *   });\n   * @example\n   *   const span = tracer.startActiveSpan('op', span => {\n   *     try {\n   *       do some work\n   *       return span;\n   *     } catch (err) {\n   *       span.setStatus({\n   *         code: SpanStatusCode.ERROR,\n   *         message: err.message,\n   *       });\n   *       throw err;\n   *     }\n   *   });\n   *   do some more work\n   *   span.end();\n   */\n  startActiveSpan<F extends (span: api.Span) => ReturnType<F>>(\n    name: string,\n    fn: F\n  ): ReturnType<F>;\n  startActiveSpan<F extends (span: api.Span) => ReturnType<F>>(\n    name: string,\n    opts: api.SpanOptions,\n    fn: F\n  ): ReturnType<F>;\n  startActiveSpan<F extends (span: api.Span) => ReturnType<F>>(\n    name: string,\n    opts: api.SpanOptions,\n    ctx: api.Context,\n    fn: F\n  ): ReturnType<F>;\n  startActiveSpan<F extends (span: api.Span) => ReturnType<F>>(\n    name: string,\n    arg2?: F | api.SpanOptions,\n    arg3?: F | api.Context,\n    arg4?: F\n  ): ReturnType<F> | undefined {\n    let opts: api.SpanOptions | undefined;\n    let ctx: api.Context | undefined;\n    let fn: F;\n\n    if (arguments.length < 2) {\n      return;\n    } else if (arguments.length === 2) {\n      fn = arg2 as F;\n    } else if (arguments.length === 3) {\n      opts = arg2 as api.SpanOptions | undefined;\n      fn = arg3 as F;\n    } else {\n      opts = arg2 as api.SpanOptions | undefined;\n      ctx = arg3 as api.Context | undefined;\n      fn = arg4 as F;\n    }\n\n    const parentContext = ctx ?? api.context.active();\n    const span = this.startSpan(name, opts, parentContext);\n    const contextWithSpanSet = api.trace.setSpan(parentContext, span);\n\n    return api.context.with(contextWithSpanSet, fn, undefined, span);\n  }\n\n  /** Returns the active {@link GeneralLimits}. */\n  getGeneralLimits(): GeneralLimits {\n    return this._generalLimits;\n  }\n\n  /** Returns the active {@link SpanLimits}. */\n  getSpanLimits(): SpanLimits {\n    return this._spanLimits;\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Context } from '@opentelemetry/api';\nimport { globalErrorHandler } from '@opentelemetry/core';\nimport { ReadableSpan } from './export/ReadableSpan';\nimport { Span } from './Span';\nimport { SpanProcessor } from './SpanProcessor';\n\n/**\n * Implementation of the {@link SpanProcessor} that simply forwards all\n * received events to a list of {@link SpanProcessor}s.\n */\nexport class MultiSpanProcessor implements SpanProcessor {\n  constructor(private readonly _spanProcessors: SpanProcessor[]) {}\n\n  forceFlush(): Promise<void> {\n    const promises: Promise<void>[] = [];\n\n    for (const spanProcessor of this._spanProcessors) {\n      promises.push(spanProcessor.forceFlush());\n    }\n    return new Promise(resolve => {\n      Promise.all(promises)\n        .then(() => {\n          resolve();\n        })\n        .catch(error => {\n          globalErrorHandler(\n            error || new Error('MultiSpanProcessor: forceFlush failed')\n          );\n          resolve();\n        });\n    });\n  }\n\n  onStart(span: Span, context: Context): void {\n    for (const spanProcessor of this._spanProcessors) {\n      spanProcessor.onStart(span, context);\n    }\n  }\n\n  onEnd(span: ReadableSpan): void {\n    for (const spanProcessor of this._spanProcessors) {\n      spanProcessor.onEnd(span);\n    }\n  }\n\n  shutdown(): Promise<void> {\n    const promises: Promise<void>[] = [];\n\n    for (const spanProcessor of this._spanProcessors) {\n      promises.push(spanProcessor.shutdown());\n    }\n    return new Promise((resolve, reject) => {\n      Promise.all(promises).then(() => {\n        resolve();\n      }, reject);\n    });\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { TracerProvider, Tracer as ApiTracer } from '@opentelemetry/api';\nimport { merge } from '@opentelemetry/core';\nimport { defaultResource, Resource } from '@opentelemetry/resources';\nimport { SpanProcessor } from './SpanProcessor';\nimport { Tracer } from './Tracer';\nimport { loadDefaultConfig } from './config';\nimport { MultiSpanProcessor } from './MultiSpanProcessor';\nimport { TracerConfig } from './types';\nimport { reconfigureLimits } from './utility';\n\nexport enum ForceFlushState {\n  'resolved',\n  'timeout',\n  'error',\n  'unresolved',\n}\n\n/**\n * This class represents a basic tracer provider which platform libraries can extend\n */\nexport class BasicTracerProvider implements TracerProvider {\n  private readonly _config: TracerConfig;\n  private readonly _tracers: Map<string, Tracer> = new Map();\n  private readonly _resource: Resource;\n  private readonly _activeSpanProcessor: MultiSpanProcessor;\n\n  constructor(config: TracerConfig = {}) {\n    const mergedConfig = merge(\n      {},\n      loadDefaultConfig(),\n      reconfigureLimits(config)\n    );\n    this._resource = mergedConfig.resource ?? defaultResource();\n\n    this._config = Object.assign({}, mergedConfig, {\n      resource: this._resource,\n    });\n\n    const spanProcessors: SpanProcessor[] = [];\n\n    if (config.spanProcessors?.length) {\n      spanProcessors.push(...config.spanProcessors);\n    }\n\n    this._activeSpanProcessor = new MultiSpanProcessor(spanProcessors);\n  }\n\n  getTracer(\n    name: string,\n    version?: string,\n    options?: { schemaUrl?: string }\n  ): ApiTracer {\n    const key = `${name}@${version || ''}:${options?.schemaUrl || ''}`;\n    if (!this._tracers.has(key)) {\n      this._tracers.set(\n        key,\n        new Tracer(\n          { name, version, schemaUrl: options?.schemaUrl },\n          this._config,\n          this._resource,\n          this._activeSpanProcessor\n        )\n      );\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return this._tracers.get(key)!;\n  }\n\n  forceFlush(): Promise<void> {\n    const timeout = this._config.forceFlushTimeoutMillis;\n    const promises = this._activeSpanProcessor['_spanProcessors'].map(\n      (spanProcessor: SpanProcessor) => {\n        return new Promise(resolve => {\n          let state: ForceFlushState;\n          const timeoutInterval = setTimeout(() => {\n            resolve(\n              new Error(\n                `Span processor did not completed within timeout period of ${timeout} ms`\n              )\n            );\n            state = ForceFlushState.timeout;\n          }, timeout);\n\n          spanProcessor\n            .forceFlush()\n            .then(() => {\n              clearTimeout(timeoutInterval);\n              if (state !== ForceFlushState.timeout) {\n                state = ForceFlushState.resolved;\n                resolve(state);\n              }\n            })\n            .catch(error => {\n              clearTimeout(timeoutInterval);\n              state = ForceFlushState.error;\n              resolve(error);\n            });\n        });\n      }\n    );\n\n    return new Promise<void>((resolve, reject) => {\n      Promise.all(promises)\n        .then(results => {\n          const errors = results.filter(\n            result => result !== ForceFlushState.resolved\n          );\n          if (errors.length > 0) {\n            reject(errors);\n          } else {\n            resolve();\n          }\n        })\n        .catch(error => reject([error]));\n    });\n  }\n\n  shutdown(): Promise<void> {\n    return this._activeSpanProcessor.shutdown();\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { SpanExporter } from './SpanExporter';\nimport { ReadableSpan } from './ReadableSpan';\nimport {\n  ExportResult,\n  ExportResultCode,\n  hrTimeToMicroseconds,\n} from '@opentelemetry/core';\n\n/**\n * This is implementation of {@link SpanExporter} that prints spans to the\n * console. This class can be used for diagnostic purposes.\n *\n * NOTE: This {@link SpanExporter} is intended for diagnostics use only, output rendered to the console may change at any time.\n */\n\n/* eslint-disable no-console */\nexport class ConsoleSpanExporter implements SpanExporter {\n  /**\n   * Export spans.\n   * @param spans\n   * @param resultCallback\n   */\n  export(\n    spans: ReadableSpan[],\n    resultCallback: (result: ExportResult) => void\n  ): void {\n    return this._sendSpans(spans, resultCallback);\n  }\n\n  /**\n   * Shutdown the exporter.\n   */\n  shutdown(): Promise<void> {\n    this._sendSpans([]);\n    return this.forceFlush();\n  }\n\n  /**\n   * Exports any pending spans in exporter\n   */\n  forceFlush(): Promise<void> {\n    return Promise.resolve();\n  }\n\n  /**\n   * converts span info into more readable format\n   * @param span\n   */\n  private _exportInfo(span: ReadableSpan) {\n    return {\n      resource: {\n        attributes: span.resource.attributes,\n      },\n      instrumentationScope: span.instrumentationScope,\n      traceId: span.spanContext().traceId,\n      parentSpanContext: span.parentSpanContext,\n      traceState: span.spanContext().traceState?.serialize(),\n      name: span.name,\n      id: span.spanContext().spanId,\n      kind: span.kind,\n      timestamp: hrTimeToMicroseconds(span.startTime),\n      duration: hrTimeToMicroseconds(span.duration),\n      attributes: span.attributes,\n      status: span.status,\n      events: span.events,\n      links: span.links,\n    };\n  }\n\n  /**\n   * Showing spans in console\n   * @param spans\n   * @param done\n   */\n  private _sendSpans(\n    spans: ReadableSpan[],\n    done?: (result: ExportResult) => void\n  ): void {\n    for (const span of spans) {\n      console.dir(this._exportInfo(span), { depth: 3 });\n    }\n    if (done) {\n      return done({ code: ExportResultCode.SUCCESS });\n    }\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { SpanExporter } from './SpanExporter';\nimport { ReadableSpan } from './ReadableSpan';\nimport { ExportResult, ExportResultCode } from '@opentelemetry/core';\n\n/**\n * This class can be used for testing purposes. It stores the exported spans\n * in a list in memory that can be retrieved using the `getFinishedSpans()`\n * method.\n */\nexport class InMemorySpanExporter implements SpanExporter {\n  private _finishedSpans: ReadableSpan[] = [];\n  /**\n   * Indicates if the exporter has been \"shutdown.\"\n   * When false, exported spans will not be stored in-memory.\n   */\n  protected _stopped = false;\n\n  export(\n    spans: ReadableSpan[],\n    resultCallback: (result: ExportResult) => void\n  ): void {\n    if (this._stopped)\n      return resultCallback({\n        code: ExportResultCode.FAILED,\n        error: new Error('Exporter has been stopped'),\n      });\n    this._finishedSpans.push(...spans);\n\n    setTimeout(() => resultCallback({ code: ExportResultCode.SUCCESS }), 0);\n  }\n\n  shutdown(): Promise<void> {\n    this._stopped = true;\n    this._finishedSpans = [];\n    return this.forceFlush();\n  }\n\n  /**\n   * Exports any pending spans in the exporter\n   */\n  forceFlush(): Promise<void> {\n    return Promise.resolve();\n  }\n\n  reset(): void {\n    this._finishedSpans = [];\n  }\n\n  getFinishedSpans(): ReadableSpan[] {\n    return this._finishedSpans;\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Context, TraceFlags } from '@opentelemetry/api';\nimport {\n  internal,\n  ExportResultCode,\n  globalErrorHandler,\n  BindOnceFuture,\n} from '@opentelemetry/core';\nimport { Span } from '../Span';\nimport { SpanProcessor } from '../SpanProcessor';\nimport { ReadableSpan } from './ReadableSpan';\nimport { SpanExporter } from './SpanExporter';\n\n/**\n * An implementation of the {@link SpanProcessor} that converts the {@link Span}\n * to {@link ReadableSpan} and passes it to the configured exporter.\n *\n * Only spans that are sampled are converted.\n *\n * NOTE: This {@link SpanProcessor} exports every ended span individually instead of batching spans together, which causes significant performance overhead with most exporters. For production use, please consider using the {@link BatchSpanProcessor} instead.\n */\nexport class SimpleSpanProcessor implements SpanProcessor {\n  private _shutdownOnce: BindOnceFuture<void>;\n  private _pendingExports: Set<Promise<void>>;\n\n  constructor(private readonly _exporter: SpanExporter) {\n    this._shutdownOnce = new BindOnceFuture(this._shutdown, this);\n    this._pendingExports = new Set<Promise<void>>();\n  }\n\n  async forceFlush(): Promise<void> {\n    await Promise.all(Array.from(this._pendingExports));\n    if (this._exporter.forceFlush) {\n      await this._exporter.forceFlush();\n    }\n  }\n\n  onStart(_span: Span, _parentContext: Context): void {}\n\n  onEnd(span: ReadableSpan): void {\n    if (this._shutdownOnce.isCalled) {\n      return;\n    }\n\n    if ((span.spanContext().traceFlags & TraceFlags.SAMPLED) === 0) {\n      return;\n    }\n\n    const pendingExport = this._doExport(span).catch(err =>\n      globalErrorHandler(err)\n    );\n    // Enqueue this export to the pending list so it can be flushed by the user.\n    this._pendingExports.add(pendingExport);\n    void pendingExport.finally(() =>\n      this._pendingExports.delete(pendingExport)\n    );\n  }\n\n  private async _doExport(span: ReadableSpan): Promise<void> {\n    if (span.resource.asyncAttributesPending) {\n      // Ensure resource is fully resolved before exporting.\n      await span.resource.waitForAsyncAttributes?.();\n    }\n\n    const result = await internal._export(this._exporter, [span]);\n    if (result.code !== ExportResultCode.SUCCESS) {\n      throw (\n        result.error ??\n        new Error(`SimpleSpanProcessor: span export failed (status ${result})`)\n      );\n    }\n  }\n\n  shutdown(): Promise<void> {\n    return this._shutdownOnce.call();\n  }\n\n  private _shutdown(): Promise<void> {\n    return this._exporter.shutdown();\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Context } from '@opentelemetry/api';\nimport { ReadableSpan } from './ReadableSpan';\nimport { Span } from '../Span';\nimport { SpanProcessor } from '../SpanProcessor';\n\n/** No-op implementation of SpanProcessor */\nexport class NoopSpanProcessor implements SpanProcessor {\n  onStart(_span: Span, _context: Context): void {}\n  onEnd(_span: ReadableSpan): void {}\n  shutdown(): Promise<void> {\n    return Promise.resolve();\n  }\n  forceFlush(): Promise<void> {\n    return Promise.resolve();\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Context, ContextManager, ROOT_CONTEXT } from '@opentelemetry/api';\n\n/**\n * Stack Context Manager for managing the state in web\n * it doesn't fully support the async calls though\n */\nexport class StackContextManager implements ContextManager {\n  /**\n   * whether the context manager is enabled or not\n   */\n  private _enabled = false;\n\n  /**\n   * Keeps the reference to current context\n   */\n  public _currentContext = ROOT_CONTEXT;\n\n  /**\n   *\n   * @param context\n   * @param target Function to be executed within the context\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-function-type\n  private _bindFunction<T extends Function>(\n    context = ROOT_CONTEXT,\n    target: T\n  ): T {\n    const manager = this;\n    const contextWrapper = function (this: unknown, ...args: unknown[]) {\n      return manager.with(context, () => target.apply(this, args));\n    };\n    Object.defineProperty(contextWrapper, 'length', {\n      enumerable: false,\n      configurable: true,\n      writable: false,\n      value: target.length,\n    });\n    return contextWrapper as unknown as T;\n  }\n\n  /**\n   * Returns the active context\n   */\n  active(): Context {\n    return this._currentContext;\n  }\n\n  /**\n   * Binds a the certain context or the active one to the target function and then returns the target\n   * @param context A context (span) to be bind to target\n   * @param target a function or event emitter. When target or one of its callbacks is called,\n   *  the provided context will be used as the active context for the duration of the call.\n   */\n  bind<T>(context: Context, target: T): T {\n    // if no specific context to propagate is given, we use the current one\n    if (context === undefined) {\n      context = this.active();\n    }\n    if (typeof target === 'function') {\n      return this._bindFunction(context, target);\n    }\n    return target;\n  }\n\n  /**\n   * Disable the context manager (clears the current context)\n   */\n  disable(): this {\n    this._currentContext = ROOT_CONTEXT;\n    this._enabled = false;\n    return this;\n  }\n\n  /**\n   * Enables the context manager and creates a default(root) context\n   */\n  enable(): this {\n    if (this._enabled) {\n      return this;\n    }\n    this._enabled = true;\n    this._currentContext = ROOT_CONTEXT;\n    return this;\n  }\n\n  /**\n   * Calls the callback function [fn] with the provided [context]. If [context] is undefined then it will use the window.\n   * The context will be set as active\n   * @param context\n   * @param fn Callback function\n   * @param thisArg optional receiver to be used for calling fn\n   * @param args optional arguments forwarded to fn\n   */\n  with<A extends unknown[], F extends (...args: A) => ReturnType<F>>(\n    context: Context | null,\n    fn: F,\n    thisArg?: ThisParameterType<F>,\n    ...args: A\n  ): ReturnType<F> {\n    const previousContext = this._currentContext;\n    this._currentContext = context || ROOT_CONTEXT;\n\n    try {\n      return fn.call(thisArg, ...args);\n    } finally {\n      this._currentContext = previousContext;\n    }\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  BasicTracerProvider,\n  SDKRegistrationConfig,\n  TracerConfig,\n} from '@opentelemetry/sdk-trace-base';\nimport { StackContextManager } from './StackContextManager';\nimport {\n  trace,\n  context,\n  ContextManager,\n  propagation,\n  TextMapPropagator,\n} from '@opentelemetry/api';\nimport {\n  CompositePropagator,\n  W3CBaggagePropagator,\n  W3CTraceContextPropagator,\n} from '@opentelemetry/core';\n\nfunction setupContextManager(\n  contextManager: ContextManager | null | undefined\n) {\n  // null means 'do not register'\n  if (contextManager === null) {\n    return;\n  }\n\n  // undefined means 'register default'\n  if (contextManager === undefined) {\n    const defaultContextManager = new StackContextManager();\n    defaultContextManager.enable();\n    context.setGlobalContextManager(defaultContextManager);\n    return;\n  }\n\n  contextManager.enable();\n  context.setGlobalContextManager(contextManager);\n}\n\nfunction setupPropagator(propagator: TextMapPropagator | null | undefined) {\n  // null means 'do not register'\n  if (propagator === null) {\n    return;\n  }\n\n  // undefined means 'register default'\n  if (propagator === undefined) {\n    propagation.setGlobalPropagator(\n      new CompositePropagator({\n        propagators: [\n          new W3CTraceContextPropagator(),\n          new W3CBaggagePropagator(),\n        ],\n      })\n    );\n    return;\n  }\n\n  propagation.setGlobalPropagator(propagator);\n}\n\n/**\n * WebTracerConfig provides an interface for configuring a Web Tracer.\n */\nexport type WebTracerConfig = TracerConfig;\n\n/**\n * This class represents a web tracer with {@link StackContextManager}\n */\nexport class WebTracerProvider extends BasicTracerProvider {\n  /**\n   * Constructs a new Tracer instance.\n   * @param config Web Tracer config\n   */\n  constructor(config: WebTracerConfig = {}) {\n    super(config);\n  }\n\n  /**\n   * Register this TracerProvider for use with the OpenTelemetry API.\n   * Undefined values may be replaced with defaults, and\n   * null values will be skipped.\n   *\n   * @param config Configuration object for SDK registration\n   */\n  register(config: SDKRegistrationConfig = {}): void {\n    trace.setGlobalTracerProvider(this);\n    setupPropagator(config.propagator);\n    setupContextManager(config.contextManager);\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport enum PerformanceTimingNames {\n  CONNECT_END = 'connectEnd',\n  CONNECT_START = 'connectStart',\n  DECODED_BODY_SIZE = 'decodedBodySize',\n  DOM_COMPLETE = 'domComplete',\n  DOM_CONTENT_LOADED_EVENT_END = 'domContentLoadedEventEnd',\n  DOM_CONTENT_LOADED_EVENT_START = 'domContentLoadedEventStart',\n  DOM_INTERACTIVE = 'domInteractive',\n  DOMAIN_LOOKUP_END = 'domainLookupEnd',\n  DOMAIN_LOOKUP_START = 'domainLookupStart',\n  ENCODED_BODY_SIZE = 'encodedBodySize',\n  FETCH_START = 'fetchStart',\n  LOAD_EVENT_END = 'loadEventEnd',\n  LOAD_EVENT_START = 'loadEventStart',\n  NAVIGATION_START = 'navigationStart',\n  REDIRECT_END = 'redirectEnd',\n  REDIRECT_START = 'redirectStart',\n  REQUEST_START = 'requestStart',\n  RESPONSE_END = 'responseEnd',\n  RESPONSE_START = 'responseStart',\n  SECURE_CONNECTION_START = 'secureConnectionStart',\n  START_TIME = 'startTime',\n  UNLOAD_EVENT_END = 'unloadEventEnd',\n  UNLOAD_EVENT_START = 'unloadEventStart',\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*\n * This file contains a copy of unstable semantic convention definitions\n * used by this package.\n * @see https://github.com/open-telemetry/opentelemetry-js/tree/main/semantic-conventions#unstable-semconv\n */\n\n/**\n * Deprecated, use `http.response.header.<key>` instead.\n *\n * @example 3495\n *\n * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.\n *\n * @deprecated Replaced by `http.response.header.<key>`.\n */\nexport const ATTR_HTTP_RESPONSE_CONTENT_LENGTH =\n  'http.response_content_length' as const;\n\n/**\n * Deprecated, use `http.response.body.size` instead.\n *\n * @example 5493\n *\n * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.\n *\n * @deprecated Replace by `http.response.body.size`.\n */\nexport const ATTR_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED =\n  'http.response_content_length_uncompressed' as const;\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  PerformanceEntries,\n  PerformanceResourceTimingInfo,\n  PropagateTraceHeaderCorsUrls,\n} from './types';\nimport { PerformanceTimingNames as PTN } from './enums/PerformanceTimingNames';\nimport * as api from '@opentelemetry/api';\nimport {\n  hrTimeToNanoseconds,\n  timeInputToHrTime,\n  urlMatches,\n} from '@opentelemetry/core';\nimport {\n  ATTR_HTTP_RESPONSE_CONTENT_LENGTH,\n  ATTR_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED,\n} from './semconv';\n\n// Used to normalize relative URLs\nlet urlNormalizingAnchor: HTMLAnchorElement | undefined;\nfunction getUrlNormalizingAnchor(): HTMLAnchorElement {\n  if (!urlNormalizingAnchor) {\n    urlNormalizingAnchor = document.createElement('a');\n  }\n\n  return urlNormalizingAnchor;\n}\n\n/**\n * Helper function to be able to use enum as typed key in type and in interface when using forEach\n * @param obj\n * @param key\n */\nexport function hasKey<O extends object>(\n  obj: O,\n  key: PropertyKey\n): key is keyof O {\n  return key in obj;\n}\n\n/**\n * Helper function for starting an event on span based on {@link PerformanceEntries}\n * @param span\n * @param performanceName name of performance entry for time start\n * @param entries\n * @param ignoreZeros\n */\nexport function addSpanNetworkEvent(\n  span: api.Span,\n  performanceName: string,\n  entries: PerformanceEntries,\n  ignoreZeros = true\n): api.Span | undefined {\n  if (\n    hasKey(entries, performanceName) &&\n    typeof entries[performanceName] === 'number' &&\n    !(ignoreZeros && entries[performanceName] === 0)\n  ) {\n    return span.addEvent(performanceName, entries[performanceName]);\n  }\n\n  return undefined;\n}\n\n/**\n * Helper function for adding network events and content length attributes.\n */\nexport function addSpanNetworkEvents(\n  span: api.Span,\n  resource: PerformanceEntries,\n  ignoreNetworkEvents = false,\n  ignoreZeros?: boolean,\n  skipOldSemconvContentLengthAttrs?: boolean\n): void {\n  if (ignoreZeros === undefined) {\n    ignoreZeros = resource[PTN.START_TIME] !== 0;\n  }\n\n  if (!ignoreNetworkEvents) {\n    addSpanNetworkEvent(span, PTN.FETCH_START, resource, ignoreZeros);\n    addSpanNetworkEvent(span, PTN.DOMAIN_LOOKUP_START, resource, ignoreZeros);\n    addSpanNetworkEvent(span, PTN.DOMAIN_LOOKUP_END, resource, ignoreZeros);\n    addSpanNetworkEvent(span, PTN.CONNECT_START, resource, ignoreZeros);\n    addSpanNetworkEvent(\n      span,\n      PTN.SECURE_CONNECTION_START,\n      resource,\n      ignoreZeros\n    );\n    addSpanNetworkEvent(span, PTN.CONNECT_END, resource, ignoreZeros);\n    addSpanNetworkEvent(span, PTN.REQUEST_START, resource, ignoreZeros);\n    addSpanNetworkEvent(span, PTN.RESPONSE_START, resource, ignoreZeros);\n    addSpanNetworkEvent(span, PTN.RESPONSE_END, resource, ignoreZeros);\n  }\n\n  if (!skipOldSemconvContentLengthAttrs) {\n    // This block adds content-length-related span attributes using the\n    // *old* HTTP semconv (v1.7.0).\n    const encodedLength = resource[PTN.ENCODED_BODY_SIZE];\n    if (encodedLength !== undefined) {\n      span.setAttribute(ATTR_HTTP_RESPONSE_CONTENT_LENGTH, encodedLength);\n    }\n\n    const decodedLength = resource[PTN.DECODED_BODY_SIZE];\n    // Spec: Not set if transport encoding not used (in which case encoded and decoded sizes match)\n    if (decodedLength !== undefined && encodedLength !== decodedLength) {\n      span.setAttribute(\n        ATTR_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED,\n        decodedLength\n      );\n    }\n  }\n}\n\n/**\n * sort resources by startTime\n * @param filteredResources\n */\nexport function sortResources(\n  filteredResources: PerformanceResourceTiming[]\n): PerformanceResourceTiming[] {\n  return filteredResources.slice().sort((a, b) => {\n    const valueA = a[PTN.FETCH_START];\n    const valueB = b[PTN.FETCH_START];\n    if (valueA > valueB) {\n      return 1;\n    } else if (valueA < valueB) {\n      return -1;\n    }\n    return 0;\n  });\n}\n\n/** Returns the origin if present (if in browser context). */\nfunction getOrigin(): string | undefined {\n  return typeof location !== 'undefined' ? location.origin : undefined;\n}\n\n/**\n * Get closest performance resource ignoring the resources that have been\n * already used.\n * @param spanUrl\n * @param startTimeHR\n * @param endTimeHR\n * @param resources\n * @param ignoredResources\n * @param initiatorType\n */\nexport function getResource(\n  spanUrl: string,\n  startTimeHR: api.HrTime,\n  endTimeHR: api.HrTime,\n  resources: PerformanceResourceTiming[],\n  ignoredResources: WeakSet<PerformanceResourceTiming> = new WeakSet<PerformanceResourceTiming>(),\n  initiatorType?: string\n): PerformanceResourceTimingInfo {\n  // de-relativize the URL before usage (does no harm to absolute URLs)\n  const parsedSpanUrl = parseUrl(spanUrl);\n  spanUrl = parsedSpanUrl.toString();\n\n  const filteredResources = filterResourcesForSpan(\n    spanUrl,\n    startTimeHR,\n    endTimeHR,\n    resources,\n    ignoredResources,\n    initiatorType\n  );\n\n  if (filteredResources.length === 0) {\n    return {\n      mainRequest: undefined,\n    };\n  }\n  if (filteredResources.length === 1) {\n    return {\n      mainRequest: filteredResources[0],\n    };\n  }\n  const sorted = sortResources(filteredResources);\n\n  if (parsedSpanUrl.origin !== getOrigin() && sorted.length > 1) {\n    let corsPreFlightRequest: PerformanceResourceTiming | undefined = sorted[0];\n    let mainRequest: PerformanceResourceTiming = findMainRequest(\n      sorted,\n      corsPreFlightRequest[PTN.RESPONSE_END],\n      endTimeHR\n    );\n\n    const responseEnd = corsPreFlightRequest[PTN.RESPONSE_END];\n    const fetchStart = mainRequest[PTN.FETCH_START];\n\n    // no corsPreFlightRequest\n    if (fetchStart < responseEnd) {\n      mainRequest = corsPreFlightRequest;\n      corsPreFlightRequest = undefined;\n    }\n\n    return {\n      corsPreFlightRequest,\n      mainRequest,\n    };\n  } else {\n    return {\n      mainRequest: filteredResources[0],\n    };\n  }\n}\n\n/**\n * Will find the main request skipping the cors pre flight requests\n * @param resources\n * @param corsPreFlightRequestEndTime\n * @param spanEndTimeHR\n */\nfunction findMainRequest(\n  resources: PerformanceResourceTiming[],\n  corsPreFlightRequestEndTime: number,\n  spanEndTimeHR: api.HrTime\n): PerformanceResourceTiming {\n  const spanEndTime = hrTimeToNanoseconds(spanEndTimeHR);\n  const minTime = hrTimeToNanoseconds(\n    timeInputToHrTime(corsPreFlightRequestEndTime)\n  );\n\n  let mainRequest: PerformanceResourceTiming = resources[1];\n  let bestGap;\n\n  const length = resources.length;\n  for (let i = 1; i < length; i++) {\n    const resource = resources[i];\n    const resourceStartTime = hrTimeToNanoseconds(\n      timeInputToHrTime(resource[PTN.FETCH_START])\n    );\n\n    const resourceEndTime = hrTimeToNanoseconds(\n      timeInputToHrTime(resource[PTN.RESPONSE_END])\n    );\n\n    const currentGap = spanEndTime - resourceEndTime;\n\n    if (resourceStartTime >= minTime && (!bestGap || currentGap < bestGap)) {\n      bestGap = currentGap;\n      mainRequest = resource;\n    }\n  }\n  return mainRequest;\n}\n\n/**\n * Filter all resources that has started and finished according to span start time and end time.\n *     It will return the closest resource to a start time\n * @param spanUrl\n * @param startTimeHR\n * @param endTimeHR\n * @param resources\n * @param ignoredResources\n */\nfunction filterResourcesForSpan(\n  spanUrl: string,\n  startTimeHR: api.HrTime,\n  endTimeHR: api.HrTime,\n  resources: PerformanceResourceTiming[],\n  ignoredResources: WeakSet<PerformanceResourceTiming>,\n  initiatorType?: string\n) {\n  const startTime = hrTimeToNanoseconds(startTimeHR);\n  const endTime = hrTimeToNanoseconds(endTimeHR);\n  let filteredResources = resources.filter(resource => {\n    const resourceStartTime = hrTimeToNanoseconds(\n      timeInputToHrTime(resource[PTN.FETCH_START])\n    );\n    const resourceEndTime = hrTimeToNanoseconds(\n      timeInputToHrTime(resource[PTN.RESPONSE_END])\n    );\n\n    return (\n      resource.initiatorType.toLowerCase() ===\n        (initiatorType || 'xmlhttprequest') &&\n      resource.name === spanUrl &&\n      resourceStartTime >= startTime &&\n      resourceEndTime <= endTime\n    );\n  });\n\n  if (filteredResources.length > 0) {\n    filteredResources = filteredResources.filter(resource => {\n      return !ignoredResources.has(resource);\n    });\n  }\n\n  return filteredResources;\n}\n\n/**\n * The URLLike interface represents an URL and HTMLAnchorElement compatible fields.\n */\nexport interface URLLike {\n  hash: string;\n  host: string;\n  hostname: string;\n  href: string;\n  readonly origin: string;\n  password: string;\n  pathname: string;\n  port: string;\n  protocol: string;\n  search: string;\n  username: string;\n}\n\n/**\n * Parses url using URL constructor or fallback to anchor element.\n * @param url\n */\nexport function parseUrl(url: string): URLLike {\n  if (typeof URL === 'function') {\n    return new URL(\n      url,\n      typeof document !== 'undefined'\n        ? document.baseURI\n        : typeof location !== 'undefined' // Some JS runtimes (e.g. Deno) don't define this\n          ? location.href\n          : undefined\n    );\n  }\n  const element = getUrlNormalizingAnchor();\n  element.href = url;\n  return element;\n}\n\n/**\n * Parses url using URL constructor or fallback to anchor element and serialize\n * it to a string.\n *\n * Performs the steps described in https://html.spec.whatwg.org/multipage/urls-and-fetching.html#parse-a-url\n *\n * @param url\n */\nexport function normalizeUrl(url: string): string {\n  const urlLike = parseUrl(url);\n  return urlLike.href;\n}\n\n/**\n * Get element XPath\n * @param target - target element\n * @param optimised - when id attribute of element is present the xpath can be\n * simplified to contain id\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\nexport function getElementXPath(target: any, optimised?: boolean): string {\n  if (target.nodeType === Node.DOCUMENT_NODE) {\n    return '/';\n  }\n  const targetValue = getNodeValue(target, optimised);\n  if (optimised && targetValue.indexOf('@id') > 0) {\n    return targetValue;\n  }\n  let xpath = '';\n  if (target.parentNode) {\n    xpath += getElementXPath(target.parentNode, false);\n  }\n  xpath += targetValue;\n\n  return xpath;\n}\n\n/**\n * get node index within the siblings\n * @param target\n */\nfunction getNodeIndex(target: HTMLElement): number {\n  if (!target.parentNode) {\n    return 0;\n  }\n  const allowedTypes = [target.nodeType];\n  if (target.nodeType === Node.CDATA_SECTION_NODE) {\n    allowedTypes.push(Node.TEXT_NODE);\n  }\n  let elements = Array.from(target.parentNode.childNodes);\n  elements = elements.filter((element: Node) => {\n    const localName = (element as HTMLElement).localName;\n    return (\n      allowedTypes.indexOf(element.nodeType) >= 0 &&\n      localName === target.localName\n    );\n  });\n  if (elements.length >= 1) {\n    return elements.indexOf(target) + 1; // xpath starts from 1\n  }\n  // if there are no other similar child xpath doesn't need index\n  return 0;\n}\n\n/**\n * get node value for xpath\n * @param target\n * @param optimised\n */\nfunction getNodeValue(target: HTMLElement, optimised?: boolean): string {\n  const nodeType = target.nodeType;\n  const index = getNodeIndex(target);\n  let nodeValue = '';\n  if (nodeType === Node.ELEMENT_NODE) {\n    const id = target.getAttribute('id');\n    if (optimised && id) {\n      return `//*[@id=\"${id}\"]`;\n    }\n    nodeValue = target.localName;\n  } else if (\n    nodeType === Node.TEXT_NODE ||\n    nodeType === Node.CDATA_SECTION_NODE\n  ) {\n    nodeValue = 'text()';\n  } else if (nodeType === Node.COMMENT_NODE) {\n    nodeValue = 'comment()';\n  } else {\n    return '';\n  }\n  // if index is 1 it can be omitted in xpath\n  if (nodeValue && index > 1) {\n    return `/${nodeValue}[${index}]`;\n  }\n  return `/${nodeValue}`;\n}\n\n/**\n * Checks if trace headers should be propagated\n * @param spanUrl\n * @private\n */\nexport function shouldPropagateTraceHeaders(\n  spanUrl: string,\n  propagateTraceHeaderCorsUrls?: PropagateTraceHeaderCorsUrls\n): boolean {\n  let propagateTraceHeaderUrls = propagateTraceHeaderCorsUrls || [];\n  if (\n    typeof propagateTraceHeaderUrls === 'string' ||\n    propagateTraceHeaderUrls instanceof RegExp\n  ) {\n    propagateTraceHeaderUrls = [propagateTraceHeaderUrls];\n  }\n  const parsedSpanUrl = parseUrl(spanUrl);\n\n  if (parsedSpanUrl.origin === getOrigin()) {\n    return true;\n  } else {\n    return propagateTraceHeaderUrls.some(propagateTraceHeaderUrl =>\n      urlMatches(spanUrl, propagateTraceHeaderUrl)\n    );\n  }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiBO,IAAM,qBAAqB;;;AC+D5B,IAAO,WAAP,MAAe;;;EAGF;EACR;EACA;EACA,aAAyB,CAAA;EACzB,QAAgB,CAAA;EAChB,SAAuB,CAAA;EACvB;EACA;EACA;EAED,0BAA0B;EAC1B,sBAA8B;EAC9B,qBAA6B;EAErC;EACA,SAAqB;IACnB,MAAM,eAAe;;EAEvB,UAAkB,CAAC,GAAG,CAAC;EACf,SAAS;EACT,YAAoB,CAAC,IAAI,EAAE;EAClB;EACA;EACA;EAEA;EACA;EACA;;;;EAKjB,YAAY,MAAiB;AAC3B,UAAM,MAAM,KAAK,IAAG;AAEpB,SAAK,eAAe,KAAK;AACzB,SAAK,wBAAwB,cAAc,IAAG;AAC9C,SAAK,qBACH,OAAO,KAAK,wBAAwB,cAAa;AACnD,SAAK,qBAAqB,KAAK,aAAa;AAC5C,SAAK,cAAc,KAAK;AACxB,SAAK,6BACH,KAAK,YAAY,6BAA6B;AAChD,SAAK,iBAAiB,KAAK;AAE3B,SAAK,OAAO,KAAK;AACjB,SAAK,oBAAoB,KAAK;AAC9B,SAAK,OAAO,KAAK;AACjB,SAAK,QAAQ,KAAK,SAAS,CAAA;AAC3B,SAAK,YAAY,KAAK,SAAS,KAAK,aAAa,GAAG;AACpD,SAAK,WAAW,KAAK;AACrB,SAAK,uBAAuB,KAAK;AAEjC,QAAI,KAAK,cAAc,MAAM;AAC3B,WAAK,cAAc,KAAK,UAAU;;AAGpC,SAAK,eAAe,QAAQ,MAAM,KAAK,OAAO;EAChD;EAEA,cAAW;AACT,WAAO,KAAK;EACd;EAGA,aAAa,KAAa,OAAc;AACtC,QAAI,SAAS,QAAQ,KAAK,aAAY;AAAI,aAAO;AACjD,QAAI,IAAI,WAAW,GAAG;AACpB,WAAK,KAAK,0BAA0B,GAAG,EAAE;AACzC,aAAO;;AAET,QAAI,CAAC,iBAAiB,KAAK,GAAG;AAC5B,WAAK,KAAK,wCAAwC,GAAG,EAAE;AACvD,aAAO;;AAGT,UAAM,EAAE,oBAAmB,IAAK,KAAK;AAErC,QACE,wBAAwB,UACxB,OAAO,KAAK,KAAK,UAAU,EAAE,UAAU,uBACvC,CAAC,OAAO,UAAU,eAAe,KAAK,KAAK,YAAY,GAAG,GAC1D;AACA,WAAK;AACL,aAAO;;AAET,SAAK,WAAW,GAAG,IAAI,KAAK,gBAAgB,KAAK;AACjD,WAAO;EACT;EAEA,cAAc,YAAsB;AAClC,eAAW,CAAC,GAAG,CAAC,KAAK,OAAO,QAAQ,UAAU,GAAG;AAC/C,WAAK,aAAa,GAAG,CAAC;;AAExB,WAAO;EACT;;;;;;;;EASA,SACE,MACA,uBACA,WAAqB;AAErB,QAAI,KAAK,aAAY;AAAI,aAAO;AAEhC,UAAM,EAAE,gBAAe,IAAK,KAAK;AAEjC,QAAI,oBAAoB,GAAG;AACzB,WAAK,KAAK,oBAAoB;AAC9B,WAAK;AACL,aAAO;;AAGT,QACE,oBAAoB,UACpB,KAAK,OAAO,UAAU,iBACtB;AACA,UAAI,KAAK,wBAAwB,GAAG;AAClC,aAAK,MAAM,wBAAwB;;AAErC,WAAK,OAAO,MAAK;AACjB,WAAK;;AAGP,QAAI,YAAY,qBAAqB,GAAG;AACtC,UAAI,CAAC,YAAY,SAAS,GAAG;AAC3B,oBAAY;;AAEd,8BAAwB;;AAG1B,UAAM,aAAa,mBAAmB,qBAAqB;AAE3D,SAAK,OAAO,KAAK;MACf;MACA;MACA,MAAM,KAAK,SAAS,SAAS;MAC7B,wBAAwB;KACzB;AACD,WAAO;EACT;EAEA,QAAQ,MAAU;AAChB,SAAK,MAAM,KAAK,IAAI;AACpB,WAAO;EACT;EAEA,SAAS,OAAa;AACpB,SAAK,MAAM,KAAK,GAAG,KAAK;AACxB,WAAO;EACT;EAEA,UAAU,QAAkB;AAC1B,QAAI,KAAK,aAAY;AAAI,aAAO;AAChC,SAAK,SAAS,EAAE,GAAG,OAAM;AAMzB,QAAI,KAAK,OAAO,WAAW,QAAQ,OAAO,OAAO,YAAY,UAAU;AACrE,WAAK,KACH,4CAA4C,OAAO,OAAO,OAAO,sBAAsB;AAEzF,aAAO,KAAK,OAAO;;AAGrB,WAAO;EACT;EAEA,WAAW,MAAY;AACrB,QAAI,KAAK,aAAY;AAAI,aAAO;AAChC,SAAK,OAAO;AACZ,WAAO;EACT;EAEA,IAAI,SAAmB;AACrB,QAAI,KAAK,aAAY,GAAI;AACvB,WAAK,MACH,GAAG,KAAK,IAAI,IAAI,KAAK,aAAa,OAAO,IAAI,KAAK,aAAa,MAAM,4CAA4C;AAEnH;;AAEF,SAAK,SAAS;AAEd,SAAK,UAAU,KAAK,SAAS,OAAO;AACpC,SAAK,YAAY,eAAe,KAAK,WAAW,KAAK,OAAO;AAE5D,QAAI,KAAK,UAAU,CAAC,IAAI,GAAG;AACzB,WAAK,KACH,uFACA,KAAK,WACL,KAAK,OAAO;AAEd,WAAK,UAAU,KAAK,UAAU,MAAK;AACnC,WAAK,YAAY,CAAC,GAAG,CAAC;;AAGxB,QAAI,KAAK,sBAAsB,GAAG;AAChC,WAAK,KACH,WAAW,KAAK,mBAAmB,yCAAyC;;AAIhF,SAAK,eAAe,MAAM,IAAI;EAChC;EAEQ,SAAS,KAAe;AAC9B,QAAI,OAAO,QAAQ,YAAY,OAAO,cAAc,IAAG,GAAI;AAGzD,aAAO,OAAO,MAAM,KAAK,kBAAkB;;AAG7C,QAAI,OAAO,QAAQ,UAAU;AAC3B,aAAO,eAAe,GAAG;;AAG3B,QAAI,eAAe,MAAM;AACvB,aAAO,eAAe,IAAI,QAAO,CAAE;;AAGrC,QAAI,kBAAkB,GAAG,GAAG;AAC1B,aAAO;;AAGT,QAAI,KAAK,oBAAoB;AAG3B,aAAO,eAAe,KAAK,IAAG,CAAE;;AAGlC,UAAM,aAAa,cAAc,IAAG,IAAK,KAAK;AAC9C,WAAO,WAAW,KAAK,WAAW,eAAe,UAAU,CAAC;EAC9D;EAEA,cAAW;AACT,WAAO,KAAK,WAAW;EACzB;EAEA,gBAAgB,WAAsB,MAAgB;AACpD,UAAM,aAAyB,CAAA;AAC/B,QAAI,OAAO,cAAc,UAAU;AACjC,iBAAW,sBAAsB,IAAI;eAC5B,WAAW;AACpB,UAAI,UAAU,MAAM;AAClB,mBAAW,mBAAmB,IAAI,UAAU,KAAK,SAAQ;iBAChD,UAAU,MAAM;AACzB,mBAAW,mBAAmB,IAAI,UAAU;;AAE9C,UAAI,UAAU,SAAS;AACrB,mBAAW,sBAAsB,IAAI,UAAU;;AAEjD,UAAI,UAAU,OAAO;AACnB,mBAAW,yBAAyB,IAAI,UAAU;;;AAKtD,QAAI,WAAW,mBAAmB,KAAK,WAAW,sBAAsB,GAAG;AACzE,WAAK,SAAS,oBAAoB,YAAY,IAAI;WAC7C;AACL,WAAK,KAAK,iCAAiC,SAAS,EAAE;;EAE1D;EAEA,IAAI,WAAQ;AACV,WAAO,KAAK;EACd;EAEA,IAAI,QAAK;AACP,WAAO,KAAK;EACd;EAEA,IAAI,yBAAsB;AACxB,WAAO,KAAK;EACd;EAEA,IAAI,qBAAkB;AACpB,WAAO,KAAK;EACd;EAEA,IAAI,oBAAiB;AACnB,WAAO,KAAK;EACd;EAEQ,eAAY;AAClB,QAAI,KAAK,QAAQ;AACf,YAAM,QAAQ,IAAI,MAChB,+CAA+C,KAAK,aAAa,OAAO,aAAa,KAAK,aAAa,MAAM,GAAG;AAGlH,WAAK,KACH,wDAAwD,KAAK,aAAa,OAAO,aAAa,KAAK,aAAa,MAAM,KACtH,KAAK;;AAGT,WAAO,KAAK;EACd;;;;EAKQ,qBAAqB,OAAe,OAAa;AACvD,QAAI,MAAM,UAAU,OAAO;AACzB,aAAO;;AAET,WAAO,MAAM,UAAU,GAAG,KAAK;EACjC;;;;;;;;;;;;;EAcQ,gBAAgB,OAAqB;AAC3C,UAAM,QAAQ,KAAK;AAEnB,QAAI,SAAS,GAAG;AAEd,WAAK,KAAK,+CAA+C,KAAK,EAAE;AAChE,aAAO;;AAIT,QAAI,OAAO,UAAU,UAAU;AAC7B,aAAO,KAAK,qBAAqB,OAAO,KAAK;;AAI/C,QAAI,MAAM,QAAQ,KAAK,GAAG;AACxB,aAAQ,MAAa,IAAI,SACvB,OAAO,QAAQ,WAAW,KAAK,qBAAqB,KAAK,KAAK,IAAI,GAAG;;AAKzE,WAAO;EACT;;;;ACtZF,IAAYA;CAAZ,SAAYA,mBAAgB;AAK1B,EAAAA,kBAAAA,kBAAA,YAAA,IAAA,CAAA,IAAA;AAKA,EAAAA,kBAAAA,kBAAA,QAAA,IAAA,CAAA,IAAA;AAKA,EAAAA,kBAAAA,kBAAA,oBAAA,IAAA,CAAA,IAAA;AACF,GAhBYA,sBAAAA,oBAAgB,CAAA,EAAA;;;ACTtB,IAAO,mBAAP,MAAuB;EAC3B,eAAY;AACV,WAAO;MACL,UAAUC,kBAAiB;;EAE/B;EAEA,WAAQ;AACN,WAAO;EACT;;;;ACTI,IAAO,kBAAP,MAAsB;EAC1B,eAAY;AACV,WAAO;MACL,UAAUC,kBAAiB;;EAE/B;EAEA,WAAQ;AACN,WAAO;EACT;;;;ACMI,IAAO,qBAAP,MAAyB;EACrB;EACA;EACA;EACA;EACA;EAER,YAAY,QAAgC;AAC1C,SAAK,QAAQ,OAAO;AAEpB,QAAI,CAAC,KAAK,OAAO;AACf,yBACE,IAAI,MAAM,wDAAwD,CAAC;AAErE,WAAK,QAAQ,IAAI,gBAAe;;AAGlC,SAAK,uBACH,OAAO,uBAAuB,IAAI,gBAAe;AACnD,SAAK,0BACH,OAAO,0BAA0B,IAAI,iBAAgB;AACvD,SAAK,sBACH,OAAO,sBAAsB,IAAI,gBAAe;AAClD,SAAK,yBACH,OAAO,yBAAyB,IAAI,iBAAgB;EACxD;EAEA,aACEC,UACA,SACA,UACA,UACA,YACA,OAAa;AAEb,UAAM,gBAAgB,MAAM,eAAeA,QAAO;AAElD,QAAI,CAAC,iBAAiB,CAAC,mBAAmB,aAAa,GAAG;AACxD,aAAO,KAAK,MAAM,aAChBA,UACA,SACA,UACA,UACA,YACA,KAAK;;AAIT,QAAI,cAAc,UAAU;AAC1B,UAAI,cAAc,aAAa,WAAW,SAAS;AACjD,eAAO,KAAK,qBAAqB,aAC/BA,UACA,SACA,UACA,UACA,YACA,KAAK;;AAGT,aAAO,KAAK,wBAAwB,aAClCA,UACA,SACA,UACA,UACA,YACA,KAAK;;AAIT,QAAI,cAAc,aAAa,WAAW,SAAS;AACjD,aAAO,KAAK,oBAAoB,aAC9BA,UACA,SACA,UACA,UACA,YACA,KAAK;;AAIT,WAAO,KAAK,uBAAuB,aACjCA,UACA,SACA,UACA,UACA,YACA,KAAK;EAET;EAEA,WAAQ;AACN,WAAO,oBAAoB,KAAK,MAAM,SAAQ,CAAE,yBAAyB,KAAK,qBAAqB,SAAQ,CAAE,4BAA4B,KAAK,wBAAwB,SAAQ,CAAE,wBAAwB,KAAK,oBAAoB,SAAQ,CAAE,2BAA2B,KAAK,uBAAuB,SAAQ,CAAE;EAC9S;;;;AC1GI,IAAO,2BAAP,MAA+B;EAGN;EAFrB;EAER,YAA6B,SAAS,GAAC;AAAV,SAAA,SAAA;AAC3B,SAAK,SAAS,KAAK,WAAW,MAAM;AACpC,SAAK,cAAc,KAAK,MAAM,KAAK,SAAS,UAAU;EACxD;EAEA,aAAaC,UAAkB,SAAe;AAC5C,WAAO;MACL,UACE,eAAe,OAAO,KAAK,KAAK,YAAY,OAAO,IAAI,KAAK,cACxDC,kBAAiB,qBACjBA,kBAAiB;;EAE3B;EAEA,WAAQ;AACN,WAAO,qBAAqB,KAAK,MAAM;EACzC;EAEQ,WAAW,OAAa;AAC9B,QAAI,OAAO,UAAU,YAAY,MAAM,KAAK;AAAG,aAAO;AACtD,WAAO,SAAS,IAAI,IAAI,SAAS,IAAI,IAAI;EAC3C;EAEQ,YAAY,SAAe;AACjC,QAAI,eAAe;AACnB,aAAS,IAAI,GAAG,IAAI,QAAQ,SAAS,GAAG,KAAK;AAC3C,YAAM,MAAM,IAAI;AAChB,YAAM,OAAO,SAAS,QAAQ,MAAM,KAAK,MAAM,CAAC,GAAG,EAAE;AACrD,sBAAgB,eAAe,UAAU;;AAE3C,WAAO;EACT;;;;AC9BF,IAAW;CAAX,SAAWC,sBAAmB;AAC5B,EAAAA,qBAAA,WAAA,IAAA;AACA,EAAAA,qBAAA,UAAA,IAAA;AACA,EAAAA,qBAAA,sBAAA,IAAA;AACA,EAAAA,qBAAA,qBAAA,IAAA;AACA,EAAAA,qBAAA,yBAAA,IAAA;AACA,EAAAA,qBAAA,cAAA,IAAA;AACF,GAPW,wBAAA,sBAAmB,CAAA,EAAA;AAS9B,IAAM,gBAAgB;AAWhB,SAAU,oBAAiB;AAC/B,SAAO;IACL,SAAS,oBAAmB;IAC5B,yBAAyB;IACzB,eAAe;MACb,2BACE,iBAAiB,mCAAmC,KAAK;MAC3D,qBACE,iBAAiB,4BAA4B,KAAK;;IAEtD,YAAY;MACV,2BACE,iBAAiB,wCAAwC,KAAK;MAChE,qBACE,iBAAiB,iCAAiC,KAAK;MACzD,gBAAgB,iBAAiB,4BAA4B,KAAK;MAClE,iBAAiB,iBAAiB,6BAA6B,KAAK;MACpE,6BACE,iBAAiB,2CAA2C,KAAK;MACnE,4BACE,iBAAiB,0CAA0C,KAAK;;;AAGxE;AAKM,SAAU,sBAAmB;AACjC,QAAM,UACJ,iBAAiB,qBAAqB,KACtC,oBAAoB;AACtB,UAAQ,SAAS;IACf,KAAK,oBAAoB;AACvB,aAAO,IAAI,gBAAe;IAC5B,KAAK,oBAAoB;AACvB,aAAO,IAAI,iBAAgB;IAC7B,KAAK,oBAAoB;AACvB,aAAO,IAAI,mBAAmB;QAC5B,MAAM,IAAI,gBAAe;OAC1B;IACH,KAAK,oBAAoB;AACvB,aAAO,IAAI,mBAAmB;QAC5B,MAAM,IAAI,iBAAgB;OAC3B;IACH,KAAK,oBAAoB;AACvB,aAAO,IAAI,yBAAyB,6BAA4B,CAAE;IACpE,KAAK,oBAAoB;AACvB,aAAO,IAAI,mBAAmB;QAC5B,MAAM,IAAI,yBAAyB,6BAA4B,CAAE;OAClE;IACH;AACE,WAAK,MACH,8BAA8B,OAAO,6BAA6B,oBAAoB,mBAAmB,IAAI;AAE/G,aAAO,IAAI,mBAAmB;QAC5B,MAAM,IAAI,gBAAe;OAC1B;;AAEP;AAEA,SAAS,+BAA4B;AACnC,QAAM,cAAc,iBAAiB,yBAAyB;AAC9D,MAAI,eAAe,MAAM;AACvB,SAAK,MACH,mDAAmD,aAAa,GAAG;AAErE,WAAO;;AAGT,MAAI,cAAc,KAAK,cAAc,GAAG;AACtC,SAAK,MACH,2BAA2B,WAAW,8DAA8D,aAAa,GAAG;AAEtH,WAAO;;AAGT,SAAO;AACT;;;ACrGO,IAAM,gCAAgC;AACtC,IAAM,uCAAuC;AAM9C,SAAU,YAAY,YAAwB;AAKlD,QAAM,sBAA6C;IACjD,SAAS,oBAAmB;;AAG9B,QAAM,iBAAiB,kBAAiB;AAExC,QAAM,SAAS,OAAO,OACpB,CAAA,GACA,gBACA,qBACA,UAAU;AAGZ,SAAO,gBAAgB,OAAO,OAC5B,CAAA,GACA,eAAe,eACf,WAAW,iBAAiB,CAAA,CAAE;AAGhC,SAAO,aAAa,OAAO,OACzB,CAAA,GACA,eAAe,YACf,WAAW,cAAc,CAAA,CAAE;AAG7B,SAAO;AACT;AAOM,SAAU,kBAAkB,YAAwB;AACxD,QAAM,aAAa,OAAO,OAAO,CAAA,GAAI,WAAW,UAAU;AAK1D,aAAW,sBACT,WAAW,YAAY,uBACvB,WAAW,eAAe,uBAC1B,iBAAiB,iCAAiC,KAClD,iBAAiB,4BAA4B,KAC7C;AAKF,aAAW,4BACT,WAAW,YAAY,6BACvB,WAAW,eAAe,6BAC1B,iBAAiB,wCAAwC,KACzD,iBAAiB,mCAAmC,KACpD;AAEF,SAAO,OAAO,OAAO,CAAA,GAAI,YAAY,EAAE,WAAU,CAAE;AACrD;;;ACxDM,IAAgB,yBAAhB,MAAsC;EAevB;EAZF;EACA;EACA;EACA;EAET,eAAe;EACf,iBAAiC,CAAA;EACjC;EACA;EACA,qBAA6B;EAErC,YACmB,WACjB,QAAU;AADO,SAAA,YAAA;AAGjB,SAAK,sBACH,OAAO,QAAQ,uBAAuB,WAClC,OAAO,qBACN,iBAAiB,gCAAgC,KAAK;AAC7D,SAAK,gBACH,OAAO,QAAQ,iBAAiB,WAC5B,OAAO,eACN,iBAAiB,yBAAyB,KAAK;AACtD,SAAK,wBACH,OAAO,QAAQ,yBAAyB,WACpC,OAAO,uBACN,iBAAiB,yBAAyB,KAAK;AACtD,SAAK,uBACH,OAAO,QAAQ,wBAAwB,WACnC,OAAO,sBACN,iBAAiB,yBAAyB,KAAK;AAEtD,SAAK,gBAAgB,IAAI,eAAe,KAAK,WAAW,IAAI;AAE5D,QAAI,KAAK,sBAAsB,KAAK,eAAe;AACjD,WAAK,KACH,mIAAmI;AAErI,WAAK,sBAAsB,KAAK;;EAEpC;EAEA,aAAU;AACR,QAAI,KAAK,cAAc,UAAU;AAC/B,aAAO,KAAK,cAAc;;AAE5B,WAAO,KAAK,UAAS;EACvB;;EAGA,QAAQ,OAAa,gBAAuB;EAAS;EAErD,MAAM,MAAkB;AACtB,QAAI,KAAK,cAAc,UAAU;AAC/B;;AAGF,SAAK,KAAK,YAAW,EAAG,aAAa,WAAW,aAAa,GAAG;AAC9D;;AAGF,SAAK,aAAa,IAAI;EACxB;EAEA,WAAQ;AACN,WAAO,KAAK,cAAc,KAAI;EAChC;EAEQ,YAAS;AACf,WAAO,QAAQ,QAAO,EACnB,KAAK,MAAK;AACT,aAAO,KAAK,WAAU;IACxB,CAAC,EACA,KAAK,MAAK;AACT,aAAO,KAAK,UAAS;IACvB,CAAC,EACA,KAAK,MAAK;AACT,aAAO,KAAK,UAAU,SAAQ;IAChC,CAAC;EACL;;EAGQ,aAAa,MAAkB;AACrC,QAAI,KAAK,eAAe,UAAU,KAAK,eAAe;AAGpD,UAAI,KAAK,uBAAuB,GAAG;AACjC,aAAK,MAAM,sCAAsC;;AAEnD,WAAK;AAEL;;AAGF,QAAI,KAAK,qBAAqB,GAAG;AAE/B,WAAK,KACH,WAAW,KAAK,kBAAkB,qCAAqC;AAEzE,WAAK,qBAAqB;;AAG5B,SAAK,eAAe,KAAK,IAAI;AAC7B,SAAK,iBAAgB;EACvB;;;;;;EAOQ,YAAS;AACf,WAAO,IAAI,QAAQ,CAAC,SAAS,WAAU;AACrC,YAAM,WAAW,CAAA;AAEjB,YAAM,QAAQ,KAAK,KACjB,KAAK,eAAe,SAAS,KAAK,mBAAmB;AAEvD,eAAS,IAAI,GAAG,IAAI,OAAO,IAAI,GAAG,KAAK;AACrC,iBAAS,KAAK,KAAK,eAAc,CAAE;;AAErC,cAAQ,IAAI,QAAQ,EACjB,KAAK,MAAK;AACT,gBAAO;MACT,CAAC,EACA,MAAM,MAAM;IACjB,CAAC;EACH;EAEQ,iBAAc;AACpB,SAAK,YAAW;AAChB,QAAI,KAAK,eAAe,WAAW,GAAG;AACpC,aAAO,QAAQ,QAAO;;AAExB,WAAO,IAAI,QAAQ,CAAC,SAAS,WAAU;AACrC,YAAM,QAAQ,WAAW,MAAK;AAE5B,eAAO,IAAI,MAAM,SAAS,CAAC;MAC7B,GAAG,KAAK,oBAAoB;AAE5B,cAAQ,KAAK,gBAAgB,QAAQ,OAAM,CAAE,GAAG,MAAK;AAInD,YAAI;AACJ,YAAI,KAAK,eAAe,UAAU,KAAK,qBAAqB;AAC1D,kBAAQ,KAAK;AACb,eAAK,iBAAiB,CAAA;eACjB;AACL,kBAAQ,KAAK,eAAe,OAAO,GAAG,KAAK,mBAAmB;;AAGhE,cAAM,WAAW,MACf,KAAK,UAAU,OAAO,OAAO,YAAS;AACpC,uBAAa,KAAK;AAClB,cAAI,OAAO,SAAS,iBAAiB,SAAS;AAC5C,oBAAO;iBACF;AACL,mBACE,OAAO,SACL,IAAI,MAAM,wCAAwC,CAAC;;QAG3D,CAAC;AAEH,YAAI,mBAAgD;AACpD,iBAAS,IAAI,GAAG,MAAM,MAAM,QAAQ,IAAI,KAAK,KAAK;AAChD,gBAAM,OAAO,MAAM,CAAC;AACpB,cACE,KAAK,SAAS,0BACd,KAAK,SAAS,wBACd;AACA,iCAAqB,CAAA;AACrB,6BAAiB,KAAK,KAAK,SAAS,uBAAsB,CAAE;;;AAKhE,YAAI,qBAAqB,MAAM;AAC7B,mBAAQ;eACH;AACL,kBAAQ,IAAI,gBAAgB,EAAE,KAAK,UAAU,SAAM;AACjD,+BAAmB,GAAG;AACtB,mBAAO,GAAG;UACZ,CAAC;;MAEL,CAAC;IACH,CAAC;EACH;EAEQ,mBAAgB;AACtB,QAAI,KAAK;AAAc;AACvB,UAAM,QAAQ,MAAK;AACjB,WAAK,eAAe;AACpB,WAAK,eAAc,EAChB,QAAQ,MAAK;AACZ,aAAK,eAAe;AACpB,YAAI,KAAK,eAAe,SAAS,GAAG;AAClC,eAAK,YAAW;AAChB,eAAK,iBAAgB;;MAEzB,CAAC,EACA,MAAM,OAAI;AACT,aAAK,eAAe;AACpB,2BAAmB,CAAC;MACtB,CAAC;IACL;AAEA,QAAI,KAAK,eAAe,UAAU,KAAK,qBAAqB;AAC1D,aAAO,MAAK;;AAEd,QAAI,KAAK,WAAW;AAAW;AAC/B,SAAK,SAAS,WAAW,MAAM,MAAK,GAAI,KAAK,qBAAqB;AAGlE,QAAI,OAAO,KAAK,WAAW,UAAU;AACnC,WAAK,OAAO,MAAK;;EAErB;EAEQ,cAAW;AACjB,QAAI,KAAK,WAAW,QAAW;AAC7B,mBAAa,KAAK,MAAM;AACxB,WAAK,SAAS;;EAElB;;;;ACjPI,IAAO,qBAAP,cAAkC,uBAAuD;EACrF;EACA;EAER,YACE,WACA,QAAwC;AAExC,UAAM,WAAW,MAAM;AACvB,SAAK,OAAO,MAAM;EACpB;EAEQ,OAAO,QAAwC;AACrD,QACE,QAAQ,mCAAmC,QAC3C,OAAO,aAAa,aACpB;AACA,WAAK,4BAA4B,MAAK;AACpC,YAAI,SAAS,oBAAoB,UAAU;AACzC,eAAK,WAAU,EAAG,MAAM,WAAQ;AAC9B,+BAAmB,KAAK;UAC1B,CAAC;;MAEL;AACA,WAAK,oBAAoB,MAAK;AAC5B,aAAK,WAAU,EAAG,MAAM,WAAQ;AAC9B,6BAAmB,KAAK;QAC1B,CAAC;MACH;AACA,eAAS,iBACP,oBACA,KAAK,yBAAyB;AAIhC,eAAS,iBAAiB,YAAY,KAAK,iBAAiB;;EAEhE;EAEU,aAAU;AAClB,QAAI,OAAO,aAAa,aAAa;AACnC,UAAI,KAAK,2BAA2B;AAClC,iBAAS,oBACP,oBACA,KAAK,yBAAyB;;AAGlC,UAAI,KAAK,mBAAmB;AAC1B,iBAAS,oBAAoB,YAAY,KAAK,iBAAiB;;;EAGrE;;;;ACtDF,IAAM,gBAAgB;AACtB,IAAM,iBAAiB;AAEjB,IAAO,oBAAP,MAAwB;;;;;EAK5B,kBAAkB,eAAe,cAAc;;;;;EAM/C,iBAAiB,eAAe,aAAa;;AAG/C,IAAM,0BAA0B,MAAM,EAAE;AACxC,SAAS,eAAe,OAAa;AACnC,SAAO,SAAS,aAAU;AACxB,aAAS,IAAI,GAAG,IAAI,QAAQ,GAAG,KAAK;AAClC,8BAAwB,CAAC,IAAI,KAAK,MAAM,KAAK,OAAM,IAAK,EAAE,IAAI;AAE9D,UAAI,wBAAwB,CAAC,KAAK,IAAI;AACpC,gCAAwB,CAAC,KAAK;;;AAGlC,WAAO,OAAO,aAAa,MACzB,MACA,wBAAwB,MAAM,GAAG,QAAQ,CAAC,CAAC;EAE/C;AACF;;;AChBM,IAAO,SAAP,MAAa;EACA;EACA;EACA;EACA;EACR;EAEQ;EACA;;;;EAKjB,YACE,sBACA,QACA,UACA,eAA4B;AAE5B,UAAM,cAAc,YAAY,MAAM;AACtC,SAAK,WAAW,YAAY;AAC5B,SAAK,iBAAiB,YAAY;AAClC,SAAK,cAAc,YAAY;AAC/B,SAAK,eAAe,OAAO,eAAe,IAAI,kBAAiB;AAC/D,SAAK,YAAY;AACjB,SAAK,iBAAiB;AACtB,SAAK,uBAAuB;EAC9B;;;;;EAMA,UACE,MACA,UAA2B,CAAA,GAC3BC,WAAc,QAAQ,OAAM,GAAE;AAG9B,QAAI,QAAQ,MAAM;AAChB,MAAAA,WAAc,MAAM,WAAWA,QAAO;;AAExC,UAAM,aAAiB,MAAM,QAAQA,QAAO;AAE5C,QAAI,oBAAoBA,QAAO,GAAG;AAChC,MAAI,KAAK,MAAM,iDAAiD;AAChE,YAAM,mBAAuB,MAAM,gBAC7B,oBAAoB;AAE1B,aAAO;;AAGT,UAAM,oBAAoB,YAAY,YAAW;AACjD,UAAM,SAAS,KAAK,aAAa,eAAc;AAC/C,QAAI;AACJ,QAAI;AACJ,QAAI;AACJ,QACE,CAAC,qBACD,CAAK,MAAM,mBAAmB,iBAAiB,GAC/C;AAEA,gBAAU,KAAK,aAAa,gBAAe;WACtC;AAEL,gBAAU,kBAAkB;AAC5B,mBAAa,kBAAkB;AAC/B,+BAAyB;;AAG3B,UAAM,WAAW,QAAQ,QAAY,SAAS;AAC9C,UAAM,SAAS,QAAQ,SAAS,CAAA,GAAI,IAAI,UAAO;AAC7C,aAAO;QACL,SAAS,KAAK;QACd,YAAY,mBAAmB,KAAK,UAAU;;IAElD,CAAC;AACD,UAAM,aAAa,mBAAmB,QAAQ,UAAU;AAExD,UAAM,iBAAiB,KAAK,SAAS,aACnCA,UACA,SACA,MACA,UACA,YACA,KAAK;AAGP,iBAAa,eAAe,cAAc;AAE1C,UAAM,aACJ,eAAe,aAAiB,iBAAiB,qBACzC,WAAW,UACX,WAAW;AACrB,UAAM,cAAc,EAAE,SAAS,QAAQ,YAAY,WAAU;AAC7D,QAAI,eAAe,aAAiB,iBAAiB,YAAY;AAC/D,MAAI,KAAK,MACP,+DAA+D;AAEjE,YAAM,mBAAuB,MAAM,gBAAgB,WAAW;AAC9D,aAAO;;AAKT,UAAM,iBAAiB,mBACrB,OAAO,OAAO,YAAY,eAAe,UAAU,CAAC;AAGtD,UAAM,OAAO,IAAI,SAAS;MACxB,UAAU,KAAK;MACf,OAAO,KAAK;MACZ,SAAAA;MACA;MACA;MACA,MAAM;MACN;MACA,mBAAmB;MACnB,YAAY;MACZ,WAAW,QAAQ;MACnB,eAAe,KAAK;MACpB,YAAY,KAAK;KAClB;AACD,WAAO;EACT;EA4DA,gBACE,MACA,MACA,MACA,MAAQ;AAER,QAAI;AACJ,QAAI;AACJ,QAAI;AAEJ,QAAI,UAAU,SAAS,GAAG;AACxB;eACS,UAAU,WAAW,GAAG;AACjC,WAAK;eACI,UAAU,WAAW,GAAG;AACjC,aAAO;AACP,WAAK;WACA;AACL,aAAO;AACP,YAAM;AACN,WAAK;;AAGP,UAAM,gBAAgB,OAAW,QAAQ,OAAM;AAC/C,UAAM,OAAO,KAAK,UAAU,MAAM,MAAM,aAAa;AACrD,UAAM,qBAAyB,MAAM,QAAQ,eAAe,IAAI;AAEhE,WAAW,QAAQ,KAAK,oBAAoB,IAAI,QAAW,IAAI;EACjE;;EAGA,mBAAgB;AACd,WAAO,KAAK;EACd;;EAGA,gBAAa;AACX,WAAO,KAAK;EACd;;;;ACtOI,IAAO,qBAAP,MAAyB;EACA;EAA7B,YAA6B,iBAAgC;AAAhC,SAAA,kBAAA;EAAmC;EAEhE,aAAU;AACR,UAAM,WAA4B,CAAA;AAElC,eAAW,iBAAiB,KAAK,iBAAiB;AAChD,eAAS,KAAK,cAAc,WAAU,CAAE;;AAE1C,WAAO,IAAI,QAAQ,aAAU;AAC3B,cAAQ,IAAI,QAAQ,EACjB,KAAK,MAAK;AACT,gBAAO;MACT,CAAC,EACA,MAAM,WAAQ;AACb,2BACE,SAAS,IAAI,MAAM,uCAAuC,CAAC;AAE7D,gBAAO;MACT,CAAC;IACL,CAAC;EACH;EAEA,QAAQ,MAAYC,UAAgB;AAClC,eAAW,iBAAiB,KAAK,iBAAiB;AAChD,oBAAc,QAAQ,MAAMA,QAAO;;EAEvC;EAEA,MAAM,MAAkB;AACtB,eAAW,iBAAiB,KAAK,iBAAiB;AAChD,oBAAc,MAAM,IAAI;;EAE5B;EAEA,WAAQ;AACN,UAAM,WAA4B,CAAA;AAElC,eAAW,iBAAiB,KAAK,iBAAiB;AAChD,eAAS,KAAK,cAAc,SAAQ,CAAE;;AAExC,WAAO,IAAI,QAAQ,CAAC,SAAS,WAAU;AACrC,cAAQ,IAAI,QAAQ,EAAE,KAAK,MAAK;AAC9B,gBAAO;MACT,GAAG,MAAM;IACX,CAAC;EACH;;;;AC9CF,IAAY;CAAZ,SAAYC,kBAAe;AACzB,EAAAA,iBAAAA,iBAAA,UAAA,IAAA,CAAA,IAAA;AACA,EAAAA,iBAAAA,iBAAA,SAAA,IAAA,CAAA,IAAA;AACA,EAAAA,iBAAAA,iBAAA,OAAA,IAAA,CAAA,IAAA;AACA,EAAAA,iBAAAA,iBAAA,YAAA,IAAA,CAAA,IAAA;AACF,GALY,oBAAA,kBAAe,CAAA,EAAA;AAUrB,IAAO,sBAAP,MAA0B;EACb;EACA,WAAgC,oBAAI,IAAG;EACvC;EACA;EAEjB,YAAY,SAAuB,CAAA,GAAE;AACnC,UAAM,eAAe,MACnB,CAAA,GACA,kBAAiB,GACjB,kBAAkB,MAAM,CAAC;AAE3B,SAAK,YAAY,aAAa,YAAY,gBAAe;AAEzD,SAAK,UAAU,OAAO,OAAO,CAAA,GAAI,cAAc;MAC7C,UAAU,KAAK;KAChB;AAED,UAAM,iBAAkC,CAAA;AAExC,QAAI,OAAO,gBAAgB,QAAQ;AACjC,qBAAe,KAAK,GAAG,OAAO,cAAc;;AAG9C,SAAK,uBAAuB,IAAI,mBAAmB,cAAc;EACnE;EAEA,UACE,MACA,SACA,SAAgC;AAEhC,UAAM,MAAM,GAAG,IAAI,IAAI,WAAW,EAAE,IAAI,SAAS,aAAa,EAAE;AAChE,QAAI,CAAC,KAAK,SAAS,IAAI,GAAG,GAAG;AAC3B,WAAK,SAAS,IACZ,KACA,IAAI,OACF,EAAE,MAAM,SAAS,WAAW,SAAS,UAAS,GAC9C,KAAK,SACL,KAAK,WACL,KAAK,oBAAoB,CAC1B;;AAKL,WAAO,KAAK,SAAS,IAAI,GAAG;EAC9B;EAEA,aAAU;AACR,UAAM,UAAU,KAAK,QAAQ;AAC7B,UAAM,WAAW,KAAK,qBAAqB,iBAAiB,EAAE,IAC5D,CAAC,kBAAgC;AAC/B,aAAO,IAAI,QAAQ,aAAU;AAC3B,YAAI;AACJ,cAAM,kBAAkB,WAAW,MAAK;AACtC,kBACE,IAAI,MACF,6DAA6D,OAAO,KAAK,CAC1E;AAEH,kBAAQ,gBAAgB;QAC1B,GAAG,OAAO;AAEV,sBACG,WAAU,EACV,KAAK,MAAK;AACT,uBAAa,eAAe;AAC5B,cAAI,UAAU,gBAAgB,SAAS;AACrC,oBAAQ,gBAAgB;AACxB,oBAAQ,KAAK;;QAEjB,CAAC,EACA,MAAM,WAAQ;AACb,uBAAa,eAAe;AAC5B,kBAAQ,gBAAgB;AACxB,kBAAQ,KAAK;QACf,CAAC;MACL,CAAC;IACH,CAAC;AAGH,WAAO,IAAI,QAAc,CAAC,SAAS,WAAU;AAC3C,cAAQ,IAAI,QAAQ,EACjB,KAAK,aAAU;AACd,cAAM,SAAS,QAAQ,OACrB,YAAU,WAAW,gBAAgB,QAAQ;AAE/C,YAAI,OAAO,SAAS,GAAG;AACrB,iBAAO,MAAM;eACR;AACL,kBAAO;;MAEX,CAAC,EACA,MAAM,WAAS,OAAO,CAAC,KAAK,CAAC,CAAC;IACnC,CAAC;EACH;EAEA,WAAQ;AACN,WAAO,KAAK,qBAAqB,SAAQ;EAC3C;;;;ACxGI,IAAO,sBAAP,MAA0B;;;;;;EAM9B,OACE,OACA,gBAA8C;AAE9C,WAAO,KAAK,WAAW,OAAO,cAAc;EAC9C;;;;EAKA,WAAQ;AACN,SAAK,WAAW,CAAA,CAAE;AAClB,WAAO,KAAK,WAAU;EACxB;;;;EAKA,aAAU;AACR,WAAO,QAAQ,QAAO;EACxB;;;;;EAMQ,YAAY,MAAkB;AACpC,WAAO;MACL,UAAU;QACR,YAAY,KAAK,SAAS;;MAE5B,sBAAsB,KAAK;MAC3B,SAAS,KAAK,YAAW,EAAG;MAC5B,mBAAmB,KAAK;MACxB,YAAY,KAAK,YAAW,EAAG,YAAY,UAAS;MACpD,MAAM,KAAK;MACX,IAAI,KAAK,YAAW,EAAG;MACvB,MAAM,KAAK;MACX,WAAW,qBAAqB,KAAK,SAAS;MAC9C,UAAU,qBAAqB,KAAK,QAAQ;MAC5C,YAAY,KAAK;MACjB,QAAQ,KAAK;MACb,QAAQ,KAAK;MACb,OAAO,KAAK;;EAEhB;;;;;;EAOQ,WACN,OACA,MAAqC;AAErC,eAAW,QAAQ,OAAO;AACxB,cAAQ,IAAI,KAAK,YAAY,IAAI,GAAG,EAAE,OAAO,EAAC,CAAE;;AAElD,QAAI,MAAM;AACR,aAAO,KAAK,EAAE,MAAM,iBAAiB,QAAO,CAAE;;EAElD;;;;AC3EI,IAAO,uBAAP,MAA2B;EACvB,iBAAiC,CAAA;;;;;EAK/B,WAAW;EAErB,OACE,OACA,gBAA8C;AAE9C,QAAI,KAAK;AACP,aAAO,eAAe;QACpB,MAAM,iBAAiB;QACvB,OAAO,IAAI,MAAM,2BAA2B;OAC7C;AACH,SAAK,eAAe,KAAK,GAAG,KAAK;AAEjC,eAAW,MAAM,eAAe,EAAE,MAAM,iBAAiB,QAAO,CAAE,GAAG,CAAC;EACxE;EAEA,WAAQ;AACN,SAAK,WAAW;AAChB,SAAK,iBAAiB,CAAA;AACtB,WAAO,KAAK,WAAU;EACxB;;;;EAKA,aAAU;AACR,WAAO,QAAQ,QAAO;EACxB;EAEA,QAAK;AACH,SAAK,iBAAiB,CAAA;EACxB;EAEA,mBAAgB;AACd,WAAO,KAAK;EACd;;;;AC9BI,IAAO,sBAAP,MAA0B;EAID;EAHrB;EACA;EAER,YAA6B,WAAuB;AAAvB,SAAA,YAAA;AAC3B,SAAK,gBAAgB,IAAI,eAAe,KAAK,WAAW,IAAI;AAC5D,SAAK,kBAAkB,oBAAI,IAAG;EAChC;EAEA,MAAM,aAAU;AACd,UAAM,QAAQ,IAAI,MAAM,KAAK,KAAK,eAAe,CAAC;AAClD,QAAI,KAAK,UAAU,YAAY;AAC7B,YAAM,KAAK,UAAU,WAAU;;EAEnC;EAEA,QAAQ,OAAa,gBAAuB;EAAS;EAErD,MAAM,MAAkB;AACtB,QAAI,KAAK,cAAc,UAAU;AAC/B;;AAGF,SAAK,KAAK,YAAW,EAAG,aAAa,WAAW,aAAa,GAAG;AAC9D;;AAGF,UAAM,gBAAgB,KAAK,UAAU,IAAI,EAAE,MAAM,SAC/C,mBAAmB,GAAG,CAAC;AAGzB,SAAK,gBAAgB,IAAI,aAAa;AACtC,SAAK,cAAc,QAAQ,MACzB,KAAK,gBAAgB,OAAO,aAAa,CAAC;EAE9C;EAEQ,MAAM,UAAU,MAAkB;AACxC,QAAI,KAAK,SAAS,wBAAwB;AAExC,YAAM,KAAK,SAAS,yBAAwB;;AAG9C,UAAM,SAAS,MAAM,SAAS,QAAQ,KAAK,WAAW,CAAC,IAAI,CAAC;AAC5D,QAAI,OAAO,SAAS,iBAAiB,SAAS;AAC5C,YACE,OAAO,SACP,IAAI,MAAM,mDAAmD,MAAM,GAAG;;EAG5E;EAEA,WAAQ;AACN,WAAO,KAAK,cAAc,KAAI;EAChC;EAEQ,YAAS;AACf,WAAO,KAAK,UAAU,SAAQ;EAChC;;;;ACxEI,IAAO,oBAAP,MAAwB;EAC5B,QAAQ,OAAa,UAAiB;EAAS;EAC/C,MAAM,OAAmB;EAAS;EAClC,WAAQ;AACN,WAAO,QAAQ,QAAO;EACxB;EACA,aAAU;AACR,WAAO,QAAQ,QAAO;EACxB;;;;ACRI,IAAO,sBAAP,MAA0B;;;;EAItB,WAAW;;;;EAKZ,kBAAkB;;;;;;;EAQjB,cACNC,WAAU,cACV,QAAS;AAET,UAAM,UAAU;AAChB,UAAM,iBAAiB,YAA4B,MAAe;AAChE,aAAO,QAAQ,KAAKA,UAAS,MAAM,OAAO,MAAM,MAAM,IAAI,CAAC;IAC7D;AACA,WAAO,eAAe,gBAAgB,UAAU;MAC9C,YAAY;MACZ,cAAc;MACd,UAAU;MACV,OAAO,OAAO;KACf;AACD,WAAO;EACT;;;;EAKA,SAAM;AACJ,WAAO,KAAK;EACd;;;;;;;EAQA,KAAQA,UAAkB,QAAS;AAEjC,QAAIA,aAAY,QAAW;AACzB,MAAAA,WAAU,KAAK,OAAM;;AAEvB,QAAI,OAAO,WAAW,YAAY;AAChC,aAAO,KAAK,cAAcA,UAAS,MAAM;;AAE3C,WAAO;EACT;;;;EAKA,UAAO;AACL,SAAK,kBAAkB;AACvB,SAAK,WAAW;AAChB,WAAO;EACT;;;;EAKA,SAAM;AACJ,QAAI,KAAK,UAAU;AACjB,aAAO;;AAET,SAAK,WAAW;AAChB,SAAK,kBAAkB;AACvB,WAAO;EACT;;;;;;;;;EAUA,KACEA,UACA,IACA,YACG,MAAO;AAEV,UAAM,kBAAkB,KAAK;AAC7B,SAAK,kBAAkBA,YAAW;AAElC,QAAI;AACF,aAAO,GAAG,KAAK,SAAS,GAAG,IAAI;;AAE/B,WAAK,kBAAkB;;EAE3B;;;;ACxFF,SAAS,oBACP,gBAAiD;AAGjD,MAAI,mBAAmB,MAAM;AAC3B;;AAIF,MAAI,mBAAmB,QAAW;AAChC,UAAM,wBAAwB,IAAI,oBAAmB;AACrD,0BAAsB,OAAM;AAC5B,YAAQ,wBAAwB,qBAAqB;AACrD;;AAGF,iBAAe,OAAM;AACrB,UAAQ,wBAAwB,cAAc;AAChD;AAEA,SAAS,gBAAgB,YAAgD;AAEvE,MAAI,eAAe,MAAM;AACvB;;AAIF,MAAI,eAAe,QAAW;AAC5B,gBAAY,oBACV,IAAI,oBAAoB;MACtB,aAAa;QACX,IAAI,0BAAyB;QAC7B,IAAI,qBAAoB;;KAE3B,CAAC;AAEJ;;AAGF,cAAY,oBAAoB,UAAU;AAC5C;AAUM,IAAO,oBAAP,cAAiC,oBAAmB;;;;;EAKxD,YAAY,SAA0B,CAAA,GAAE;AACtC,UAAM,MAAM;EACd;;;;;;;;EASA,SAAS,SAAgC,CAAA,GAAE;AACzC,UAAM,wBAAwB,IAAI;AAClC,oBAAgB,OAAO,UAAU;AACjC,wBAAoB,OAAO,cAAc;EAC3C;;;;ACzFF,IAAY;CAAZ,SAAYC,yBAAsB;AAChC,EAAAA,wBAAA,aAAA,IAAA;AACA,EAAAA,wBAAA,eAAA,IAAA;AACA,EAAAA,wBAAA,mBAAA,IAAA;AACA,EAAAA,wBAAA,cAAA,IAAA;AACA,EAAAA,wBAAA,8BAAA,IAAA;AACA,EAAAA,wBAAA,gCAAA,IAAA;AACA,EAAAA,wBAAA,iBAAA,IAAA;AACA,EAAAA,wBAAA,mBAAA,IAAA;AACA,EAAAA,wBAAA,qBAAA,IAAA;AACA,EAAAA,wBAAA,mBAAA,IAAA;AACA,EAAAA,wBAAA,aAAA,IAAA;AACA,EAAAA,wBAAA,gBAAA,IAAA;AACA,EAAAA,wBAAA,kBAAA,IAAA;AACA,EAAAA,wBAAA,kBAAA,IAAA;AACA,EAAAA,wBAAA,cAAA,IAAA;AACA,EAAAA,wBAAA,gBAAA,IAAA;AACA,EAAAA,wBAAA,eAAA,IAAA;AACA,EAAAA,wBAAA,cAAA,IAAA;AACA,EAAAA,wBAAA,gBAAA,IAAA;AACA,EAAAA,wBAAA,yBAAA,IAAA;AACA,EAAAA,wBAAA,YAAA,IAAA;AACA,EAAAA,wBAAA,kBAAA,IAAA;AACA,EAAAA,wBAAA,oBAAA,IAAA;AACF,GAxBY,2BAAA,yBAAsB,CAAA,EAAA;;;ACe3B,IAAM,oCACX;AAWK,IAAM,iDACX;;;ACVF,IAAI;AACJ,SAAS,0BAAuB;AAC9B,MAAI,CAAC,sBAAsB;AACzB,2BAAuB,SAAS,cAAc,GAAG;;AAGnD,SAAO;AACT;AAOM,SAAU,OACd,KACA,KAAgB;AAEhB,SAAO,OAAO;AAChB;AASM,SAAU,oBACd,MACA,iBACA,SACA,cAAc,MAAI;AAElB,MACE,OAAO,SAAS,eAAe,KAC/B,OAAO,QAAQ,eAAe,MAAM,YACpC,EAAE,eAAe,QAAQ,eAAe,MAAM,IAC9C;AACA,WAAO,KAAK,SAAS,iBAAiB,QAAQ,eAAe,CAAC;;AAGhE,SAAO;AACT;AAKM,SAAU,qBACd,MACA,UACA,sBAAsB,OACtB,aACA,kCAA0C;AAE1C,MAAI,gBAAgB,QAAW;AAC7B,kBAAc,SAAS,uBAAI,UAAU,MAAM;;AAG7C,MAAI,CAAC,qBAAqB;AACxB,wBAAoB,MAAM,uBAAI,aAAa,UAAU,WAAW;AAChE,wBAAoB,MAAM,uBAAI,qBAAqB,UAAU,WAAW;AACxE,wBAAoB,MAAM,uBAAI,mBAAmB,UAAU,WAAW;AACtE,wBAAoB,MAAM,uBAAI,eAAe,UAAU,WAAW;AAClE,wBACE,MACA,uBAAI,yBACJ,UACA,WAAW;AAEb,wBAAoB,MAAM,uBAAI,aAAa,UAAU,WAAW;AAChE,wBAAoB,MAAM,uBAAI,eAAe,UAAU,WAAW;AAClE,wBAAoB,MAAM,uBAAI,gBAAgB,UAAU,WAAW;AACnE,wBAAoB,MAAM,uBAAI,cAAc,UAAU,WAAW;;AAGnE,MAAI,CAAC,kCAAkC;AAGrC,UAAM,gBAAgB,SAAS,uBAAI,iBAAiB;AACpD,QAAI,kBAAkB,QAAW;AAC/B,WAAK,aAAa,mCAAmC,aAAa;;AAGpE,UAAM,gBAAgB,SAAS,uBAAI,iBAAiB;AAEpD,QAAI,kBAAkB,UAAa,kBAAkB,eAAe;AAClE,WAAK,aACH,gDACA,aAAa;;;AAIrB;AAMM,SAAU,cACd,mBAA8C;AAE9C,SAAO,kBAAkB,MAAK,EAAG,KAAK,CAAC,GAAG,MAAK;AAC7C,UAAM,SAAS,EAAE,uBAAI,WAAW;AAChC,UAAM,SAAS,EAAE,uBAAI,WAAW;AAChC,QAAI,SAAS,QAAQ;AACnB,aAAO;eACE,SAAS,QAAQ;AAC1B,aAAO;;AAET,WAAO;EACT,CAAC;AACH;AAGA,SAAS,YAAS;AAChB,SAAO,OAAO,aAAa,cAAc,SAAS,SAAS;AAC7D;AAYM,SAAU,YACd,SACA,aACA,WACA,WACA,mBAAuD,oBAAI,QAAO,GAClE,eAAsB;AAGtB,QAAM,gBAAgB,SAAS,OAAO;AACtC,YAAU,cAAc,SAAQ;AAEhC,QAAM,oBAAoB,uBACxB,SACA,aACA,WACA,WACA,kBACA,aAAa;AAGf,MAAI,kBAAkB,WAAW,GAAG;AAClC,WAAO;MACL,aAAa;;;AAGjB,MAAI,kBAAkB,WAAW,GAAG;AAClC,WAAO;MACL,aAAa,kBAAkB,CAAC;;;AAGpC,QAAM,SAAS,cAAc,iBAAiB;AAE9C,MAAI,cAAc,WAAW,UAAS,KAAM,OAAO,SAAS,GAAG;AAC7D,QAAI,uBAA8D,OAAO,CAAC;AAC1E,QAAI,cAAyC,gBAC3C,QACA,qBAAqB,uBAAI,YAAY,GACrC,SAAS;AAGX,UAAM,cAAc,qBAAqB,uBAAI,YAAY;AACzD,UAAM,aAAa,YAAY,uBAAI,WAAW;AAG9C,QAAI,aAAa,aAAa;AAC5B,oBAAc;AACd,6BAAuB;;AAGzB,WAAO;MACL;MACA;;SAEG;AACL,WAAO;MACL,aAAa,kBAAkB,CAAC;;;AAGtC;AAQA,SAAS,gBACP,WACA,6BACA,eAAyB;AAEzB,QAAM,cAAc,oBAAoB,aAAa;AACrD,QAAM,UAAU,oBACd,kBAAkB,2BAA2B,CAAC;AAGhD,MAAI,cAAyC,UAAU,CAAC;AACxD,MAAI;AAEJ,QAAM,SAAS,UAAU;AACzB,WAAS,IAAI,GAAG,IAAI,QAAQ,KAAK;AAC/B,UAAM,WAAW,UAAU,CAAC;AAC5B,UAAM,oBAAoB,oBACxB,kBAAkB,SAAS,uBAAI,WAAW,CAAC,CAAC;AAG9C,UAAM,kBAAkB,oBACtB,kBAAkB,SAAS,uBAAI,YAAY,CAAC,CAAC;AAG/C,UAAM,aAAa,cAAc;AAEjC,QAAI,qBAAqB,YAAY,CAAC,WAAW,aAAa,UAAU;AACtE,gBAAU;AACV,oBAAc;;;AAGlB,SAAO;AACT;AAWA,SAAS,uBACP,SACA,aACA,WACA,WACA,kBACA,eAAsB;AAEtB,QAAM,YAAY,oBAAoB,WAAW;AACjD,QAAM,UAAU,oBAAoB,SAAS;AAC7C,MAAI,oBAAoB,UAAU,OAAO,cAAW;AAClD,UAAM,oBAAoB,oBACxB,kBAAkB,SAAS,uBAAI,WAAW,CAAC,CAAC;AAE9C,UAAM,kBAAkB,oBACtB,kBAAkB,SAAS,uBAAI,YAAY,CAAC,CAAC;AAG/C,WACE,SAAS,cAAc,YAAW,OAC/B,iBAAiB,qBACpB,SAAS,SAAS,WAClB,qBAAqB,aACrB,mBAAmB;EAEvB,CAAC;AAED,MAAI,kBAAkB,SAAS,GAAG;AAChC,wBAAoB,kBAAkB,OAAO,cAAW;AACtD,aAAO,CAAC,iBAAiB,IAAI,QAAQ;IACvC,CAAC;;AAGH,SAAO;AACT;AAuBM,SAAU,SAAS,KAAW;AAClC,MAAI,OAAO,QAAQ,YAAY;AAC7B,WAAO,IAAI,IACT,KACA,OAAO,aAAa,cAChB,SAAS,UACT,OAAO,aAAa,cAClB,SAAS,OACT,MAAS;;AAGnB,QAAM,UAAU,wBAAuB;AACvC,UAAQ,OAAO;AACf,SAAO;AACT;AAUM,SAAU,aAAa,KAAW;AACtC,QAAM,UAAU,SAAS,GAAG;AAC5B,SAAO,QAAQ;AACjB;AASM,SAAU,gBAAgB,QAAa,WAAmB;AAC9D,MAAI,OAAO,aAAa,KAAK,eAAe;AAC1C,WAAO;;AAET,QAAM,cAAc,aAAa,QAAQ,SAAS;AAClD,MAAI,aAAa,YAAY,QAAQ,KAAK,IAAI,GAAG;AAC/C,WAAO;;AAET,MAAI,QAAQ;AACZ,MAAI,OAAO,YAAY;AACrB,aAAS,gBAAgB,OAAO,YAAY,KAAK;;AAEnD,WAAS;AAET,SAAO;AACT;AAMA,SAAS,aAAa,QAAmB;AACvC,MAAI,CAAC,OAAO,YAAY;AACtB,WAAO;;AAET,QAAM,eAAe,CAAC,OAAO,QAAQ;AACrC,MAAI,OAAO,aAAa,KAAK,oBAAoB;AAC/C,iBAAa,KAAK,KAAK,SAAS;;AAElC,MAAI,WAAW,MAAM,KAAK,OAAO,WAAW,UAAU;AACtD,aAAW,SAAS,OAAO,CAAC,YAAiB;AAC3C,UAAM,YAAa,QAAwB;AAC3C,WACE,aAAa,QAAQ,QAAQ,QAAQ,KAAK,KAC1C,cAAc,OAAO;EAEzB,CAAC;AACD,MAAI,SAAS,UAAU,GAAG;AACxB,WAAO,SAAS,QAAQ,MAAM,IAAI;;AAGpC,SAAO;AACT;AAOA,SAAS,aAAa,QAAqB,WAAmB;AAC5D,QAAM,WAAW,OAAO;AACxB,QAAM,QAAQ,aAAa,MAAM;AACjC,MAAI,YAAY;AAChB,MAAI,aAAa,KAAK,cAAc;AAClC,UAAM,KAAK,OAAO,aAAa,IAAI;AACnC,QAAI,aAAa,IAAI;AACnB,aAAO,YAAY,EAAE;;AAEvB,gBAAY,OAAO;aAEnB,aAAa,KAAK,aAClB,aAAa,KAAK,oBAClB;AACA,gBAAY;aACH,aAAa,KAAK,cAAc;AACzC,gBAAY;SACP;AACL,WAAO;;AAGT,MAAI,aAAa,QAAQ,GAAG;AAC1B,WAAO,IAAI,SAAS,IAAI,KAAK;;AAE/B,SAAO,IAAI,SAAS;AACtB;AAOM,SAAU,4BACd,SACA,8BAA2D;AAE3D,MAAI,2BAA2B,gCAAgC,CAAA;AAC/D,MACE,OAAO,6BAA6B,YACpC,oCAAoC,QACpC;AACA,+BAA2B,CAAC,wBAAwB;;AAEtD,QAAM,gBAAgB,SAAS,OAAO;AAEtC,MAAI,cAAc,WAAW,UAAS,GAAI;AACxC,WAAO;SACF;AACL,WAAO,yBAAyB,KAAK,6BACnC,WAAW,SAAS,uBAAuB,CAAC;;AAGlD;",
  "names": ["SamplingDecision", "SamplingDecision", "SamplingDecision", "context", "context", "SamplingDecision", "TracesSamplerValues", "context", "context", "ForceFlushState", "context", "PerformanceTimingNames"]
}
