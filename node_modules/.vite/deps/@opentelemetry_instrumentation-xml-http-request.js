import {
  PerformanceTimingNames,
  addSpanNetworkEvents,
  getResource,
  parseUrl,
  shouldPropagateTraceHeaders
} from "./chunk-SDFO7HFY.js";
import {
  InstrumentationBase,
  SemconvStability,
  isWrapped,
  safeExecuteInTheMiddle,
  semconvStabilityFromStr
} from "./chunk-EF4EXS77.js";
import {
  getStringListFromEnv,
  hrTime,
  isUrlIgnored,
  otperformance
} from "./chunk-MUUYURUO.js";
import {
  ATTR_ERROR_TYPE,
  ATTR_HTTP_REQUEST_METHOD,
  ATTR_HTTP_REQUEST_METHOD_ORIGINAL,
  ATTR_HTTP_RESPONSE_STATUS_CODE,
  ATTR_SERVER_ADDRESS,
  ATTR_SERVER_PORT,
  ATTR_URL_FULL
} from "./chunk-JOJVESY7.js";
import {
  SpanKind,
  SpanStatusCode,
  context,
  diag,
  propagation,
  trace
} from "./chunk-WWXHSA53.js";
import "./chunk-CXVDPRWL.js";
import "./chunk-G3PMV62Z.js";

// node_modules/.pnpm/@opentelemetry+instrumentation-xml-http-request@0.208.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-xml-http-request/build/esm/semconv.js
var ATTR_HTTP_HOST = "http.host";
var ATTR_HTTP_METHOD = "http.method";
var ATTR_HTTP_REQUEST_BODY_SIZE = "http.request.body.size";
var ATTR_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED = "http.request_content_length_uncompressed";
var ATTR_HTTP_SCHEME = "http.scheme";
var ATTR_HTTP_STATUS_CODE = "http.status_code";
var ATTR_HTTP_URL = "http.url";
var ATTR_HTTP_USER_AGENT = "http.user_agent";

// node_modules/.pnpm/@opentelemetry+instrumentation-xml-http-request@0.208.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-xml-http-request/build/esm/enums/EventNames.js
var EventNames;
(function(EventNames2) {
  EventNames2["METHOD_OPEN"] = "open";
  EventNames2["METHOD_SEND"] = "send";
  EventNames2["EVENT_ABORT"] = "abort";
  EventNames2["EVENT_ERROR"] = "error";
  EventNames2["EVENT_LOAD"] = "loaded";
  EventNames2["EVENT_TIMEOUT"] = "timeout";
})(EventNames || (EventNames = {}));

// node_modules/.pnpm/@opentelemetry+instrumentation-xml-http-request@0.208.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-xml-http-request/build/esm/utils.js
var DIAG_LOGGER = diag.createComponentLogger({
  namespace: "@opentelemetry/opentelemetry-instrumentation-xml-http-request/utils"
});
function isDocument(value) {
  return typeof Document !== "undefined" && value instanceof Document;
}
function getXHRBodyLength(body) {
  if (isDocument(body)) {
    return new XMLSerializer().serializeToString(document).length;
  }
  if (typeof body === "string") {
    return getByteLength(body);
  }
  if (body instanceof Blob) {
    return body.size;
  }
  if (body instanceof FormData) {
    return getFormDataSize(body);
  }
  if (body instanceof URLSearchParams) {
    return getByteLength(body.toString());
  }
  if (body.byteLength !== void 0) {
    return body.byteLength;
  }
  DIAG_LOGGER.warn("unknown body type");
  return void 0;
}
var TEXT_ENCODER = new TextEncoder();
function getByteLength(s) {
  return TEXT_ENCODER.encode(s).byteLength;
}
function getFormDataSize(formData) {
  let size = 0;
  for (const [key, value] of formData.entries()) {
    size += key.length;
    if (value instanceof Blob) {
      size += value.size;
    } else {
      size += value.length;
    }
  }
  return size;
}
function normalizeHttpRequestMethod(method) {
  const knownMethods2 = getKnownMethods();
  const methUpper = method.toUpperCase();
  if (methUpper in knownMethods2) {
    return methUpper;
  } else {
    return "_OTHER";
  }
}
var DEFAULT_KNOWN_METHODS = {
  CONNECT: true,
  DELETE: true,
  GET: true,
  HEAD: true,
  OPTIONS: true,
  PATCH: true,
  POST: true,
  PUT: true,
  TRACE: true
};
var knownMethods;
function getKnownMethods() {
  if (knownMethods === void 0) {
    const cfgMethods = getStringListFromEnv("OTEL_INSTRUMENTATION_HTTP_KNOWN_METHODS");
    if (cfgMethods && cfgMethods.length > 0) {
      knownMethods = {};
      cfgMethods.forEach((m) => {
        knownMethods[m] = true;
      });
    } else {
      knownMethods = DEFAULT_KNOWN_METHODS;
    }
  }
  return knownMethods;
}
var HTTP_PORT_FROM_PROTOCOL = {
  "https:": "443",
  "http:": "80"
};
function serverPortFromUrl(url) {
  const serverPort = Number(url.port || HTTP_PORT_FROM_PROTOCOL[url.protocol]);
  if (serverPort && !isNaN(serverPort)) {
    return serverPort;
  } else {
    return void 0;
  }
}

// node_modules/.pnpm/@opentelemetry+instrumentation-xml-http-request@0.208.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-xml-http-request/build/esm/version.js
var VERSION = "0.208.0";

// node_modules/.pnpm/@opentelemetry+instrumentation-xml-http-request@0.208.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-xml-http-request/build/esm/enums/AttributeNames.js
var AttributeNames;
(function(AttributeNames2) {
  AttributeNames2["HTTP_STATUS_TEXT"] = "http.status_text";
})(AttributeNames || (AttributeNames = {}));

// node_modules/.pnpm/@opentelemetry+instrumentation-xml-http-request@0.208.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-xml-http-request/build/esm/xhr.js
var OBSERVER_WAIT_TIME_MS = 300;
var XMLHttpRequestInstrumentation = class extends InstrumentationBase {
  component = "xml-http-request";
  version = VERSION;
  moduleName = this.component;
  _tasksCount = 0;
  _xhrMem = /* @__PURE__ */ new WeakMap();
  _usedResources = /* @__PURE__ */ new WeakSet();
  _semconvStability;
  constructor(config = {}) {
    super("@opentelemetry/instrumentation-xml-http-request", VERSION, config);
    this._semconvStability = semconvStabilityFromStr("http", config?.semconvStabilityOptIn);
  }
  init() {
  }
  /**
   * Adds custom headers to XMLHttpRequest
   * @param xhr
   * @param spanUrl
   * @private
   */
  _addHeaders(xhr, spanUrl) {
    const url = parseUrl(spanUrl).href;
    if (!shouldPropagateTraceHeaders(url, this.getConfig().propagateTraceHeaderCorsUrls)) {
      const headers2 = {};
      propagation.inject(context.active(), headers2);
      if (Object.keys(headers2).length > 0) {
        this._diag.debug("headers inject skipped due to CORS policy");
      }
      return;
    }
    const headers = {};
    propagation.inject(context.active(), headers);
    Object.keys(headers).forEach((key) => {
      xhr.setRequestHeader(key, String(headers[key]));
    });
  }
  /**
   * Add cors pre flight child span
   * @param span
   * @param corsPreFlightRequest
   * @private
   */
  _addChildSpan(span, corsPreFlightRequest) {
    context.with(trace.setSpan(context.active(), span), () => {
      const childSpan = this.tracer.startSpan("CORS Preflight", {
        startTime: corsPreFlightRequest[PerformanceTimingNames.FETCH_START]
      });
      const skipOldSemconvContentLengthAttrs = !(this._semconvStability & SemconvStability.OLD);
      addSpanNetworkEvents(childSpan, corsPreFlightRequest, this.getConfig().ignoreNetworkEvents, void 0, skipOldSemconvContentLengthAttrs);
      childSpan.end(corsPreFlightRequest[PerformanceTimingNames.RESPONSE_END]);
    });
  }
  /**
   * Add attributes when span is going to end
   * @param span
   * @param xhr
   * @param spanUrl
   * @private
   */
  _addFinalSpanAttributes(span, xhrMem, spanUrl) {
    if (this._semconvStability & SemconvStability.OLD) {
      if (xhrMem.status !== void 0) {
        span.setAttribute(ATTR_HTTP_STATUS_CODE, xhrMem.status);
      }
      if (xhrMem.statusText !== void 0) {
        span.setAttribute(AttributeNames.HTTP_STATUS_TEXT, xhrMem.statusText);
      }
      if (typeof spanUrl === "string") {
        const parsedUrl = parseUrl(spanUrl);
        span.setAttribute(ATTR_HTTP_HOST, parsedUrl.host);
        span.setAttribute(ATTR_HTTP_SCHEME, parsedUrl.protocol.replace(":", ""));
      }
      span.setAttribute(ATTR_HTTP_USER_AGENT, navigator.userAgent);
    }
    if (this._semconvStability & SemconvStability.STABLE) {
      if (xhrMem.status) {
        span.setAttribute(ATTR_HTTP_RESPONSE_STATUS_CODE, xhrMem.status);
      }
    }
  }
  _applyAttributesAfterXHR(span, xhr) {
    const applyCustomAttributesOnSpan = this.getConfig().applyCustomAttributesOnSpan;
    if (typeof applyCustomAttributesOnSpan === "function") {
      safeExecuteInTheMiddle(() => applyCustomAttributesOnSpan(span, xhr), (error) => {
        if (!error) {
          return;
        }
        this._diag.error("applyCustomAttributesOnSpan", error);
      }, true);
    }
  }
  /**
   * will collect information about all resources created
   * between "send" and "end" with additional waiting for main resource
   * @param xhr
   * @param spanUrl
   * @private
   */
  _addResourceObserver(xhr, spanUrl) {
    const xhrMem = this._xhrMem.get(xhr);
    if (!xhrMem || typeof PerformanceObserver !== "function" || typeof PerformanceResourceTiming !== "function") {
      return;
    }
    xhrMem.createdResources = {
      observer: new PerformanceObserver((list) => {
        const entries = list.getEntries();
        const parsedUrl = parseUrl(spanUrl);
        entries.forEach((entry) => {
          if (entry.initiatorType === "xmlhttprequest" && entry.name === parsedUrl.href) {
            if (xhrMem.createdResources) {
              xhrMem.createdResources.entries.push(entry);
            }
          }
        });
      }),
      entries: []
    };
    xhrMem.createdResources.observer.observe({
      entryTypes: ["resource"]
    });
  }
  /**
   * Clears the resource timings and all resources assigned with spans
   *     when {@link XMLHttpRequestInstrumentationConfig.clearTimingResources} is
   *     set to true (default false)
   * @private
   */
  _clearResources() {
    if (this._tasksCount === 0 && this.getConfig().clearTimingResources) {
      otperformance.clearResourceTimings();
      this._xhrMem = /* @__PURE__ */ new WeakMap();
      this._usedResources = /* @__PURE__ */ new WeakSet();
    }
  }
  /**
   * Finds appropriate resource and add network events to the span
   * @param span
   */
  _findResourceAndAddNetworkEvents(xhrMem, span, spanUrl, startTime, endTime) {
    if (!spanUrl || !startTime || !endTime || !xhrMem.createdResources) {
      return;
    }
    let resources = xhrMem.createdResources.entries;
    if (!resources || !resources.length) {
      resources = otperformance.getEntriesByType("resource");
    }
    const resource = getResource(parseUrl(spanUrl).href, startTime, endTime, resources, this._usedResources);
    if (resource.mainRequest) {
      const mainRequest = resource.mainRequest;
      this._markResourceAsUsed(mainRequest);
      const corsPreFlightRequest = resource.corsPreFlightRequest;
      if (corsPreFlightRequest) {
        this._addChildSpan(span, corsPreFlightRequest);
        this._markResourceAsUsed(corsPreFlightRequest);
      }
      const skipOldSemconvContentLengthAttrs = !(this._semconvStability & SemconvStability.OLD);
      addSpanNetworkEvents(span, mainRequest, this.getConfig().ignoreNetworkEvents, void 0, skipOldSemconvContentLengthAttrs);
    }
  }
  /**
   * Removes the previous information about span.
   * This might happened when the same xhr is used again.
   * @param xhr
   * @private
   */
  _cleanPreviousSpanInformation(xhr) {
    const xhrMem = this._xhrMem.get(xhr);
    if (xhrMem) {
      const callbackToRemoveEvents = xhrMem.callbackToRemoveEvents;
      if (callbackToRemoveEvents) {
        callbackToRemoveEvents();
      }
      this._xhrMem.delete(xhr);
    }
  }
  /**
   * Creates a new span when method "open" is called
   * @param xhr
   * @param url
   * @param method
   * @private
   */
  _createSpan(xhr, url, method) {
    if (isUrlIgnored(url, this.getConfig().ignoreUrls)) {
      this._diag.debug("ignoring span as url matches ignored url");
      return;
    }
    let name = "";
    const parsedUrl = parseUrl(url);
    const attributes = {};
    if (this._semconvStability & SemconvStability.OLD) {
      name = method.toUpperCase();
      attributes[ATTR_HTTP_METHOD] = method;
      attributes[ATTR_HTTP_URL] = parsedUrl.toString();
    }
    if (this._semconvStability & SemconvStability.STABLE) {
      const origMethod = method;
      const normMethod = normalizeHttpRequestMethod(method);
      if (!name) {
        name = normMethod;
      }
      attributes[ATTR_HTTP_REQUEST_METHOD] = normMethod;
      if (normMethod !== origMethod) {
        attributes[ATTR_HTTP_REQUEST_METHOD_ORIGINAL] = origMethod;
      }
      attributes[ATTR_URL_FULL] = parsedUrl.toString();
      attributes[ATTR_SERVER_ADDRESS] = parsedUrl.hostname;
      const serverPort = serverPortFromUrl(parsedUrl);
      if (serverPort) {
        attributes[ATTR_SERVER_PORT] = serverPort;
      }
    }
    const currentSpan = this.tracer.startSpan(name, {
      kind: SpanKind.CLIENT,
      attributes
    });
    currentSpan.addEvent(EventNames.METHOD_OPEN);
    this._cleanPreviousSpanInformation(xhr);
    this._xhrMem.set(xhr, {
      span: currentSpan,
      spanUrl: url
    });
    return currentSpan;
  }
  /**
   * Marks certain [resource]{@link PerformanceResourceTiming} when information
   * from this is used to add events to span.
   * This is done to avoid reusing the same resource again for next span
   * @param resource
   * @private
   */
  _markResourceAsUsed(resource) {
    this._usedResources.add(resource);
  }
  /**
   * Patches the method open
   * @private
   */
  _patchOpen() {
    return (original) => {
      const plugin = this;
      return function patchOpen(...args) {
        const method = args[0];
        const url = args[1];
        plugin._createSpan(this, url, method);
        return original.apply(this, args);
      };
    };
  }
  /**
   * Patches the method send
   * @private
   */
  _patchSend() {
    const plugin = this;
    function endSpanTimeout(eventName, xhrMem, performanceEndTime, endTime) {
      const callbackToRemoveEvents = xhrMem.callbackToRemoveEvents;
      if (typeof callbackToRemoveEvents === "function") {
        callbackToRemoveEvents();
      }
      const { span, spanUrl, sendStartTime } = xhrMem;
      if (span) {
        plugin._findResourceAndAddNetworkEvents(xhrMem, span, spanUrl, sendStartTime, performanceEndTime);
        span.addEvent(eventName, endTime);
        plugin._addFinalSpanAttributes(span, xhrMem, spanUrl);
        span.end(endTime);
        plugin._tasksCount--;
      }
      plugin._clearResources();
    }
    function endSpan(eventName, xhr, isError, errorType) {
      const xhrMem = plugin._xhrMem.get(xhr);
      if (!xhrMem) {
        return;
      }
      xhrMem.status = xhr.status;
      xhrMem.statusText = xhr.statusText;
      plugin._xhrMem.delete(xhr);
      if (xhrMem.span) {
        const span = xhrMem.span;
        plugin._applyAttributesAfterXHR(span, xhr);
        if (plugin._semconvStability & SemconvStability.STABLE) {
          if (isError) {
            if (errorType) {
              span.setStatus({
                code: SpanStatusCode.ERROR,
                message: errorType
              });
              span.setAttribute(ATTR_ERROR_TYPE, errorType);
            }
          } else if (xhrMem.status && xhrMem.status >= 400) {
            span.setStatus({ code: SpanStatusCode.ERROR });
            span.setAttribute(ATTR_ERROR_TYPE, String(xhrMem.status));
          }
        }
      }
      const performanceEndTime = hrTime();
      const endTime = Date.now();
      setTimeout(() => {
        endSpanTimeout(eventName, xhrMem, performanceEndTime, endTime);
      }, OBSERVER_WAIT_TIME_MS);
    }
    function onError() {
      endSpan(EventNames.EVENT_ERROR, this, true, "error");
    }
    function onAbort() {
      endSpan(EventNames.EVENT_ABORT, this, false);
    }
    function onTimeout() {
      endSpan(EventNames.EVENT_TIMEOUT, this, true, "timeout");
    }
    function onLoad() {
      if (this.status < 299) {
        endSpan(EventNames.EVENT_LOAD, this, false);
      } else {
        endSpan(EventNames.EVENT_ERROR, this, false);
      }
    }
    function unregister(xhr) {
      xhr.removeEventListener("abort", onAbort);
      xhr.removeEventListener("error", onError);
      xhr.removeEventListener("load", onLoad);
      xhr.removeEventListener("timeout", onTimeout);
      const xhrMem = plugin._xhrMem.get(xhr);
      if (xhrMem) {
        xhrMem.callbackToRemoveEvents = void 0;
      }
    }
    return (original) => {
      return function patchSend(...args) {
        const xhrMem = plugin._xhrMem.get(this);
        if (!xhrMem) {
          return original.apply(this, args);
        }
        const currentSpan = xhrMem.span;
        const spanUrl = xhrMem.spanUrl;
        if (currentSpan && spanUrl) {
          if (plugin.getConfig().measureRequestSize && args?.[0]) {
            const body = args[0];
            const bodyLength = getXHRBodyLength(body);
            if (bodyLength !== void 0) {
              if (plugin._semconvStability & SemconvStability.OLD) {
                currentSpan.setAttribute(ATTR_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED, bodyLength);
              }
              if (plugin._semconvStability & SemconvStability.STABLE) {
                currentSpan.setAttribute(ATTR_HTTP_REQUEST_BODY_SIZE, bodyLength);
              }
            }
          }
          context.with(trace.setSpan(context.active(), currentSpan), () => {
            plugin._tasksCount++;
            xhrMem.sendStartTime = hrTime();
            currentSpan.addEvent(EventNames.METHOD_SEND);
            this.addEventListener("abort", onAbort);
            this.addEventListener("error", onError);
            this.addEventListener("load", onLoad);
            this.addEventListener("timeout", onTimeout);
            xhrMem.callbackToRemoveEvents = () => {
              unregister(this);
              if (xhrMem.createdResources) {
                xhrMem.createdResources.observer.disconnect();
              }
            };
            plugin._addHeaders(this, spanUrl);
            plugin._addResourceObserver(this, spanUrl);
          });
        }
        return original.apply(this, args);
      };
    };
  }
  /**
   * implements enable function
   */
  enable() {
    this._diag.debug("applying patch to", this.moduleName, this.version);
    if (isWrapped(XMLHttpRequest.prototype.open)) {
      this._unwrap(XMLHttpRequest.prototype, "open");
      this._diag.debug("removing previous patch from method open");
    }
    if (isWrapped(XMLHttpRequest.prototype.send)) {
      this._unwrap(XMLHttpRequest.prototype, "send");
      this._diag.debug("removing previous patch from method send");
    }
    this._wrap(XMLHttpRequest.prototype, "open", this._patchOpen());
    this._wrap(XMLHttpRequest.prototype, "send", this._patchSend());
  }
  /**
   * implements disable function
   */
  disable() {
    this._diag.debug("removing patch from", this.moduleName, this.version);
    this._unwrap(XMLHttpRequest.prototype, "open");
    this._unwrap(XMLHttpRequest.prototype, "send");
    this._tasksCount = 0;
    this._xhrMem = /* @__PURE__ */ new WeakMap();
    this._usedResources = /* @__PURE__ */ new WeakSet();
  }
};
export {
  XMLHttpRequestInstrumentation
};
//# sourceMappingURL=@opentelemetry_instrumentation-xml-http-request.js.map
