import {
  PerformanceTimingNames,
  addSpanNetworkEvents,
  getResource,
  parseUrl,
  shouldPropagateTraceHeaders
} from "./chunk-SDFO7HFY.js";
import {
  InstrumentationBase,
  SemconvStability,
  isWrapped,
  safeExecuteInTheMiddle,
  semconvStabilityFromStr
} from "./chunk-EF4EXS77.js";
import {
  _globalThis,
  getStringListFromEnv,
  hrTime,
  isUrlIgnored,
  millisToHrTime
} from "./chunk-MUUYURUO.js";
import {
  ATTR_ERROR_TYPE,
  ATTR_HTTP_REQUEST_METHOD,
  ATTR_HTTP_REQUEST_METHOD_ORIGINAL,
  ATTR_HTTP_RESPONSE_STATUS_CODE,
  ATTR_SERVER_ADDRESS,
  ATTR_SERVER_PORT,
  ATTR_URL_FULL
} from "./chunk-JOJVESY7.js";
import {
  SpanKind,
  SpanStatusCode,
  context,
  diag,
  propagation,
  trace
} from "./chunk-WWXHSA53.js";
import "./chunk-CXVDPRWL.js";
import "./chunk-G3PMV62Z.js";

// node_modules/.pnpm/@opentelemetry+instrumentation-fetch@0.208.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-fetch/build/esm/enums/AttributeNames.js
var AttributeNames;
(function(AttributeNames2) {
  AttributeNames2["COMPONENT"] = "component";
  AttributeNames2["HTTP_STATUS_TEXT"] = "http.status_text";
})(AttributeNames || (AttributeNames = {}));

// node_modules/.pnpm/@opentelemetry+instrumentation-fetch@0.208.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-fetch/build/esm/semconv.js
var ATTR_HTTP_HOST = "http.host";
var ATTR_HTTP_METHOD = "http.method";
var ATTR_HTTP_REQUEST_BODY_SIZE = "http.request.body.size";
var ATTR_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED = "http.request_content_length_uncompressed";
var ATTR_HTTP_SCHEME = "http.scheme";
var ATTR_HTTP_STATUS_CODE = "http.status_code";
var ATTR_HTTP_URL = "http.url";
var ATTR_HTTP_USER_AGENT = "http.user_agent";

// node_modules/.pnpm/@opentelemetry+instrumentation-fetch@0.208.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-fetch/build/esm/utils.js
var DIAG_LOGGER = diag.createComponentLogger({
  namespace: "@opentelemetry/opentelemetry-instrumentation-fetch/utils"
});
function getFetchBodyLength(...args) {
  if (args[0] instanceof URL || typeof args[0] === "string") {
    const requestInit = args[1];
    if (!requestInit?.body) {
      return Promise.resolve();
    }
    if (requestInit.body instanceof ReadableStream) {
      const { body, length } = _getBodyNonDestructively(requestInit.body);
      requestInit.body = body;
      return length;
    } else {
      return Promise.resolve(getXHRBodyLength(requestInit.body));
    }
  } else {
    const info = args[0];
    if (!info?.body) {
      return Promise.resolve();
    }
    return info.clone().text().then((t) => getByteLength(t));
  }
}
function _getBodyNonDestructively(body) {
  if (!body.pipeThrough) {
    DIAG_LOGGER.warn("Platform has ReadableStream but not pipeThrough!");
    return {
      body,
      length: Promise.resolve(void 0)
    };
  }
  let length = 0;
  let resolveLength;
  const lengthPromise = new Promise((resolve) => {
    resolveLength = resolve;
  });
  const transform = new TransformStream({
    start() {
    },
    async transform(chunk, controller) {
      const bytearray = await chunk;
      length += bytearray.byteLength;
      controller.enqueue(chunk);
    },
    flush() {
      resolveLength(length);
    }
  });
  return {
    body: body.pipeThrough(transform),
    length: lengthPromise
  };
}
function isDocument(value) {
  return typeof Document !== "undefined" && value instanceof Document;
}
function getXHRBodyLength(body) {
  if (isDocument(body)) {
    return new XMLSerializer().serializeToString(document).length;
  }
  if (typeof body === "string") {
    return getByteLength(body);
  }
  if (body instanceof Blob) {
    return body.size;
  }
  if (body instanceof FormData) {
    return getFormDataSize(body);
  }
  if (body instanceof URLSearchParams) {
    return getByteLength(body.toString());
  }
  if (body.byteLength !== void 0) {
    return body.byteLength;
  }
  DIAG_LOGGER.warn("unknown body type");
  return void 0;
}
var TEXT_ENCODER = new TextEncoder();
function getByteLength(s) {
  return TEXT_ENCODER.encode(s).byteLength;
}
function getFormDataSize(formData) {
  let size = 0;
  for (const [key, value] of formData.entries()) {
    size += key.length;
    if (value instanceof Blob) {
      size += value.size;
    } else {
      size += value.length;
    }
  }
  return size;
}
function normalizeHttpRequestMethod(method) {
  const knownMethods2 = getKnownMethods();
  const methUpper = method.toUpperCase();
  if (methUpper in knownMethods2) {
    return methUpper;
  } else {
    return "_OTHER";
  }
}
var DEFAULT_KNOWN_METHODS = {
  CONNECT: true,
  DELETE: true,
  GET: true,
  HEAD: true,
  OPTIONS: true,
  PATCH: true,
  POST: true,
  PUT: true,
  TRACE: true
};
var knownMethods;
function getKnownMethods() {
  if (knownMethods === void 0) {
    const cfgMethods = getStringListFromEnv("OTEL_INSTRUMENTATION_HTTP_KNOWN_METHODS");
    if (cfgMethods && cfgMethods.length > 0) {
      knownMethods = {};
      cfgMethods.forEach((m) => {
        knownMethods[m] = true;
      });
    } else {
      knownMethods = DEFAULT_KNOWN_METHODS;
    }
  }
  return knownMethods;
}
var HTTP_PORT_FROM_PROTOCOL = {
  "https:": "443",
  "http:": "80"
};
function serverPortFromUrl(url) {
  const serverPort = Number(url.port || HTTP_PORT_FROM_PROTOCOL[url.protocol]);
  if (serverPort && !isNaN(serverPort)) {
    return serverPort;
  } else {
    return void 0;
  }
}

// node_modules/.pnpm/@opentelemetry+instrumentation-fetch@0.208.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-fetch/build/esm/version.js
var VERSION = "0.208.0";

// node_modules/.pnpm/@opentelemetry+instrumentation-fetch@0.208.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-fetch/build/esm/fetch.js
var OBSERVER_WAIT_TIME_MS = 300;
var isNode = typeof process === "object" && process.release?.name === "node";
var FetchInstrumentation = class extends InstrumentationBase {
  component = "fetch";
  version = VERSION;
  moduleName = this.component;
  _usedResources = /* @__PURE__ */ new WeakSet();
  _tasksCount = 0;
  _semconvStability;
  constructor(config = {}) {
    super("@opentelemetry/instrumentation-fetch", VERSION, config);
    this._semconvStability = semconvStabilityFromStr("http", config?.semconvStabilityOptIn);
  }
  init() {
  }
  /**
   * Add cors pre flight child span
   * @param span
   * @param corsPreFlightRequest
   */
  _addChildSpan(span, corsPreFlightRequest) {
    const childSpan = this.tracer.startSpan("CORS Preflight", {
      startTime: corsPreFlightRequest[PerformanceTimingNames.FETCH_START]
    }, trace.setSpan(context.active(), span));
    const skipOldSemconvContentLengthAttrs = !(this._semconvStability & SemconvStability.OLD);
    addSpanNetworkEvents(childSpan, corsPreFlightRequest, this.getConfig().ignoreNetworkEvents, void 0, skipOldSemconvContentLengthAttrs);
    childSpan.end(corsPreFlightRequest[PerformanceTimingNames.RESPONSE_END]);
  }
  /**
   * Adds more attributes to span just before ending it
   * @param span
   * @param response
   */
  _addFinalSpanAttributes(span, response) {
    const parsedUrl = parseUrl(response.url);
    if (this._semconvStability & SemconvStability.OLD) {
      span.setAttribute(ATTR_HTTP_STATUS_CODE, response.status);
      if (response.statusText != null) {
        span.setAttribute(AttributeNames.HTTP_STATUS_TEXT, response.statusText);
      }
      span.setAttribute(ATTR_HTTP_HOST, parsedUrl.host);
      span.setAttribute(ATTR_HTTP_SCHEME, parsedUrl.protocol.replace(":", ""));
      if (typeof navigator !== "undefined") {
        span.setAttribute(ATTR_HTTP_USER_AGENT, navigator.userAgent);
      }
    }
    if (this._semconvStability & SemconvStability.STABLE) {
      span.setAttribute(ATTR_HTTP_RESPONSE_STATUS_CODE, response.status);
      span.setAttribute(ATTR_SERVER_ADDRESS, parsedUrl.hostname);
      const serverPort = serverPortFromUrl(parsedUrl);
      if (serverPort) {
        span.setAttribute(ATTR_SERVER_PORT, serverPort);
      }
    }
  }
  /**
   * Add headers
   * @param options
   * @param spanUrl
   */
  _addHeaders(options, spanUrl) {
    if (!shouldPropagateTraceHeaders(spanUrl, this.getConfig().propagateTraceHeaderCorsUrls)) {
      const headers = {};
      propagation.inject(context.active(), headers);
      if (Object.keys(headers).length > 0) {
        this._diag.debug("headers inject skipped due to CORS policy");
      }
      return;
    }
    if (options instanceof Request) {
      propagation.inject(context.active(), options.headers, {
        set: (h, k, v) => h.set(k, typeof v === "string" ? v : String(v))
      });
    } else if (options.headers instanceof Headers) {
      propagation.inject(context.active(), options.headers, {
        set: (h, k, v) => h.set(k, typeof v === "string" ? v : String(v))
      });
    } else if (options.headers instanceof Map) {
      propagation.inject(context.active(), options.headers, {
        set: (h, k, v) => h.set(k, typeof v === "string" ? v : String(v))
      });
    } else {
      const headers = {};
      propagation.inject(context.active(), headers);
      options.headers = Object.assign({}, headers, options.headers || {});
    }
  }
  /**
   * Clears the resource timings and all resources assigned with spans
   *     when {@link FetchPluginConfig.clearTimingResources} is
   *     set to true (default false)
   * @private
   */
  _clearResources() {
    if (this._tasksCount === 0 && this.getConfig().clearTimingResources) {
      performance.clearResourceTimings();
      this._usedResources = /* @__PURE__ */ new WeakSet();
    }
  }
  /**
   * Creates a new span
   * @param url
   * @param options
   */
  _createSpan(url, options = {}) {
    if (isUrlIgnored(url, this.getConfig().ignoreUrls)) {
      this._diag.debug("ignoring span as url matches ignored url");
      return;
    }
    let name = "";
    const attributes = {};
    if (this._semconvStability & SemconvStability.OLD) {
      const method = (options.method || "GET").toUpperCase();
      name = `HTTP ${method}`;
      attributes[AttributeNames.COMPONENT] = this.moduleName;
      attributes[ATTR_HTTP_METHOD] = method;
      attributes[ATTR_HTTP_URL] = url;
    }
    if (this._semconvStability & SemconvStability.STABLE) {
      const origMethod = options.method;
      const normMethod = normalizeHttpRequestMethod(options.method || "GET");
      if (!name) {
        name = normMethod;
      }
      attributes[ATTR_HTTP_REQUEST_METHOD] = normMethod;
      if (normMethod !== origMethod) {
        attributes[ATTR_HTTP_REQUEST_METHOD_ORIGINAL] = origMethod;
      }
      attributes[ATTR_URL_FULL] = url;
    }
    return this.tracer.startSpan(name, {
      kind: SpanKind.CLIENT,
      attributes
    });
  }
  /**
   * Finds appropriate resource and add network events to the span
   * @param span
   * @param resourcesObserver
   * @param endTime
   */
  _findResourceAndAddNetworkEvents(span, resourcesObserver, endTime) {
    let resources = resourcesObserver.entries;
    if (!resources.length) {
      if (!performance.getEntriesByType) {
        return;
      }
      resources = performance.getEntriesByType("resource");
    }
    const resource = getResource(resourcesObserver.spanUrl, resourcesObserver.startTime, endTime, resources, this._usedResources, "fetch");
    if (resource.mainRequest) {
      const mainRequest = resource.mainRequest;
      this._markResourceAsUsed(mainRequest);
      const corsPreFlightRequest = resource.corsPreFlightRequest;
      if (corsPreFlightRequest) {
        this._addChildSpan(span, corsPreFlightRequest);
        this._markResourceAsUsed(corsPreFlightRequest);
      }
      const skipOldSemconvContentLengthAttrs = !(this._semconvStability & SemconvStability.OLD);
      addSpanNetworkEvents(span, mainRequest, this.getConfig().ignoreNetworkEvents, void 0, skipOldSemconvContentLengthAttrs);
    }
  }
  /**
   * Marks certain [resource]{@link PerformanceResourceTiming} when information
   * from this is used to add events to span.
   * This is done to avoid reusing the same resource again for next span
   * @param resource
   */
  _markResourceAsUsed(resource) {
    this._usedResources.add(resource);
  }
  /**
   * Finish span, add attributes, network events etc.
   * @param span
   * @param spanData
   * @param response
   */
  _endSpan(span, spanData, response) {
    const endTime = millisToHrTime(Date.now());
    const performanceEndTime = hrTime();
    this._addFinalSpanAttributes(span, response);
    if (this._semconvStability & SemconvStability.STABLE) {
      if (response.status >= 400) {
        span.setStatus({ code: SpanStatusCode.ERROR });
        span.setAttribute(ATTR_ERROR_TYPE, String(response.status));
      }
    }
    setTimeout(() => {
      spanData.observer?.disconnect();
      this._findResourceAndAddNetworkEvents(span, spanData, performanceEndTime);
      this._tasksCount--;
      this._clearResources();
      span.end(endTime);
    }, OBSERVER_WAIT_TIME_MS);
  }
  /**
   * Patches the constructor of fetch
   */
  _patchConstructor() {
    return (original) => {
      const plugin = this;
      return function patchConstructor(...args) {
        const self = this;
        const url = parseUrl(args[0] instanceof Request ? args[0].url : String(args[0])).href;
        const options = args[0] instanceof Request ? args[0] : args[1] || {};
        const createdSpan = plugin._createSpan(url, options);
        if (!createdSpan) {
          return original.apply(this, args);
        }
        const spanData = plugin._prepareSpanData(url);
        if (plugin.getConfig().measureRequestSize) {
          getFetchBodyLength(...args).then((bodyLength) => {
            if (!bodyLength)
              return;
            if (plugin._semconvStability & SemconvStability.OLD) {
              createdSpan.setAttribute(ATTR_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED, bodyLength);
            }
            if (plugin._semconvStability & SemconvStability.STABLE) {
              createdSpan.setAttribute(ATTR_HTTP_REQUEST_BODY_SIZE, bodyLength);
            }
          }).catch((error) => {
            plugin._diag.warn("getFetchBodyLength", error);
          });
        }
        function endSpanOnError(span, error) {
          plugin._applyAttributesAfterFetch(span, options, error);
          plugin._endSpan(span, spanData, {
            status: error.status || 0,
            statusText: error.message,
            url
          });
        }
        function endSpanOnSuccess(span, response) {
          plugin._applyAttributesAfterFetch(span, options, response);
          if (response.status >= 200 && response.status < 400) {
            plugin._endSpan(span, spanData, response);
          } else {
            plugin._endSpan(span, spanData, {
              status: response.status,
              statusText: response.statusText,
              url
            });
          }
        }
        function withCancelPropagation(body, readerClone) {
          if (!body)
            return null;
          const reader = body.getReader();
          return new ReadableStream({
            async pull(controller) {
              try {
                const { value, done } = await reader.read();
                if (done) {
                  reader.releaseLock();
                  controller.close();
                } else {
                  controller.enqueue(value);
                }
              } catch (err) {
                controller.error(err);
                reader.cancel(err).catch((_) => {
                });
                try {
                  reader.releaseLock();
                } catch {
                }
              }
            },
            cancel(reason) {
              readerClone.cancel(reason).catch((_) => {
              });
              return reader.cancel(reason);
            }
          });
        }
        function onSuccess(span, resolve, response) {
          let proxiedResponse = null;
          try {
            const resClone = response.clone();
            const body = resClone.body;
            if (body) {
              const reader = body.getReader();
              const isNullBodyStatus = (
                // 101 responses and protocol upgrading is handled internally by the browser
                response.status === 204 || response.status === 205 || response.status === 304
              );
              const wrappedBody = isNullBodyStatus ? null : withCancelPropagation(response.body, reader);
              proxiedResponse = new Response(wrappedBody, {
                status: response.status,
                statusText: response.statusText,
                headers: response.headers
              });
              const read = () => {
                reader.read().then(({ done }) => {
                  if (done) {
                    endSpanOnSuccess(span, response);
                  } else {
                    read();
                  }
                }, (error) => {
                  endSpanOnError(span, error);
                });
              };
              read();
            } else {
              endSpanOnSuccess(span, response);
            }
          } finally {
            resolve(proxiedResponse ?? response);
          }
        }
        function onError(span, reject, error) {
          try {
            endSpanOnError(span, error);
          } finally {
            reject(error);
          }
        }
        return new Promise((resolve, reject) => {
          return context.with(trace.setSpan(context.active(), createdSpan), () => {
            plugin._addHeaders(options, url);
            plugin._callRequestHook(createdSpan, options);
            plugin._tasksCount++;
            return original.apply(self, options instanceof Request ? [options] : [url, options]).then(onSuccess.bind(self, createdSpan, resolve), onError.bind(self, createdSpan, reject));
          });
        });
      };
    };
  }
  _applyAttributesAfterFetch(span, request, result) {
    const applyCustomAttributesOnSpan = this.getConfig().applyCustomAttributesOnSpan;
    if (applyCustomAttributesOnSpan) {
      safeExecuteInTheMiddle(() => applyCustomAttributesOnSpan(span, request, result), (error) => {
        if (!error) {
          return;
        }
        this._diag.error("applyCustomAttributesOnSpan", error);
      }, true);
    }
  }
  _callRequestHook(span, request) {
    const requestHook = this.getConfig().requestHook;
    if (requestHook) {
      safeExecuteInTheMiddle(() => requestHook(span, request), (error) => {
        if (!error) {
          return;
        }
        this._diag.error("requestHook", error);
      }, true);
    }
  }
  /**
   * Prepares a span data - needed later for matching appropriate network
   *     resources
   * @param spanUrl
   */
  _prepareSpanData(spanUrl) {
    const startTime = hrTime();
    const entries = [];
    if (typeof PerformanceObserver !== "function") {
      return { entries, startTime, spanUrl };
    }
    const observer = new PerformanceObserver((list) => {
      const perfObsEntries = list.getEntries();
      perfObsEntries.forEach((entry) => {
        if (entry.initiatorType === "fetch" && entry.name === spanUrl) {
          entries.push(entry);
        }
      });
    });
    observer.observe({
      entryTypes: ["resource"]
    });
    return { entries, observer, startTime, spanUrl };
  }
  /**
   * implements enable function
   */
  enable() {
    if (isNode) {
      this._diag.warn("this instrumentation is intended for web usage only, it does not instrument Node.js's fetch()");
      return;
    }
    if (isWrapped(fetch)) {
      this._unwrap(_globalThis, "fetch");
      this._diag.debug("removing previous patch for constructor");
    }
    this._wrap(_globalThis, "fetch", this._patchConstructor());
  }
  /**
   * implements unpatch function
   */
  disable() {
    if (isNode) {
      return;
    }
    this._unwrap(_globalThis, "fetch");
    this._usedResources = /* @__PURE__ */ new WeakSet();
  }
};
export {
  FetchInstrumentation
};
//# sourceMappingURL=@opentelemetry_instrumentation-fetch.js.map
