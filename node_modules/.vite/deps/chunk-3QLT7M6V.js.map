{
  "version": 3,
  "sources": ["../../.pnpm/@opentelemetry+sdk-metrics@2.2.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/src/export/AggregationTemporality.ts", "../../.pnpm/@opentelemetry+sdk-metrics@2.2.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/src/export/MetricData.ts", "../../.pnpm/@opentelemetry+sdk-metrics@2.2.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/src/utils.ts", "../../.pnpm/@opentelemetry+sdk-metrics@2.2.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/src/aggregator/types.ts", "../../.pnpm/@opentelemetry+sdk-metrics@2.2.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/src/aggregator/Drop.ts", "../../.pnpm/@opentelemetry+sdk-metrics@2.2.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/src/aggregator/Histogram.ts", "../../.pnpm/@opentelemetry+sdk-metrics@2.2.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/src/aggregator/exponential-histogram/Buckets.ts", "../../.pnpm/@opentelemetry+sdk-metrics@2.2.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/src/aggregator/exponential-histogram/mapping/ieee754.ts", "../../.pnpm/@opentelemetry+sdk-metrics@2.2.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/src/aggregator/exponential-histogram/util.ts", "../../.pnpm/@opentelemetry+sdk-metrics@2.2.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/src/aggregator/exponential-histogram/mapping/types.ts", "../../.pnpm/@opentelemetry+sdk-metrics@2.2.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/src/aggregator/exponential-histogram/mapping/ExponentMapping.ts", "../../.pnpm/@opentelemetry+sdk-metrics@2.2.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/src/aggregator/exponential-histogram/mapping/LogarithmMapping.ts", "../../.pnpm/@opentelemetry+sdk-metrics@2.2.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/src/aggregator/exponential-histogram/mapping/getMapping.ts", "../../.pnpm/@opentelemetry+sdk-metrics@2.2.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/src/aggregator/ExponentialHistogram.ts", "../../.pnpm/@opentelemetry+sdk-metrics@2.2.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/src/aggregator/LastValue.ts", "../../.pnpm/@opentelemetry+sdk-metrics@2.2.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/src/aggregator/Sum.ts", "../../.pnpm/@opentelemetry+sdk-metrics@2.2.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/src/view/Aggregation.ts", "../../.pnpm/@opentelemetry+sdk-metrics@2.2.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/src/view/AggregationOption.ts", "../../.pnpm/@opentelemetry+sdk-metrics@2.2.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/src/export/AggregationSelector.ts", "../../.pnpm/@opentelemetry+sdk-metrics@2.2.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/src/export/MetricReader.ts", "../../.pnpm/@opentelemetry+sdk-metrics@2.2.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/src/export/PeriodicExportingMetricReader.ts", "../../.pnpm/@opentelemetry+sdk-metrics@2.2.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/src/export/InMemoryMetricExporter.ts", "../../.pnpm/@opentelemetry+sdk-metrics@2.2.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/src/export/ConsoleMetricExporter.ts", "../../.pnpm/@opentelemetry+sdk-metrics@2.2.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/src/view/ViewRegistry.ts", "../../.pnpm/@opentelemetry+sdk-metrics@2.2.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/src/InstrumentDescriptor.ts", "../../.pnpm/@opentelemetry+sdk-metrics@2.2.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/src/Instruments.ts", "../../.pnpm/@opentelemetry+sdk-metrics@2.2.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/src/Meter.ts", "../../.pnpm/@opentelemetry+sdk-metrics@2.2.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/src/state/MetricStorage.ts", "../../.pnpm/@opentelemetry+sdk-metrics@2.2.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/src/state/HashMap.ts", "../../.pnpm/@opentelemetry+sdk-metrics@2.2.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/src/state/DeltaMetricProcessor.ts", "../../.pnpm/@opentelemetry+sdk-metrics@2.2.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/src/state/TemporalMetricProcessor.ts", "../../.pnpm/@opentelemetry+sdk-metrics@2.2.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/src/state/AsyncMetricStorage.ts", "../../.pnpm/@opentelemetry+sdk-metrics@2.2.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/src/view/RegistrationConflicts.ts", "../../.pnpm/@opentelemetry+sdk-metrics@2.2.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/src/state/MetricStorageRegistry.ts", "../../.pnpm/@opentelemetry+sdk-metrics@2.2.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/src/state/MultiWritableMetricStorage.ts", "../../.pnpm/@opentelemetry+sdk-metrics@2.2.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/src/ObservableResult.ts", "../../.pnpm/@opentelemetry+sdk-metrics@2.2.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/src/state/ObservableRegistry.ts", "../../.pnpm/@opentelemetry+sdk-metrics@2.2.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/src/state/SyncMetricStorage.ts", "../../.pnpm/@opentelemetry+sdk-metrics@2.2.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/src/view/AttributesProcessor.ts", "../../.pnpm/@opentelemetry+sdk-metrics@2.2.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/src/state/MeterSharedState.ts", "../../.pnpm/@opentelemetry+sdk-metrics@2.2.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/src/state/MeterProviderSharedState.ts", "../../.pnpm/@opentelemetry+sdk-metrics@2.2.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/src/state/MetricCollector.ts", "../../.pnpm/@opentelemetry+sdk-metrics@2.2.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/src/view/Predicate.ts", "../../.pnpm/@opentelemetry+sdk-metrics@2.2.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/src/view/InstrumentSelector.ts", "../../.pnpm/@opentelemetry+sdk-metrics@2.2.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/src/view/MeterSelector.ts", "../../.pnpm/@opentelemetry+sdk-metrics@2.2.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/src/view/View.ts", "../../.pnpm/@opentelemetry+sdk-metrics@2.2.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/src/MeterProvider.ts"],
  "sourcesContent": ["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * AggregationTemporality indicates the way additive quantities are expressed.\n */\nexport enum AggregationTemporality {\n  DELTA,\n  CUMULATIVE,\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { HrTime, Attributes, ValueType } from '@opentelemetry/api';\nimport { InstrumentationScope } from '@opentelemetry/core';\nimport { Resource } from '@opentelemetry/resources';\nimport { AggregationTemporality } from './AggregationTemporality';\nimport { Histogram, ExponentialHistogram } from '../aggregator/types';\n\n/**\n * Supported types of metric instruments.\n */\nexport enum InstrumentType {\n  COUNTER = 'COUNTER',\n  GAUGE = 'GAUGE',\n  HISTOGRAM = 'HISTOGRAM',\n  UP_DOWN_COUNTER = 'UP_DOWN_COUNTER',\n  OBSERVABLE_COUNTER = 'OBSERVABLE_COUNTER',\n  OBSERVABLE_GAUGE = 'OBSERVABLE_GAUGE',\n  OBSERVABLE_UP_DOWN_COUNTER = 'OBSERVABLE_UP_DOWN_COUNTER',\n}\n\nexport interface MetricDescriptor {\n  readonly name: string;\n  readonly description: string;\n  readonly unit: string;\n  readonly valueType: ValueType;\n}\n\n/**\n * Basic metric data fields.\n */\ninterface BaseMetricData {\n  readonly descriptor: MetricDescriptor;\n  readonly aggregationTemporality: AggregationTemporality;\n  /**\n   * DataPointType of the metric instrument.\n   */\n  readonly dataPointType: DataPointType;\n}\n\n/**\n * Represents a metric data aggregated by either a LastValueAggregation or\n * SumAggregation.\n */\nexport interface SumMetricData extends BaseMetricData {\n  readonly dataPointType: DataPointType.SUM;\n  readonly dataPoints: DataPoint<number>[];\n  readonly isMonotonic: boolean;\n}\n\nexport interface GaugeMetricData extends BaseMetricData {\n  readonly dataPointType: DataPointType.GAUGE;\n  readonly dataPoints: DataPoint<number>[];\n}\n\n/**\n * Represents a metric data aggregated by a HistogramAggregation.\n */\nexport interface HistogramMetricData extends BaseMetricData {\n  readonly dataPointType: DataPointType.HISTOGRAM;\n  readonly dataPoints: DataPoint<Histogram>[];\n}\n\n/**\n * Represents a metric data aggregated by a ExponentialHistogramAggregation.\n */\nexport interface ExponentialHistogramMetricData extends BaseMetricData {\n  readonly dataPointType: DataPointType.EXPONENTIAL_HISTOGRAM;\n  readonly dataPoints: DataPoint<ExponentialHistogram>[];\n}\n\n/**\n * Represents an aggregated metric data.\n */\nexport type MetricData =\n  | SumMetricData\n  | GaugeMetricData\n  | HistogramMetricData\n  | ExponentialHistogramMetricData;\n\nexport interface ScopeMetrics {\n  scope: InstrumentationScope;\n  metrics: MetricData[];\n}\n\nexport interface ResourceMetrics {\n  resource: Resource;\n  scopeMetrics: ScopeMetrics[];\n}\n\n/**\n * Represents the collection result of the metrics. If there are any\n * non-critical errors in the collection, like throwing in a single observable\n * callback, these errors are aggregated in the {@link CollectionResult.errors}\n * array and other successfully collected metrics are returned.\n */\nexport interface CollectionResult {\n  /**\n   * Collected metrics.\n   */\n  resourceMetrics: ResourceMetrics;\n  /**\n   * Arbitrary JavaScript exception values.\n   */\n  errors: unknown[];\n}\n\n/**\n * The aggregated point data type.\n */\nexport enum DataPointType {\n  /**\n   * A histogram data point contains a histogram statistics of collected\n   * values with a list of explicit bucket boundaries and statistics such\n   * as min, max, count, and sum of all collected values.\n   */\n  HISTOGRAM,\n  /**\n   * An exponential histogram data point contains a histogram statistics of\n   * collected values where bucket boundaries are automatically calculated\n   * using an exponential function, and statistics such as min, max, count,\n   * and sum of all collected values.\n   */\n  EXPONENTIAL_HISTOGRAM,\n  /**\n   * A gauge metric data point has only a single numeric value.\n   */\n  GAUGE,\n  /**\n   * A sum metric data point has a single numeric value and a\n   * monotonicity-indicator.\n   */\n  SUM,\n}\n\n/**\n * Represents an aggregated point data with start time, end time and their\n * associated attributes and points.\n */\nexport interface DataPoint<T> {\n  /**\n   * The start epoch timestamp of the DataPoint, usually the time when\n   * the metric was created when the preferred AggregationTemporality is\n   * CUMULATIVE, or last collection time otherwise.\n   */\n  readonly startTime: HrTime;\n  /**\n   * The end epoch timestamp when data were collected, usually it represents\n   * the moment when `MetricReader.collect` was called.\n   */\n  readonly endTime: HrTime;\n  /**\n   * The attributes associated with this DataPoint.\n   */\n  readonly attributes: Attributes;\n  /**\n   * The value for this DataPoint. The type of the value is indicated by the\n   * {@link DataPointType}.\n   */\n  readonly value: T;\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Attributes } from '@opentelemetry/api';\nimport { InstrumentationScope } from '@opentelemetry/core';\n\nexport type Maybe<T> = T | undefined;\n\nexport function isNotNullish<T>(item: Maybe<T>): item is T {\n  return item !== undefined && item !== null;\n}\n\n/**\n * Converting the unordered attributes into unique identifier string.\n * @param attributes user provided unordered Attributes.\n */\nexport function hashAttributes(attributes: Attributes): string {\n  let keys = Object.keys(attributes);\n  if (keys.length === 0) return '';\n\n  // Return a string that is stable on key orders.\n  keys = keys.sort();\n  return JSON.stringify(keys.map(key => [key, attributes[key]]));\n}\n\n/**\n * Converting the instrumentation scope object to a unique identifier string.\n * @param instrumentationScope\n */\nexport function instrumentationScopeId(\n  instrumentationScope: InstrumentationScope\n): string {\n  return `${instrumentationScope.name}:${instrumentationScope.version ?? ''}:${\n    instrumentationScope.schemaUrl ?? ''\n  }`;\n}\n\n/**\n * Error that is thrown on timeouts.\n */\nexport class TimeoutError extends Error {\n  constructor(message?: string) {\n    super(message);\n\n    // manually adjust prototype to retain `instanceof` functionality when targeting ES5, see:\n    // https://github.com/Microsoft/TypeScript-wiki/blob/main/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\n    Object.setPrototypeOf(this, TimeoutError.prototype);\n  }\n}\n\n/**\n * Adds a timeout to a promise and rejects if the specified timeout has elapsed. Also rejects if the specified promise\n * rejects, and resolves if the specified promise resolves.\n *\n * <p> NOTE: this operation will continue even after it throws a {@link TimeoutError}.\n *\n * @param promise promise to use with timeout.\n * @param timeout the timeout in milliseconds until the returned promise is rejected.\n */\nexport function callWithTimeout<T>(\n  promise: Promise<T>,\n  timeout: number\n): Promise<T> {\n  let timeoutHandle: ReturnType<typeof setTimeout>;\n\n  const timeoutPromise = new Promise<never>(function timeoutFunction(\n    _resolve,\n    reject\n  ) {\n    timeoutHandle = setTimeout(function timeoutHandler() {\n      reject(new TimeoutError('Operation timed out.'));\n    }, timeout);\n  });\n\n  return Promise.race([promise, timeoutPromise]).then(\n    result => {\n      clearTimeout(timeoutHandle);\n      return result;\n    },\n    reason => {\n      clearTimeout(timeoutHandle);\n      throw reason;\n    }\n  );\n}\n\nexport interface PromiseAllSettledFulfillResult<T> {\n  status: 'fulfilled';\n  value: T;\n}\n\nexport interface PromiseAllSettledRejectionResult {\n  status: 'rejected';\n  reason: unknown;\n}\n\nexport type PromiseAllSettledResult<T> =\n  | PromiseAllSettledFulfillResult<T>\n  | PromiseAllSettledRejectionResult;\n\n/**\n * Node.js v12.9 lower and browser compatible `Promise.allSettled`.\n */\nexport async function PromiseAllSettled<T>(\n  promises: Promise<T>[]\n): Promise<PromiseAllSettledResult<T>[]> {\n  return Promise.all(\n    promises.map<Promise<PromiseAllSettledResult<T>>>(async p => {\n      try {\n        const ret = await p;\n        return {\n          status: 'fulfilled',\n          value: ret,\n        };\n      } catch (e) {\n        return {\n          status: 'rejected',\n          reason: e,\n        };\n      }\n    })\n  );\n}\n\nexport function isPromiseAllSettledRejectionResult(\n  it: PromiseAllSettledResult<unknown>\n): it is PromiseAllSettledRejectionResult {\n  return it.status === 'rejected';\n}\n\n/**\n * Node.js v11.0 lower and browser compatible `Array.prototype.flatMap`.\n */\nexport function FlatMap<T, R>(arr: T[], fn: (it: T) => R[]): R[] {\n  const result: R[] = [];\n  arr.forEach(it => {\n    result.push(...fn(it));\n  });\n  return result;\n}\n\nexport function setEquals(lhs: Set<unknown>, rhs: Set<unknown>): boolean {\n  if (lhs.size !== rhs.size) {\n    return false;\n  }\n  for (const item of lhs) {\n    if (!rhs.has(item)) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Binary search the sorted array to the find upper bound for the value.\n * @param arr\n * @param value\n * @returns\n */\nexport function binarySearchUB(arr: number[], value: number): number {\n  let lo = 0;\n  let hi = arr.length - 1;\n  let ret = arr.length;\n\n  while (hi >= lo) {\n    const mid = lo + Math.trunc((hi - lo) / 2);\n    if (arr[mid] < value) {\n      lo = mid + 1;\n    } else {\n      ret = mid;\n      hi = mid - 1;\n    }\n  }\n\n  return ret;\n}\n\nexport function equalsCaseInsensitive(lhs: string, rhs: string): boolean {\n  return lhs.toLowerCase() === rhs.toLowerCase();\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { HrTime, Attributes } from '@opentelemetry/api';\nimport { AggregationTemporality } from '../export/AggregationTemporality';\nimport { MetricData } from '../export/MetricData';\nimport { Maybe } from '../utils';\nimport { InstrumentDescriptor } from '../InstrumentDescriptor';\n\n/** The kind of aggregator. */\nexport enum AggregatorKind {\n  DROP,\n  SUM,\n  LAST_VALUE,\n  HISTOGRAM,\n  EXPONENTIAL_HISTOGRAM,\n}\n\n/** DataPoint value type for SumAggregation. */\nexport type Sum = number;\n\n/** DataPoint value type for LastValueAggregation. */\nexport type LastValue = number;\n\n/** DataPoint value type for HistogramAggregation. */\nexport interface Histogram {\n  /**\n   * Buckets are implemented using two different arrays:\n   *  - boundaries: contains every finite bucket boundary, which are inclusive upper bounds\n   *  - counts: contains event counts for each bucket\n   *\n   * Note that we'll always have n+1 buckets, where n is the number of boundaries.\n   * This is because we need to count events that are higher than the upper boundary.\n   *\n   * Example: if we measure the values: [5, 30, 5, 40, 5, 15, 15, 15, 25]\n   *  with the boundaries [ 10, 20, 30 ], we will have the following state:\n   *\n   * buckets: {\n   *\tboundaries: [10, 20, 30],\n   *\tcounts: [3, 3, 2, 1],\n   * }\n   */\n  buckets: {\n    boundaries: number[];\n    counts: number[];\n  };\n  sum?: number;\n  count: number;\n  min?: number;\n  max?: number;\n}\n\n/** DataPoint value type for ExponentialHistogramAggregation. */\nexport interface ExponentialHistogram {\n  count: number;\n  sum?: number;\n  scale: number;\n  zeroCount: number;\n  positive: {\n    offset: number;\n    bucketCounts: number[];\n  };\n  negative: {\n    offset: number;\n    bucketCounts: number[];\n  };\n  min?: number;\n  max?: number;\n}\n\n/**\n * An Aggregator accumulation state.\n */\nexport interface Accumulation {\n  setStartTime(startTime: HrTime): void;\n  record(value: number): void;\n}\n\nexport type AccumulationRecord<T> = [Attributes, T];\n\n/**\n * Base interface for aggregators. Aggregators are responsible for holding\n * aggregated values and taking a snapshot of these values upon export.\n */\nexport interface Aggregator<T> {\n  /** The kind of the aggregator. */\n  kind: AggregatorKind;\n\n  /**\n   * Create a clean state of accumulation.\n   */\n  createAccumulation(startTime: HrTime): T;\n\n  /**\n   * Returns the result of the merge of the given accumulations.\n   *\n   * This should always assume that the accumulations do not overlap and merge together for a new\n   * cumulative report.\n   *\n   * @param previous the previously captured accumulation\n   * @param delta the newly captured (delta) accumulation\n   * @returns the result of the merge of the given accumulations\n   */\n  merge(previous: T, delta: T): T;\n\n  /**\n   * Returns a new DELTA aggregation by comparing two cumulative measurements.\n   *\n   * @param previous the previously captured accumulation\n   * @param current the newly captured (cumulative) accumulation\n   * @returns The resulting delta accumulation\n   */\n  diff(previous: T, current: T): T;\n\n  /**\n   * Returns the {@link MetricData} that this {@link Aggregator} will produce.\n   *\n   * @param descriptor the metric descriptor.\n   * @param aggregationTemporality the temporality of the resulting {@link MetricData}\n   * @param accumulationByAttributes the array of attributes and accumulation pairs.\n   * @param endTime the end time of the metric data.\n   * @return the {@link MetricData} that this {@link Aggregator} will produce.\n   */\n  toMetricData(\n    descriptor: InstrumentDescriptor,\n    aggregationTemporality: AggregationTemporality,\n    accumulationByAttributes: AccumulationRecord<T>[],\n    endTime: HrTime\n  ): Maybe<MetricData>;\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { HrTime } from '@opentelemetry/api';\nimport { AggregationTemporality } from '../export/AggregationTemporality';\nimport { MetricData, MetricDescriptor } from '../export/MetricData';\nimport { Maybe } from '../utils';\nimport { AggregatorKind, Aggregator, AccumulationRecord } from './types';\n\n/** Basic aggregator for None which keeps no recorded value. */\nexport class DropAggregator implements Aggregator<undefined> {\n  kind: AggregatorKind.DROP = AggregatorKind.DROP;\n\n  createAccumulation() {\n    return undefined;\n  }\n\n  merge(_previous: undefined, _delta: undefined) {\n    return undefined;\n  }\n\n  diff(_previous: undefined, _current: undefined) {\n    return undefined;\n  }\n\n  toMetricData(\n    _descriptor: MetricDescriptor,\n    _aggregationTemporality: AggregationTemporality,\n    _accumulationByAttributes: AccumulationRecord<undefined>[],\n    _endTime: HrTime\n  ): Maybe<MetricData> {\n    return undefined;\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Accumulation,\n  AccumulationRecord,\n  Aggregator,\n  AggregatorKind,\n} from './types';\nimport {\n  DataPointType,\n  HistogramMetricData,\n  InstrumentType,\n} from '../export/MetricData';\nimport { HrTime } from '@opentelemetry/api';\nimport { binarySearchUB, Maybe } from '../utils';\nimport { AggregationTemporality } from '../export/AggregationTemporality';\nimport { InstrumentDescriptor } from '../InstrumentDescriptor';\n\n/**\n * Internal value type for HistogramAggregation.\n * Differs from the exported type as undefined sum/min/max complicate arithmetic\n * performed by this aggregation, but are required to be undefined in the exported types.\n */\ninterface InternalHistogram {\n  buckets: {\n    boundaries: number[];\n    counts: number[];\n  };\n  sum: number;\n  count: number;\n  hasMinMax: boolean;\n  min: number;\n  max: number;\n}\n\nfunction createNewEmptyCheckpoint(boundaries: number[]): InternalHistogram {\n  const counts = boundaries.map(() => 0);\n  counts.push(0);\n  return {\n    buckets: {\n      boundaries,\n      counts,\n    },\n    sum: 0,\n    count: 0,\n    hasMinMax: false,\n    min: Infinity,\n    max: -Infinity,\n  };\n}\n\nexport class HistogramAccumulation implements Accumulation {\n  constructor(\n    public startTime: HrTime,\n    private readonly _boundaries: number[],\n    private _recordMinMax = true,\n    private _current: InternalHistogram = createNewEmptyCheckpoint(_boundaries)\n  ) {}\n\n  record(value: number): void {\n    // NaN does not fall into any bucket, is not zero and should not be counted,\n    // NaN is never greater than max nor less than min, therefore return as there's nothing for us to do.\n    if (Number.isNaN(value)) {\n      return;\n    }\n\n    this._current.count += 1;\n    this._current.sum += value;\n\n    if (this._recordMinMax) {\n      this._current.min = Math.min(value, this._current.min);\n      this._current.max = Math.max(value, this._current.max);\n      this._current.hasMinMax = true;\n    }\n\n    const idx = binarySearchUB(this._boundaries, value);\n    this._current.buckets.counts[idx] += 1;\n  }\n\n  setStartTime(startTime: HrTime): void {\n    this.startTime = startTime;\n  }\n\n  toPointValue(): InternalHistogram {\n    return this._current;\n  }\n}\n\n/**\n * Basic aggregator which observes events and counts them in pre-defined buckets\n * and provides the total sum and count of all observations.\n */\nexport class HistogramAggregator implements Aggregator<HistogramAccumulation> {\n  public kind: AggregatorKind.HISTOGRAM = AggregatorKind.HISTOGRAM;\n\n  /**\n   * @param _boundaries sorted upper bounds of recorded values.\n   * @param _recordMinMax If set to true, min and max will be recorded. Otherwise, min and max will not be recorded.\n   */\n  constructor(\n    private readonly _boundaries: number[],\n    private readonly _recordMinMax: boolean\n  ) {}\n\n  createAccumulation(startTime: HrTime) {\n    return new HistogramAccumulation(\n      startTime,\n      this._boundaries,\n      this._recordMinMax\n    );\n  }\n\n  /**\n   * Return the result of the merge of two histogram accumulations. As long as one Aggregator\n   * instance produces all Accumulations with constant boundaries we don't need to worry about\n   * merging accumulations with different boundaries.\n   */\n  merge(\n    previous: HistogramAccumulation,\n    delta: HistogramAccumulation\n  ): HistogramAccumulation {\n    const previousValue = previous.toPointValue();\n    const deltaValue = delta.toPointValue();\n\n    const previousCounts = previousValue.buckets.counts;\n    const deltaCounts = deltaValue.buckets.counts;\n\n    const mergedCounts = new Array(previousCounts.length);\n    for (let idx = 0; idx < previousCounts.length; idx++) {\n      mergedCounts[idx] = previousCounts[idx] + deltaCounts[idx];\n    }\n\n    let min = Infinity;\n    let max = -Infinity;\n\n    if (this._recordMinMax) {\n      if (previousValue.hasMinMax && deltaValue.hasMinMax) {\n        min = Math.min(previousValue.min, deltaValue.min);\n        max = Math.max(previousValue.max, deltaValue.max);\n      } else if (previousValue.hasMinMax) {\n        min = previousValue.min;\n        max = previousValue.max;\n      } else if (deltaValue.hasMinMax) {\n        min = deltaValue.min;\n        max = deltaValue.max;\n      }\n    }\n\n    return new HistogramAccumulation(\n      previous.startTime,\n      previousValue.buckets.boundaries,\n      this._recordMinMax,\n      {\n        buckets: {\n          boundaries: previousValue.buckets.boundaries,\n          counts: mergedCounts,\n        },\n        count: previousValue.count + deltaValue.count,\n        sum: previousValue.sum + deltaValue.sum,\n        hasMinMax:\n          this._recordMinMax &&\n          (previousValue.hasMinMax || deltaValue.hasMinMax),\n        min: min,\n        max: max,\n      }\n    );\n  }\n\n  /**\n   * Returns a new DELTA aggregation by comparing two cumulative measurements.\n   */\n  diff(\n    previous: HistogramAccumulation,\n    current: HistogramAccumulation\n  ): HistogramAccumulation {\n    const previousValue = previous.toPointValue();\n    const currentValue = current.toPointValue();\n\n    const previousCounts = previousValue.buckets.counts;\n    const currentCounts = currentValue.buckets.counts;\n\n    const diffedCounts = new Array(previousCounts.length);\n    for (let idx = 0; idx < previousCounts.length; idx++) {\n      diffedCounts[idx] = currentCounts[idx] - previousCounts[idx];\n    }\n\n    return new HistogramAccumulation(\n      current.startTime,\n      previousValue.buckets.boundaries,\n      this._recordMinMax,\n      {\n        buckets: {\n          boundaries: previousValue.buckets.boundaries,\n          counts: diffedCounts,\n        },\n        count: currentValue.count - previousValue.count,\n        sum: currentValue.sum - previousValue.sum,\n        hasMinMax: false,\n        min: Infinity,\n        max: -Infinity,\n      }\n    );\n  }\n\n  toMetricData(\n    descriptor: InstrumentDescriptor,\n    aggregationTemporality: AggregationTemporality,\n    accumulationByAttributes: AccumulationRecord<HistogramAccumulation>[],\n    endTime: HrTime\n  ): Maybe<HistogramMetricData> {\n    return {\n      descriptor,\n      aggregationTemporality,\n      dataPointType: DataPointType.HISTOGRAM,\n      dataPoints: accumulationByAttributes.map(([attributes, accumulation]) => {\n        const pointValue = accumulation.toPointValue();\n\n        // determine if instrument allows negative values.\n        const allowsNegativeValues =\n          descriptor.type === InstrumentType.GAUGE ||\n          descriptor.type === InstrumentType.UP_DOWN_COUNTER ||\n          descriptor.type === InstrumentType.OBSERVABLE_GAUGE ||\n          descriptor.type === InstrumentType.OBSERVABLE_UP_DOWN_COUNTER;\n\n        return {\n          attributes,\n          startTime: accumulation.startTime,\n          endTime,\n          value: {\n            min: pointValue.hasMinMax ? pointValue.min : undefined,\n            max: pointValue.hasMinMax ? pointValue.max : undefined,\n            sum: !allowsNegativeValues ? pointValue.sum : undefined,\n            buckets: pointValue.buckets,\n            count: pointValue.count,\n          },\n        };\n      }),\n    };\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport class Buckets {\n  /**\n   * The term index refers to the number of the exponential histogram bucket\n   * used to determine its boundaries. The lower boundary of a bucket is\n   * determined by base ** index and the upper boundary of a bucket is\n   * determined by base ** (index + 1). index values are signed to account\n   * for values less than or equal to 1.\n   *\n   * indexBase is the index of the 0th position in the\n   * backing array, i.e., backing[0] is the count\n   * in the bucket with index `indexBase`.\n   *\n   * indexStart is the smallest index value represented\n   * in the backing array.\n   *\n   * indexEnd is the largest index value represented in\n   * the backing array.\n   */\n  constructor(\n    public backing = new BucketsBacking(),\n    public indexBase = 0,\n    public indexStart = 0,\n    public indexEnd = 0\n  ) {}\n\n  /**\n   * Offset is the bucket index of the smallest entry in the counts array\n   * @returns {number}\n   */\n  get offset(): number {\n    return this.indexStart;\n  }\n\n  /**\n   * Buckets is a view into the backing array.\n   * @returns {number}\n   */\n  get length(): number {\n    if (this.backing.length === 0) {\n      return 0;\n    }\n\n    if (this.indexEnd === this.indexStart && this.at(0) === 0) {\n      return 0;\n    }\n\n    return this.indexEnd - this.indexStart + 1;\n  }\n\n  /**\n   * An array of counts, where count[i] carries the count\n   * of the bucket at index (offset+i).  count[i] is the count of\n   * values greater than base^(offset+i) and less than or equal to\n   * base^(offset+i+1).\n   * @returns {number} The logical counts based on the backing array\n   */\n  counts(): number[] {\n    return Array.from({ length: this.length }, (_, i) => this.at(i));\n  }\n\n  /**\n   * At returns the count of the bucket at a position in the logical\n   * array of counts.\n   * @param position\n   * @returns {number}\n   */\n  at(position: number): number {\n    const bias = this.indexBase - this.indexStart;\n    if (position < bias) {\n      position += this.backing.length;\n    }\n\n    position -= bias;\n    return this.backing.countAt(position);\n  }\n\n  /**\n   * incrementBucket increments the backing array index by `increment`\n   * @param bucketIndex\n   * @param increment\n   */\n  incrementBucket(bucketIndex: number, increment: number) {\n    this.backing.increment(bucketIndex, increment);\n  }\n\n  /**\n   * decrementBucket decrements the backing array index by `decrement`\n   * if decrement is greater than the current value, it's set to 0.\n   * @param bucketIndex\n   * @param decrement\n   */\n  decrementBucket(bucketIndex: number, decrement: number) {\n    this.backing.decrement(bucketIndex, decrement);\n  }\n\n  /**\n   * trim removes leading and / or trailing zero buckets (which can occur\n   * after diffing two histos) and rotates the backing array so that the\n   * smallest non-zero index is in the 0th position of the backing array\n   */\n  trim() {\n    for (let i = 0; i < this.length; i++) {\n      if (this.at(i) !== 0) {\n        this.indexStart += i;\n        break;\n      } else if (i === this.length - 1) {\n        //the entire array is zeroed out\n        this.indexStart = this.indexEnd = this.indexBase = 0;\n        return;\n      }\n    }\n\n    for (let i = this.length - 1; i >= 0; i--) {\n      if (this.at(i) !== 0) {\n        this.indexEnd -= this.length - i - 1;\n        break;\n      }\n    }\n\n    this._rotate();\n  }\n\n  /**\n   * downscale first rotates, then collapses 2**`by`-to-1 buckets.\n   * @param by\n   */\n  downscale(by: number) {\n    this._rotate();\n\n    const size = 1 + this.indexEnd - this.indexStart;\n    const each = 1 << by;\n    let inpos = 0;\n    let outpos = 0;\n\n    for (let pos = this.indexStart; pos <= this.indexEnd; ) {\n      let mod = pos % each;\n      if (mod < 0) {\n        mod += each;\n      }\n      for (let i = mod; i < each && inpos < size; i++) {\n        this._relocateBucket(outpos, inpos);\n        inpos++;\n        pos++;\n      }\n      outpos++;\n    }\n\n    this.indexStart >>= by;\n    this.indexEnd >>= by;\n    this.indexBase = this.indexStart;\n  }\n\n  /**\n   * Clone returns a deep copy of Buckets\n   * @returns {Buckets}\n   */\n  clone(): Buckets {\n    return new Buckets(\n      this.backing.clone(),\n      this.indexBase,\n      this.indexStart,\n      this.indexEnd\n    );\n  }\n\n  /**\n   * _rotate shifts the backing array contents so that indexStart ==\n   * indexBase to simplify the downscale logic.\n   */\n  private _rotate() {\n    const bias = this.indexBase - this.indexStart;\n\n    if (bias === 0) {\n      return;\n    } else if (bias > 0) {\n      this.backing.reverse(0, this.backing.length);\n      this.backing.reverse(0, bias);\n      this.backing.reverse(bias, this.backing.length);\n    } else {\n      // negative bias, this can happen when diffing two histograms\n      this.backing.reverse(0, this.backing.length);\n      this.backing.reverse(0, this.backing.length + bias);\n    }\n    this.indexBase = this.indexStart;\n  }\n\n  /**\n   * _relocateBucket adds the count in counts[src] to counts[dest] and\n   * resets count[src] to zero.\n   */\n  private _relocateBucket(dest: number, src: number) {\n    if (dest === src) {\n      return;\n    }\n    this.incrementBucket(dest, this.backing.emptyBucket(src));\n  }\n}\n\n/**\n * BucketsBacking holds the raw buckets and some utility methods to\n * manage them.\n */\nclass BucketsBacking {\n  constructor(private _counts = [0]) {}\n\n  /**\n   * length returns the physical size of the backing array, which\n   * is >= buckets.length()\n   */\n  get length(): number {\n    return this._counts.length;\n  }\n\n  /**\n   * countAt returns the count in a specific bucket\n   */\n  countAt(pos: number): number {\n    return this._counts[pos];\n  }\n\n  /**\n   * growTo grows a backing array and copies old entries\n   * into their correct new positions.\n   */\n  growTo(newSize: number, oldPositiveLimit: number, newPositiveLimit: number) {\n    const tmp = new Array<number>(newSize).fill(0);\n    tmp.splice(\n      newPositiveLimit,\n      this._counts.length - oldPositiveLimit,\n      ...this._counts.slice(oldPositiveLimit)\n    );\n    tmp.splice(0, oldPositiveLimit, ...this._counts.slice(0, oldPositiveLimit));\n    this._counts = tmp;\n  }\n\n  /**\n   * reverse the items in the backing array in the range [from, limit).\n   */\n  reverse(from: number, limit: number) {\n    const num = Math.floor((from + limit) / 2) - from;\n    for (let i = 0; i < num; i++) {\n      const tmp = this._counts[from + i];\n      this._counts[from + i] = this._counts[limit - i - 1];\n      this._counts[limit - i - 1] = tmp;\n    }\n  }\n\n  /**\n   * emptyBucket empties the count from a bucket, for\n   * moving into another.\n   */\n  emptyBucket(src: number): number {\n    const tmp = this._counts[src];\n    this._counts[src] = 0;\n    return tmp;\n  }\n\n  /**\n   * increments a bucket by `increment`\n   */\n  increment(bucketIndex: number, increment: number) {\n    this._counts[bucketIndex] += increment;\n  }\n\n  /**\n   * decrements a bucket by `decrement`\n   */\n  decrement(bucketIndex: number, decrement: number) {\n    if (this._counts[bucketIndex] >= decrement) {\n      this._counts[bucketIndex] -= decrement;\n    } else {\n      // this should not happen, but we're being defensive against\n      // negative counts.\n      this._counts[bucketIndex] = 0;\n    }\n  }\n\n  /**\n   * clone returns a deep copy of BucketsBacking\n   */\n  clone(): BucketsBacking {\n    return new BucketsBacking([...this._counts]);\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * The functions and constants in this file allow us to interact\n * with the internal representation of an IEEE 64-bit floating point\n * number. We need to work with all 64-bits, thus, care needs to be\n * taken when working with Javascript's bitwise operators (<<, >>, &,\n * |, etc) as they truncate operands to 32-bits. In order to work around\n * this we work with the 64-bits as two 32-bit halves, perform bitwise\n * operations on them independently, and combine the results (if needed).\n */\n\nexport const SIGNIFICAND_WIDTH = 52;\n\n/**\n * EXPONENT_MASK is set to 1 for the hi 32-bits of an IEEE 754\n * floating point exponent: 0x7ff00000.\n */\nconst EXPONENT_MASK = 0x7ff00000;\n\n/**\n * SIGNIFICAND_MASK is the mask for the significand portion of the hi 32-bits\n * of an IEEE 754 double-precision floating-point value: 0xfffff\n */\nconst SIGNIFICAND_MASK = 0xfffff;\n\n/**\n * EXPONENT_BIAS is the exponent bias specified for encoding\n * the IEEE 754 double-precision floating point exponent: 1023\n */\nconst EXPONENT_BIAS = 1023;\n\n/**\n * MIN_NORMAL_EXPONENT is the minimum exponent of a normalized\n * floating point: -1022.\n */\nexport const MIN_NORMAL_EXPONENT = -EXPONENT_BIAS + 1;\n\n/**\n * MAX_NORMAL_EXPONENT is the maximum exponent of a normalized\n * floating point: 1023.\n */\nexport const MAX_NORMAL_EXPONENT = EXPONENT_BIAS;\n\n/**\n * MIN_VALUE is the smallest normal number\n */\nexport const MIN_VALUE = Math.pow(2, -1022);\n\n/**\n * getNormalBase2 extracts the normalized base-2 fractional exponent.\n * This returns k for the equation f x 2**k where f is\n * in the range [1, 2).  Note that this function is not called for\n * subnormal numbers.\n * @param {number} value - the value to determine normalized base-2 fractional\n *    exponent for\n * @returns {number} the normalized base-2 exponent\n */\nexport function getNormalBase2(value: number): number {\n  const dv = new DataView(new ArrayBuffer(8));\n  dv.setFloat64(0, value);\n  // access the raw 64-bit float as 32-bit uints\n  const hiBits = dv.getUint32(0);\n  const expBits = (hiBits & EXPONENT_MASK) >> 20;\n  return expBits - EXPONENT_BIAS;\n}\n\n/**\n * GetSignificand returns the 52 bit (unsigned) significand as a signed value.\n * @param {number} value - the floating point number to extract the significand from\n * @returns {number} The 52-bit significand\n */\nexport function getSignificand(value: number): number {\n  const dv = new DataView(new ArrayBuffer(8));\n  dv.setFloat64(0, value);\n  // access the raw 64-bit float as two 32-bit uints\n  const hiBits = dv.getUint32(0);\n  const loBits = dv.getUint32(4);\n  // extract the significand bits from the hi bits and left shift 32 places note:\n  // we can't use the native << operator as it will truncate the result to 32-bits\n  const significandHiBits = (hiBits & SIGNIFICAND_MASK) * Math.pow(2, 32);\n  // combine the hi and lo bits and return\n  return significandHiBits + loBits;\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Note: other languages provide this as a built in function. This is\n * a naive, but functionally correct implementation. This is used sparingly,\n * when creating a new mapping in a running application.\n *\n * ldexp returns frac × 2**exp. With the following special cases:\n *   ldexp(±0, exp) = ±0\n *   ldexp(±Inf, exp) = ±Inf\n *   ldexp(NaN, exp) = NaN\n * @param frac\n * @param exp\n * @returns {number}\n */\nexport function ldexp(frac: number, exp: number): number {\n  if (\n    frac === 0 ||\n    frac === Number.POSITIVE_INFINITY ||\n    frac === Number.NEGATIVE_INFINITY ||\n    Number.isNaN(frac)\n  ) {\n    return frac;\n  }\n  return frac * Math.pow(2, exp);\n}\n\n/**\n * Computes the next power of two that is greater than or equal to v.\n * This implementation more efficient than, but functionally equivalent\n * to Math.pow(2, Math.ceil(Math.log(x)/Math.log(2))).\n * @param v\n * @returns {number}\n */\nexport function nextGreaterSquare(v: number): number {\n  // The following expression computes the least power-of-two\n  // that is >= v.  There are a number of tricky ways to\n  // do this, see https://stackoverflow.com/questions/466204/rounding-up-to-next-power-of-2\n  v--;\n  v |= v >> 1;\n  v |= v >> 2;\n  v |= v >> 4;\n  v |= v >> 8;\n  v |= v >> 16;\n  v++;\n  return v;\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport class MappingError extends Error {}\n\n/**\n * The mapping interface is used by the exponential histogram to determine\n * where to bucket values. The interface is implemented by ExponentMapping,\n * used for scales [-10, 0] and LogarithmMapping, used for scales [1, 20].\n */\nexport interface Mapping {\n  mapToIndex(value: number): number;\n  lowerBoundary(index: number): number;\n  get scale(): number;\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as ieee754 from './ieee754';\nimport * as util from '../util';\nimport { Mapping, MappingError } from './types';\n\n/**\n * ExponentMapping implements exponential mapping functions for\n * scales <=0. For scales > 0 LogarithmMapping should be used.\n */\nexport class ExponentMapping implements Mapping {\n  private readonly _shift: number;\n\n  constructor(scale: number) {\n    this._shift = -scale;\n  }\n\n  /**\n   * Maps positive floating point values to indexes corresponding to scale\n   * @param value\n   * @returns {number} index for provided value at the current scale\n   */\n  mapToIndex(value: number): number {\n    if (value < ieee754.MIN_VALUE) {\n      return this._minNormalLowerBoundaryIndex();\n    }\n\n    const exp = ieee754.getNormalBase2(value);\n\n    // In case the value is an exact power of two, compute a\n    // correction of -1. Note, we are using a custom _rightShift\n    // to accommodate a 52-bit argument, which the native bitwise\n    // operators do not support\n    const correction = this._rightShift(\n      ieee754.getSignificand(value) - 1,\n      ieee754.SIGNIFICAND_WIDTH\n    );\n\n    return (exp + correction) >> this._shift;\n  }\n\n  /**\n   * Returns the lower bucket boundary for the given index for scale\n   *\n   * @param index\n   * @returns {number}\n   */\n  lowerBoundary(index: number): number {\n    const minIndex = this._minNormalLowerBoundaryIndex();\n    if (index < minIndex) {\n      throw new MappingError(\n        `underflow: ${index} is < minimum lower boundary: ${minIndex}`\n      );\n    }\n    const maxIndex = this._maxNormalLowerBoundaryIndex();\n    if (index > maxIndex) {\n      throw new MappingError(\n        `overflow: ${index} is > maximum lower boundary: ${maxIndex}`\n      );\n    }\n\n    return util.ldexp(1, index << this._shift);\n  }\n\n  /**\n   * The scale used by this mapping\n   * @returns {number}\n   */\n  get scale(): number {\n    if (this._shift === 0) {\n      return 0;\n    }\n    return -this._shift;\n  }\n\n  private _minNormalLowerBoundaryIndex(): number {\n    let index = ieee754.MIN_NORMAL_EXPONENT >> this._shift;\n    if (this._shift < 2) {\n      index--;\n    }\n\n    return index;\n  }\n\n  private _maxNormalLowerBoundaryIndex(): number {\n    return ieee754.MAX_NORMAL_EXPONENT >> this._shift;\n  }\n\n  private _rightShift(value: number, shift: number): number {\n    return Math.floor(value * Math.pow(2, -shift));\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as ieee754 from './ieee754';\nimport * as util from '../util';\nimport { Mapping, MappingError } from './types';\n\n/**\n * LogarithmMapping implements exponential mapping functions for scale > 0.\n * For scales <= 0 the exponent mapping should be used.\n */\nexport class LogarithmMapping implements Mapping {\n  private readonly _scale: number;\n  private readonly _scaleFactor: number;\n  private readonly _inverseFactor: number;\n\n  constructor(scale: number) {\n    this._scale = scale;\n    this._scaleFactor = util.ldexp(Math.LOG2E, scale);\n    this._inverseFactor = util.ldexp(Math.LN2, -scale);\n  }\n\n  /**\n   * Maps positive floating point values to indexes corresponding to scale\n   * @param value\n   * @returns {number} index for provided value at the current scale\n   */\n  mapToIndex(value: number): number {\n    if (value <= ieee754.MIN_VALUE) {\n      return this._minNormalLowerBoundaryIndex() - 1;\n    }\n\n    // exact power of two special case\n    if (ieee754.getSignificand(value) === 0) {\n      const exp = ieee754.getNormalBase2(value);\n      return (exp << this._scale) - 1;\n    }\n\n    // non-power of two cases. use Math.floor to round the scaled logarithm\n    const index = Math.floor(Math.log(value) * this._scaleFactor);\n    const maxIndex = this._maxNormalLowerBoundaryIndex();\n    if (index >= maxIndex) {\n      return maxIndex;\n    }\n\n    return index;\n  }\n\n  /**\n   * Returns the lower bucket boundary for the given index for scale\n   *\n   * @param index\n   * @returns {number}\n   */\n  lowerBoundary(index: number): number {\n    const maxIndex = this._maxNormalLowerBoundaryIndex();\n    if (index >= maxIndex) {\n      if (index === maxIndex) {\n        return 2 * Math.exp((index - (1 << this._scale)) / this._scaleFactor);\n      }\n      throw new MappingError(\n        `overflow: ${index} is > maximum lower boundary: ${maxIndex}`\n      );\n    }\n\n    const minIndex = this._minNormalLowerBoundaryIndex();\n    if (index <= minIndex) {\n      if (index === minIndex) {\n        return ieee754.MIN_VALUE;\n      } else if (index === minIndex - 1) {\n        return Math.exp((index + (1 << this._scale)) / this._scaleFactor) / 2;\n      }\n      throw new MappingError(\n        `overflow: ${index} is < minimum lower boundary: ${minIndex}`\n      );\n    }\n\n    return Math.exp(index * this._inverseFactor);\n  }\n\n  /**\n   * The scale used by this mapping\n   * @returns {number}\n   */\n  get scale(): number {\n    return this._scale;\n  }\n\n  private _minNormalLowerBoundaryIndex(): number {\n    return ieee754.MIN_NORMAL_EXPONENT << this._scale;\n  }\n\n  private _maxNormalLowerBoundaryIndex(): number {\n    return ((ieee754.MAX_NORMAL_EXPONENT + 1) << this._scale) - 1;\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { ExponentMapping } from './ExponentMapping';\nimport { LogarithmMapping } from './LogarithmMapping';\nimport { MappingError, Mapping } from './types';\n\nconst MIN_SCALE = -10;\nconst MAX_SCALE = 20;\nconst PREBUILT_MAPPINGS = Array.from({ length: 31 }, (_, i) => {\n  if (i > 10) {\n    return new LogarithmMapping(i - 10);\n  }\n  return new ExponentMapping(i - 10);\n});\n\n/**\n * getMapping returns an appropriate mapping for the given scale. For scales -10\n * to 0 the underlying type will be ExponentMapping. For scales 1 to 20 the\n * underlying type will be LogarithmMapping.\n * @param scale a number in the range [-10, 20]\n * @returns {Mapping}\n */\nexport function getMapping(scale: number): Mapping {\n  if (scale > MAX_SCALE || scale < MIN_SCALE) {\n    throw new MappingError(\n      `expected scale >= ${MIN_SCALE} && <= ${MAX_SCALE}, got: ${scale}`\n    );\n  }\n  // mappings are offset by 10. scale -10 is at position 0 and scale 20 is at 30\n  return PREBUILT_MAPPINGS[scale + 10];\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Accumulation,\n  AccumulationRecord,\n  Aggregator,\n  AggregatorKind,\n  ExponentialHistogram,\n} from './types';\nimport {\n  DataPointType,\n  ExponentialHistogramMetricData,\n  InstrumentType,\n} from '../export/MetricData';\nimport { diag, HrTime } from '@opentelemetry/api';\nimport { Maybe } from '../utils';\nimport { AggregationTemporality } from '../export/AggregationTemporality';\nimport { InstrumentDescriptor } from '../InstrumentDescriptor';\nimport { Buckets } from './exponential-histogram/Buckets';\nimport { getMapping } from './exponential-histogram/mapping/getMapping';\nimport { Mapping } from './exponential-histogram/mapping/types';\nimport { nextGreaterSquare } from './exponential-histogram/util';\n\n/**\n * Internal value type for ExponentialHistogramAggregation.\n * Differs from the exported type as undefined sum/min/max complicate arithmetic\n * performed by this aggregation, but are required to be undefined in the exported types.\n */\ninterface InternalHistogram extends ExponentialHistogram {\n  hasMinMax: boolean;\n  min: number;\n  max: number;\n  sum: number;\n}\n\n// HighLow is a utility class used for computing a common scale for\n// two exponential histogram accumulations\nclass HighLow {\n  static combine(h1: HighLow, h2: HighLow): HighLow {\n    return new HighLow(Math.min(h1.low, h2.low), Math.max(h1.high, h2.high));\n  }\n  constructor(\n    public low: number,\n    public high: number\n  ) {}\n}\n\nconst MAX_SCALE = 20;\nconst DEFAULT_MAX_SIZE = 160;\nconst MIN_MAX_SIZE = 2;\n\nexport class ExponentialHistogramAccumulation implements Accumulation {\n  constructor(\n    public startTime: HrTime,\n    private _maxSize = DEFAULT_MAX_SIZE,\n    private _recordMinMax = true,\n    private _sum = 0,\n    private _count = 0,\n    private _zeroCount = 0,\n    private _min = Number.POSITIVE_INFINITY,\n    private _max = Number.NEGATIVE_INFINITY,\n    private _positive = new Buckets(),\n    private _negative = new Buckets(),\n    private _mapping: Mapping = getMapping(MAX_SCALE)\n  ) {\n    if (this._maxSize < MIN_MAX_SIZE) {\n      diag.warn(`Exponential Histogram Max Size set to ${this._maxSize}, \\\n                changing to the minimum size of: ${MIN_MAX_SIZE}`);\n      this._maxSize = MIN_MAX_SIZE;\n    }\n  }\n\n  /**\n   * record updates a histogram with a single count\n   * @param {Number} value\n   */\n  record(value: number) {\n    this.updateByIncrement(value, 1);\n  }\n\n  /**\n   * Sets the start time for this accumulation\n   * @param {HrTime} startTime\n   */\n  setStartTime(startTime: HrTime): void {\n    this.startTime = startTime;\n  }\n\n  /**\n   * Returns the datapoint representation of this accumulation\n   * @param {HrTime} startTime\n   */\n  toPointValue(): InternalHistogram {\n    return {\n      hasMinMax: this._recordMinMax,\n      min: this.min,\n      max: this.max,\n      sum: this.sum,\n      positive: {\n        offset: this.positive.offset,\n        bucketCounts: this.positive.counts(),\n      },\n      negative: {\n        offset: this.negative.offset,\n        bucketCounts: this.negative.counts(),\n      },\n      count: this.count,\n      scale: this.scale,\n      zeroCount: this.zeroCount,\n    };\n  }\n\n  /**\n   * @returns {Number} The sum of values recorded by this accumulation\n   */\n  get sum(): number {\n    return this._sum;\n  }\n\n  /**\n   * @returns {Number} The minimum value recorded by this accumulation\n   */\n  get min(): number {\n    return this._min;\n  }\n\n  /**\n   * @returns {Number} The maximum value recorded by this accumulation\n   */\n  get max(): number {\n    return this._max;\n  }\n\n  /**\n   * @returns {Number} The count of values recorded by this accumulation\n   */\n  get count(): number {\n    return this._count;\n  }\n\n  /**\n   * @returns {Number} The number of 0 values recorded by this accumulation\n   */\n  get zeroCount(): number {\n    return this._zeroCount;\n  }\n\n  /**\n   * @returns {Number} The scale used by this accumulation\n   */\n  get scale(): number {\n    if (this._count === this._zeroCount) {\n      // all zeros! scale doesn't matter, use zero\n      return 0;\n    }\n    return this._mapping.scale;\n  }\n\n  /**\n   * positive holds the positive values\n   * @returns {Buckets}\n   */\n  get positive(): Buckets {\n    return this._positive;\n  }\n\n  /**\n   * negative holds the negative values by their absolute value\n   * @returns {Buckets}\n   */\n  get negative(): Buckets {\n    return this._negative;\n  }\n\n  /**\n   * updateByIncr supports updating a histogram with a non-negative\n   * increment.\n   * @param value\n   * @param increment\n   */\n  updateByIncrement(value: number, increment: number) {\n    // NaN does not fall into any bucket, is not zero and should not be counted,\n    // NaN is never greater than max nor less than min, therefore return as there's nothing for us to do.\n    if (Number.isNaN(value)) {\n      return;\n    }\n\n    if (value > this._max) {\n      this._max = value;\n    }\n    if (value < this._min) {\n      this._min = value;\n    }\n\n    this._count += increment;\n\n    if (value === 0) {\n      this._zeroCount += increment;\n      return;\n    }\n\n    this._sum += value * increment;\n\n    if (value > 0) {\n      this._updateBuckets(this._positive, value, increment);\n    } else {\n      this._updateBuckets(this._negative, -value, increment);\n    }\n  }\n\n  /**\n   * merge combines data from previous value into self\n   * @param {ExponentialHistogramAccumulation} previous\n   */\n  merge(previous: ExponentialHistogramAccumulation) {\n    if (this._count === 0) {\n      this._min = previous.min;\n      this._max = previous.max;\n    } else if (previous.count !== 0) {\n      if (previous.min < this.min) {\n        this._min = previous.min;\n      }\n      if (previous.max > this.max) {\n        this._max = previous.max;\n      }\n    }\n\n    this.startTime = previous.startTime;\n    this._sum += previous.sum;\n    this._count += previous.count;\n    this._zeroCount += previous.zeroCount;\n\n    const minScale = this._minScale(previous);\n\n    this._downscale(this.scale - minScale);\n\n    this._mergeBuckets(this.positive, previous, previous.positive, minScale);\n    this._mergeBuckets(this.negative, previous, previous.negative, minScale);\n  }\n\n  /**\n   * diff subtracts other from self\n   * @param {ExponentialHistogramAccumulation} other\n   */\n  diff(other: ExponentialHistogramAccumulation) {\n    this._min = Infinity;\n    this._max = -Infinity;\n    this._sum -= other.sum;\n    this._count -= other.count;\n    this._zeroCount -= other.zeroCount;\n\n    const minScale = this._minScale(other);\n\n    this._downscale(this.scale - minScale);\n\n    this._diffBuckets(this.positive, other, other.positive, minScale);\n    this._diffBuckets(this.negative, other, other.negative, minScale);\n  }\n\n  /**\n   * clone returns a deep copy of self\n   * @returns {ExponentialHistogramAccumulation}\n   */\n  clone(): ExponentialHistogramAccumulation {\n    return new ExponentialHistogramAccumulation(\n      this.startTime,\n      this._maxSize,\n      this._recordMinMax,\n      this._sum,\n      this._count,\n      this._zeroCount,\n      this._min,\n      this._max,\n      this.positive.clone(),\n      this.negative.clone(),\n      this._mapping\n    );\n  }\n\n  /**\n   * _updateBuckets maps the incoming value to a bucket index for the current\n   * scale. If the bucket index is outside of the range of the backing array,\n   * it will rescale the backing array and update the mapping for the new scale.\n   */\n  private _updateBuckets(buckets: Buckets, value: number, increment: number) {\n    let index = this._mapping.mapToIndex(value);\n\n    // rescale the mapping if needed\n    let rescalingNeeded = false;\n    let high = 0;\n    let low = 0;\n\n    if (buckets.length === 0) {\n      buckets.indexStart = index;\n      buckets.indexEnd = buckets.indexStart;\n      buckets.indexBase = buckets.indexStart;\n    } else if (\n      index < buckets.indexStart &&\n      buckets.indexEnd - index >= this._maxSize\n    ) {\n      rescalingNeeded = true;\n      low = index;\n      high = buckets.indexEnd;\n    } else if (\n      index > buckets.indexEnd &&\n      index - buckets.indexStart >= this._maxSize\n    ) {\n      rescalingNeeded = true;\n      low = buckets.indexStart;\n      high = index;\n    }\n\n    // rescale and compute index at new scale\n    if (rescalingNeeded) {\n      const change = this._changeScale(high, low);\n      this._downscale(change);\n      index = this._mapping.mapToIndex(value);\n    }\n\n    this._incrementIndexBy(buckets, index, increment);\n  }\n\n  /**\n   * _incrementIndexBy increments the count of the bucket specified by `index`.\n   * If the index is outside of the range [buckets.indexStart, buckets.indexEnd]\n   * the boundaries of the backing array will be adjusted and more buckets will\n   * be added if needed.\n   */\n  private _incrementIndexBy(\n    buckets: Buckets,\n    index: number,\n    increment: number\n  ) {\n    if (increment === 0) {\n      // nothing to do for a zero increment, can happen during a merge operation\n      return;\n    }\n\n    if (buckets.length === 0) {\n      buckets.indexStart = buckets.indexEnd = buckets.indexBase = index;\n    }\n\n    if (index < buckets.indexStart) {\n      const span = buckets.indexEnd - index;\n      if (span >= buckets.backing.length) {\n        this._grow(buckets, span + 1);\n      }\n      buckets.indexStart = index;\n    } else if (index > buckets.indexEnd) {\n      const span = index - buckets.indexStart;\n      if (span >= buckets.backing.length) {\n        this._grow(buckets, span + 1);\n      }\n      buckets.indexEnd = index;\n    }\n\n    let bucketIndex = index - buckets.indexBase;\n    if (bucketIndex < 0) {\n      bucketIndex += buckets.backing.length;\n    }\n    buckets.incrementBucket(bucketIndex, increment);\n  }\n\n  /**\n   * grow resizes the backing array by doubling in size up to maxSize.\n   * This extends the array with a bunch of zeros and copies the\n   * existing counts to the same position.\n   */\n  private _grow(buckets: Buckets, needed: number) {\n    const size = buckets.backing.length;\n    const bias = buckets.indexBase - buckets.indexStart;\n    const oldPositiveLimit = size - bias;\n    let newSize = nextGreaterSquare(needed);\n    if (newSize > this._maxSize) {\n      newSize = this._maxSize;\n    }\n    const newPositiveLimit = newSize - bias;\n    buckets.backing.growTo(newSize, oldPositiveLimit, newPositiveLimit);\n  }\n\n  /**\n   * _changeScale computes how much downscaling is needed by shifting the\n   * high and low values until they are separated by no more than size.\n   */\n  private _changeScale(high: number, low: number): number {\n    let change = 0;\n    while (high - low >= this._maxSize) {\n      high >>= 1;\n      low >>= 1;\n      change++;\n    }\n    return change;\n  }\n\n  /**\n   * _downscale subtracts `change` from the current mapping scale.\n   */\n  private _downscale(change: number) {\n    if (change === 0) {\n      return;\n    }\n    if (change < 0) {\n      // Note: this should be impossible. If we get here it's because\n      // there is a bug in the implementation.\n      throw new Error(`impossible change of scale: ${this.scale}`);\n    }\n    const newScale = this._mapping.scale - change;\n\n    this._positive.downscale(change);\n    this._negative.downscale(change);\n\n    this._mapping = getMapping(newScale);\n  }\n\n  /**\n   * _minScale is used by diff and merge to compute an ideal combined scale\n   */\n  private _minScale(other: ExponentialHistogramAccumulation): number {\n    const minScale = Math.min(this.scale, other.scale);\n\n    const highLowPos = HighLow.combine(\n      this._highLowAtScale(this.positive, this.scale, minScale),\n      this._highLowAtScale(other.positive, other.scale, minScale)\n    );\n\n    const highLowNeg = HighLow.combine(\n      this._highLowAtScale(this.negative, this.scale, minScale),\n      this._highLowAtScale(other.negative, other.scale, minScale)\n    );\n\n    return Math.min(\n      minScale - this._changeScale(highLowPos.high, highLowPos.low),\n      minScale - this._changeScale(highLowNeg.high, highLowNeg.low)\n    );\n  }\n\n  /**\n   * _highLowAtScale is used by diff and merge to compute an ideal combined scale.\n   */\n  private _highLowAtScale(\n    buckets: Buckets,\n    currentScale: number,\n    newScale: number\n  ): HighLow {\n    if (buckets.length === 0) {\n      return new HighLow(0, -1);\n    }\n    const shift = currentScale - newScale;\n    return new HighLow(buckets.indexStart >> shift, buckets.indexEnd >> shift);\n  }\n\n  /**\n   * _mergeBuckets translates index values from another histogram and\n   * adds the values into the corresponding buckets of this histogram.\n   */\n  private _mergeBuckets(\n    ours: Buckets,\n    other: ExponentialHistogramAccumulation,\n    theirs: Buckets,\n    scale: number\n  ) {\n    const theirOffset = theirs.offset;\n    const theirChange = other.scale - scale;\n\n    for (let i = 0; i < theirs.length; i++) {\n      this._incrementIndexBy(\n        ours,\n        (theirOffset + i) >> theirChange,\n        theirs.at(i)\n      );\n    }\n  }\n\n  /**\n   * _diffBuckets translates index values from another histogram and\n   * subtracts the values in the corresponding buckets of this histogram.\n   */\n  private _diffBuckets(\n    ours: Buckets,\n    other: ExponentialHistogramAccumulation,\n    theirs: Buckets,\n    scale: number\n  ) {\n    const theirOffset = theirs.offset;\n    const theirChange = other.scale - scale;\n\n    for (let i = 0; i < theirs.length; i++) {\n      const ourIndex = (theirOffset + i) >> theirChange;\n      let bucketIndex = ourIndex - ours.indexBase;\n      if (bucketIndex < 0) {\n        bucketIndex += ours.backing.length;\n      }\n      ours.decrementBucket(bucketIndex, theirs.at(i));\n    }\n\n    ours.trim();\n  }\n}\n\n/**\n * Aggregator for ExponentialHistogramAccumulations\n */\nexport class ExponentialHistogramAggregator\n  implements Aggregator<ExponentialHistogramAccumulation>\n{\n  public kind: AggregatorKind.EXPONENTIAL_HISTOGRAM =\n    AggregatorKind.EXPONENTIAL_HISTOGRAM;\n\n  /**\n   * @param _maxSize Maximum number of buckets for each of the positive\n   *    and negative ranges, exclusive of the zero-bucket.\n   * @param _recordMinMax If set to true, min and max will be recorded.\n   *    Otherwise, min and max will not be recorded.\n   */\n  constructor(\n    readonly _maxSize: number,\n    private readonly _recordMinMax: boolean\n  ) {}\n\n  createAccumulation(startTime: HrTime) {\n    return new ExponentialHistogramAccumulation(\n      startTime,\n      this._maxSize,\n      this._recordMinMax\n    );\n  }\n\n  /**\n   * Return the result of the merge of two exponential histogram accumulations.\n   */\n  merge(\n    previous: ExponentialHistogramAccumulation,\n    delta: ExponentialHistogramAccumulation\n  ): ExponentialHistogramAccumulation {\n    const result = delta.clone();\n    result.merge(previous);\n\n    return result;\n  }\n\n  /**\n   * Returns a new DELTA aggregation by comparing two cumulative measurements.\n   */\n  diff(\n    previous: ExponentialHistogramAccumulation,\n    current: ExponentialHistogramAccumulation\n  ): ExponentialHistogramAccumulation {\n    const result = current.clone();\n    result.diff(previous);\n\n    return result;\n  }\n\n  toMetricData(\n    descriptor: InstrumentDescriptor,\n    aggregationTemporality: AggregationTemporality,\n    accumulationByAttributes: AccumulationRecord<ExponentialHistogramAccumulation>[],\n    endTime: HrTime\n  ): Maybe<ExponentialHistogramMetricData> {\n    return {\n      descriptor,\n      aggregationTemporality,\n      dataPointType: DataPointType.EXPONENTIAL_HISTOGRAM,\n      dataPoints: accumulationByAttributes.map(([attributes, accumulation]) => {\n        const pointValue = accumulation.toPointValue();\n\n        // determine if instrument allows negative values.\n        const allowsNegativeValues =\n          descriptor.type === InstrumentType.GAUGE ||\n          descriptor.type === InstrumentType.UP_DOWN_COUNTER ||\n          descriptor.type === InstrumentType.OBSERVABLE_GAUGE ||\n          descriptor.type === InstrumentType.OBSERVABLE_UP_DOWN_COUNTER;\n\n        return {\n          attributes,\n          startTime: accumulation.startTime,\n          endTime,\n          value: {\n            min: pointValue.hasMinMax ? pointValue.min : undefined,\n            max: pointValue.hasMinMax ? pointValue.max : undefined,\n            sum: !allowsNegativeValues ? pointValue.sum : undefined,\n            positive: {\n              offset: pointValue.positive.offset,\n              bucketCounts: pointValue.positive.bucketCounts,\n            },\n            negative: {\n              offset: pointValue.negative.offset,\n              bucketCounts: pointValue.negative.bucketCounts,\n            },\n            count: pointValue.count,\n            scale: pointValue.scale,\n            zeroCount: pointValue.zeroCount,\n          },\n        };\n      }),\n    };\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Accumulation,\n  AccumulationRecord,\n  Aggregator,\n  AggregatorKind,\n  LastValue,\n} from './types';\nimport { HrTime } from '@opentelemetry/api';\nimport { millisToHrTime, hrTimeToMicroseconds } from '@opentelemetry/core';\nimport { DataPointType, GaugeMetricData } from '../export/MetricData';\nimport { Maybe } from '../utils';\nimport { AggregationTemporality } from '../export/AggregationTemporality';\nimport { InstrumentDescriptor } from '../InstrumentDescriptor';\n\nexport class LastValueAccumulation implements Accumulation {\n  constructor(\n    public startTime: HrTime,\n    private _current = 0,\n    public sampleTime: HrTime = [0, 0]\n  ) {}\n\n  record(value: number): void {\n    this._current = value;\n    this.sampleTime = millisToHrTime(Date.now());\n  }\n\n  setStartTime(startTime: HrTime): void {\n    this.startTime = startTime;\n  }\n\n  toPointValue(): LastValue {\n    return this._current;\n  }\n}\n\n/** Basic aggregator which calculates a LastValue from individual measurements. */\nexport class LastValueAggregator implements Aggregator<LastValueAccumulation> {\n  public kind: AggregatorKind.LAST_VALUE = AggregatorKind.LAST_VALUE;\n\n  createAccumulation(startTime: HrTime) {\n    return new LastValueAccumulation(startTime);\n  }\n\n  /**\n   * Returns the result of the merge of the given accumulations.\n   *\n   * Return the newly captured (delta) accumulation for LastValueAggregator.\n   */\n  merge(\n    previous: LastValueAccumulation,\n    delta: LastValueAccumulation\n  ): LastValueAccumulation {\n    // nanoseconds may lose precisions.\n    const latestAccumulation =\n      hrTimeToMicroseconds(delta.sampleTime) >=\n      hrTimeToMicroseconds(previous.sampleTime)\n        ? delta\n        : previous;\n    return new LastValueAccumulation(\n      previous.startTime,\n      latestAccumulation.toPointValue(),\n      latestAccumulation.sampleTime\n    );\n  }\n\n  /**\n   * Returns a new DELTA aggregation by comparing two cumulative measurements.\n   *\n   * A delta aggregation is not meaningful to LastValueAggregator, just return\n   * the newly captured (delta) accumulation for LastValueAggregator.\n   */\n  diff(\n    previous: LastValueAccumulation,\n    current: LastValueAccumulation\n  ): LastValueAccumulation {\n    // nanoseconds may lose precisions.\n    const latestAccumulation =\n      hrTimeToMicroseconds(current.sampleTime) >=\n      hrTimeToMicroseconds(previous.sampleTime)\n        ? current\n        : previous;\n    return new LastValueAccumulation(\n      current.startTime,\n      latestAccumulation.toPointValue(),\n      latestAccumulation.sampleTime\n    );\n  }\n\n  toMetricData(\n    descriptor: InstrumentDescriptor,\n    aggregationTemporality: AggregationTemporality,\n    accumulationByAttributes: AccumulationRecord<LastValueAccumulation>[],\n    endTime: HrTime\n  ): Maybe<GaugeMetricData> {\n    return {\n      descriptor,\n      aggregationTemporality,\n      dataPointType: DataPointType.GAUGE,\n      dataPoints: accumulationByAttributes.map(([attributes, accumulation]) => {\n        return {\n          attributes,\n          startTime: accumulation.startTime,\n          endTime,\n          value: accumulation.toPointValue(),\n        };\n      }),\n    };\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Sum,\n  AggregatorKind,\n  Aggregator,\n  Accumulation,\n  AccumulationRecord,\n} from './types';\nimport { HrTime } from '@opentelemetry/api';\nimport { DataPointType, SumMetricData } from '../export/MetricData';\nimport { Maybe } from '../utils';\nimport { AggregationTemporality } from '../export/AggregationTemporality';\nimport { InstrumentDescriptor } from '../InstrumentDescriptor';\n\nexport class SumAccumulation implements Accumulation {\n  constructor(\n    public startTime: HrTime,\n    public monotonic: boolean,\n    private _current = 0,\n    public reset = false\n  ) {}\n\n  record(value: number): void {\n    if (this.monotonic && value < 0) {\n      return;\n    }\n    this._current += value;\n  }\n\n  setStartTime(startTime: HrTime): void {\n    this.startTime = startTime;\n  }\n\n  toPointValue(): Sum {\n    return this._current;\n  }\n}\n\n/** Basic aggregator which calculates a Sum from individual measurements. */\nexport class SumAggregator implements Aggregator<SumAccumulation> {\n  public kind: AggregatorKind.SUM = AggregatorKind.SUM;\n\n  constructor(public monotonic: boolean) {}\n\n  createAccumulation(startTime: HrTime) {\n    return new SumAccumulation(startTime, this.monotonic);\n  }\n\n  /**\n   * Returns the result of the merge of the given accumulations.\n   */\n  merge(previous: SumAccumulation, delta: SumAccumulation): SumAccumulation {\n    const prevPv = previous.toPointValue();\n    const deltaPv = delta.toPointValue();\n    if (delta.reset) {\n      return new SumAccumulation(\n        delta.startTime,\n        this.monotonic,\n        deltaPv,\n        delta.reset\n      );\n    }\n    return new SumAccumulation(\n      previous.startTime,\n      this.monotonic,\n      prevPv + deltaPv\n    );\n  }\n\n  /**\n   * Returns a new DELTA aggregation by comparing two cumulative measurements.\n   */\n  diff(previous: SumAccumulation, current: SumAccumulation): SumAccumulation {\n    const prevPv = previous.toPointValue();\n    const currPv = current.toPointValue();\n    /**\n     * If the SumAggregator is a monotonic one and the previous point value is\n     * greater than the current one, a reset is deemed to be happened.\n     * Return the current point value to prevent the value from been reset.\n     */\n    if (this.monotonic && prevPv > currPv) {\n      return new SumAccumulation(\n        current.startTime,\n        this.monotonic,\n        currPv,\n        true\n      );\n    }\n    return new SumAccumulation(\n      current.startTime,\n      this.monotonic,\n      currPv - prevPv\n    );\n  }\n\n  toMetricData(\n    descriptor: InstrumentDescriptor,\n    aggregationTemporality: AggregationTemporality,\n    accumulationByAttributes: AccumulationRecord<SumAccumulation>[],\n    endTime: HrTime\n  ): Maybe<SumMetricData> {\n    return {\n      descriptor,\n      aggregationTemporality,\n      dataPointType: DataPointType.SUM,\n      dataPoints: accumulationByAttributes.map(([attributes, accumulation]) => {\n        return {\n          attributes,\n          startTime: accumulation.startTime,\n          endTime,\n          value: accumulation.toPointValue(),\n        };\n      }),\n      isMonotonic: this.monotonic,\n    };\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as api from '@opentelemetry/api';\nimport {\n  Aggregator,\n  SumAggregator,\n  DropAggregator,\n  LastValueAggregator,\n  HistogramAggregator,\n  ExponentialHistogramAggregator,\n} from '../aggregator';\nimport { Accumulation } from '../aggregator/types';\nimport { InstrumentDescriptor } from '../InstrumentDescriptor';\nimport { Maybe } from '../utils';\nimport { InstrumentType } from '../export/MetricData';\n\n/**\n * Configures how measurements are combined into metrics for views.\n *\n * Aggregation provides a set of built-in aggregations via static methods.\n */\nexport interface Aggregation {\n  createAggregator(\n    instrument: InstrumentDescriptor\n  ): Aggregator<Maybe<Accumulation>>;\n}\n\n/**\n * The default drop aggregation.\n */\nexport class DropAggregation implements Aggregation {\n  private static DEFAULT_INSTANCE = new DropAggregator();\n  createAggregator(_instrument: InstrumentDescriptor) {\n    return DropAggregation.DEFAULT_INSTANCE;\n  }\n}\n\n/**\n * The default sum aggregation.\n */\nexport class SumAggregation implements Aggregation {\n  private static MONOTONIC_INSTANCE = new SumAggregator(true);\n  private static NON_MONOTONIC_INSTANCE = new SumAggregator(false);\n  createAggregator(instrument: InstrumentDescriptor) {\n    switch (instrument.type) {\n      case InstrumentType.COUNTER:\n      case InstrumentType.OBSERVABLE_COUNTER:\n      case InstrumentType.HISTOGRAM: {\n        return SumAggregation.MONOTONIC_INSTANCE;\n      }\n      default: {\n        return SumAggregation.NON_MONOTONIC_INSTANCE;\n      }\n    }\n  }\n}\n\n/**\n * The default last value aggregation.\n */\nexport class LastValueAggregation implements Aggregation {\n  private static DEFAULT_INSTANCE = new LastValueAggregator();\n  createAggregator(_instrument: InstrumentDescriptor) {\n    return LastValueAggregation.DEFAULT_INSTANCE;\n  }\n}\n\n/**\n * The default histogram aggregation.\n\n */\nexport class HistogramAggregation implements Aggregation {\n  private static DEFAULT_INSTANCE = new HistogramAggregator(\n    [0, 5, 10, 25, 50, 75, 100, 250, 500, 750, 1000, 2500, 5000, 7500, 10000],\n    true\n  );\n  createAggregator(_instrument: InstrumentDescriptor) {\n    return HistogramAggregation.DEFAULT_INSTANCE;\n  }\n}\n\n/**\n * The explicit bucket histogram aggregation.\n */\nexport class ExplicitBucketHistogramAggregation implements Aggregation {\n  private _boundaries: number[];\n\n  /**\n   * @param boundaries the bucket boundaries of the histogram aggregation\n   * @param _recordMinMax If set to true, min and max will be recorded. Otherwise, min and max will not be recorded.\n   */\n  constructor(\n    boundaries: number[],\n    private readonly _recordMinMax = true\n  ) {\n    if (boundaries == null) {\n      throw new Error(\n        'ExplicitBucketHistogramAggregation should be created with explicit boundaries, if a single bucket histogram is required, please pass an empty array'\n      );\n    }\n    // Copy the boundaries array for modification.\n    boundaries = boundaries.concat();\n    // We need to an ordered set to be able to correctly compute count for each\n    // boundary since we'll iterate on each in order.\n    boundaries = boundaries.sort((a, b) => a - b);\n    // Remove all Infinity from the boundaries.\n    const minusInfinityIndex = boundaries.lastIndexOf(-Infinity);\n    let infinityIndex: number | undefined = boundaries.indexOf(Infinity);\n    if (infinityIndex === -1) {\n      infinityIndex = undefined;\n    }\n    this._boundaries = boundaries.slice(minusInfinityIndex + 1, infinityIndex);\n  }\n\n  createAggregator(_instrument: InstrumentDescriptor) {\n    return new HistogramAggregator(this._boundaries, this._recordMinMax);\n  }\n}\n\nexport class ExponentialHistogramAggregation implements Aggregation {\n  constructor(\n    private readonly _maxSize = 160,\n    private readonly _recordMinMax = true\n  ) {}\n  createAggregator(_instrument: InstrumentDescriptor) {\n    return new ExponentialHistogramAggregator(\n      this._maxSize,\n      this._recordMinMax\n    );\n  }\n}\n\n/**\n * The default aggregation.\n */\nexport class DefaultAggregation implements Aggregation {\n  private _resolve(instrument: InstrumentDescriptor): Aggregation {\n    // cast to unknown to disable complaints on the (unreachable) fallback.\n    switch (instrument.type as unknown) {\n      case InstrumentType.COUNTER:\n      case InstrumentType.UP_DOWN_COUNTER:\n      case InstrumentType.OBSERVABLE_COUNTER:\n      case InstrumentType.OBSERVABLE_UP_DOWN_COUNTER: {\n        return SUM_AGGREGATION;\n      }\n      case InstrumentType.GAUGE:\n      case InstrumentType.OBSERVABLE_GAUGE: {\n        return LAST_VALUE_AGGREGATION;\n      }\n      case InstrumentType.HISTOGRAM: {\n        if (instrument.advice.explicitBucketBoundaries) {\n          return new ExplicitBucketHistogramAggregation(\n            instrument.advice.explicitBucketBoundaries\n          );\n        }\n        return HISTOGRAM_AGGREGATION;\n      }\n    }\n    api.diag.warn(`Unable to recognize instrument type: ${instrument.type}`);\n    return DROP_AGGREGATION;\n  }\n\n  createAggregator(\n    instrument: InstrumentDescriptor\n  ): Aggregator<Maybe<Accumulation>> {\n    return this._resolve(instrument).createAggregator(instrument);\n  }\n}\n\nexport const DROP_AGGREGATION = new DropAggregation();\nexport const SUM_AGGREGATION = new SumAggregation();\nexport const LAST_VALUE_AGGREGATION = new LastValueAggregation();\nexport const HISTOGRAM_AGGREGATION = new HistogramAggregation();\nexport const EXPONENTIAL_HISTOGRAM_AGGREGATION =\n  new ExponentialHistogramAggregation();\nexport const DEFAULT_AGGREGATION = new DefaultAggregation();\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport {\n  Aggregation,\n  DEFAULT_AGGREGATION,\n  DROP_AGGREGATION,\n  ExplicitBucketHistogramAggregation,\n  ExponentialHistogramAggregation,\n  HISTOGRAM_AGGREGATION,\n  LAST_VALUE_AGGREGATION,\n  SUM_AGGREGATION,\n} from './Aggregation';\n\nexport enum AggregationType {\n  DEFAULT = 0,\n  DROP = 1,\n  SUM = 2,\n  LAST_VALUE = 3,\n  EXPLICIT_BUCKET_HISTOGRAM = 4,\n  EXPONENTIAL_HISTOGRAM = 5,\n}\n\nexport type SumAggregationOption = {\n  type: AggregationType.SUM;\n};\n\nexport type LastValueAggregationOption = {\n  type: AggregationType.LAST_VALUE;\n};\n\nexport type DropAggregationOption = {\n  type: AggregationType.DROP;\n};\n\nexport type DefaultAggregationOption = {\n  type: AggregationType.DEFAULT;\n};\n\nexport type HistogramAggregationOption = {\n  type: AggregationType.EXPLICIT_BUCKET_HISTOGRAM;\n  options?: {\n    recordMinMax?: boolean;\n    boundaries: number[];\n  };\n};\n\nexport type ExponentialHistogramAggregationOption = {\n  type: AggregationType.EXPONENTIAL_HISTOGRAM;\n  options?: {\n    recordMinMax?: boolean;\n    maxSize?: number;\n  };\n};\n\nexport type AggregationOption =\n  | ExponentialHistogramAggregationOption\n  | HistogramAggregationOption\n  | SumAggregationOption\n  | DropAggregationOption\n  | DefaultAggregationOption\n  | LastValueAggregationOption;\n\nexport function toAggregation(option: AggregationOption): Aggregation {\n  switch (option.type) {\n    case AggregationType.DEFAULT:\n      return DEFAULT_AGGREGATION;\n    case AggregationType.DROP:\n      return DROP_AGGREGATION;\n    case AggregationType.SUM:\n      return SUM_AGGREGATION;\n    case AggregationType.LAST_VALUE:\n      return LAST_VALUE_AGGREGATION;\n    case AggregationType.EXPONENTIAL_HISTOGRAM: {\n      const expOption = option as ExponentialHistogramAggregationOption;\n      return new ExponentialHistogramAggregation(\n        expOption.options?.maxSize,\n        expOption.options?.recordMinMax\n      );\n    }\n    case AggregationType.EXPLICIT_BUCKET_HISTOGRAM: {\n      const expOption = option as HistogramAggregationOption;\n      if (expOption.options == null) {\n        return HISTOGRAM_AGGREGATION;\n      } else {\n        return new ExplicitBucketHistogramAggregation(\n          expOption.options?.boundaries,\n          expOption.options?.recordMinMax\n        );\n      }\n    }\n    default:\n      throw new Error('Unsupported Aggregation');\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { AggregationTemporality } from './AggregationTemporality';\nimport { InstrumentType } from './MetricData';\nimport { AggregationOption, AggregationType } from '../view/AggregationOption';\n\n/**\n * Aggregation selector based on metric instrument types.\n */\nexport type AggregationSelector = (\n  instrumentType: InstrumentType\n) => AggregationOption;\n\n/**\n * Aggregation temporality selector based on metric instrument types.\n */\nexport type AggregationTemporalitySelector = (\n  instrumentType: InstrumentType\n) => AggregationTemporality;\n\nexport const DEFAULT_AGGREGATION_SELECTOR: AggregationSelector =\n  _instrumentType => {\n    return {\n      type: AggregationType.DEFAULT,\n    };\n  };\n\nexport const DEFAULT_AGGREGATION_TEMPORALITY_SELECTOR: AggregationTemporalitySelector =\n  _instrumentType => AggregationTemporality.CUMULATIVE;\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as api from '@opentelemetry/api';\nimport { AggregationTemporality } from './AggregationTemporality';\nimport { MetricProducer } from './MetricProducer';\nimport { CollectionResult, InstrumentType } from './MetricData';\nimport { callWithTimeout, FlatMap } from '../utils';\nimport {\n  CollectionOptions,\n  ForceFlushOptions,\n  ShutdownOptions,\n} from '../types';\nimport {\n  AggregationSelector,\n  AggregationTemporalitySelector,\n  DEFAULT_AGGREGATION_SELECTOR,\n  DEFAULT_AGGREGATION_TEMPORALITY_SELECTOR,\n} from './AggregationSelector';\nimport { AggregationOption } from '../view/AggregationOption';\nimport { CardinalitySelector } from './CardinalitySelector';\n\nexport interface MetricReaderOptions {\n  /**\n   * Aggregation selector based on metric instrument types. If no views are\n   * configured for a metric instrument, a per-metric-reader aggregation is\n   * selected with this selector.\n   *\n   * <p> NOTE: the provided function MUST be pure\n   */\n  aggregationSelector?: AggregationSelector;\n  /**\n   * Aggregation temporality selector based on metric instrument types. If\n   * not configured, cumulative is used for all instruments.\n   *\n   * <p> NOTE: the provided function MUST be pure\n   */\n  aggregationTemporalitySelector?: AggregationTemporalitySelector;\n  /**\n   * Cardinality selector based on metric instrument types. If not configured,\n   * a default value is used.\n   *\n   * <p> NOTE: the provided function MUST be pure\n   */\n  cardinalitySelector?: CardinalitySelector;\n  /**\n   * **Note, this option is experimental**. Additional MetricProducers to use as a source of\n   * aggregated metric data in addition to the SDK's metric data. The resource returned by\n   * these MetricProducers is ignored; the SDK's resource will be used instead.\n   * @experimental\n   */\n  metricProducers?: MetricProducer[];\n}\n\n/**\n * Reads metrics from the SDK. Implementations MUST follow the Metric Reader Specification as well as the requirements\n * listed in this interface. Consider extending {@link MetricReader} to get a specification-compliant base implementation\n * of this interface\n */\nexport interface IMetricReader {\n  /**\n   * Set the {@link MetricProducer} used by this instance. **This should only be called once by the\n   * SDK and should be considered internal.**\n   *\n   * <p> NOTE: implementations MUST throw when called more than once\n   *\n   * @param metricProducer\n   */\n  setMetricProducer(metricProducer: MetricProducer): void;\n\n  /**\n   * Select the {@link AggregationOption} for the given {@link InstrumentType} for this\n   * reader.\n   *\n   * <p> NOTE: implementations MUST be pure\n   */\n  selectAggregation(instrumentType: InstrumentType): AggregationOption;\n\n  /**\n   * Select the {@link AggregationTemporality} for the given\n   * {@link InstrumentType} for this reader.\n   *\n   * <p> NOTE: implementations MUST be pure\n   */\n  selectAggregationTemporality(\n    instrumentType: InstrumentType\n  ): AggregationTemporality;\n\n  /**\n   * Select the cardinality limit for the given {@link InstrumentType} for this\n   * reader.\n   *\n   * <p> NOTE: implementations MUST be pure\n   */\n  selectCardinalityLimit(instrumentType: InstrumentType): number;\n\n  /**\n   * Collect all metrics from the associated {@link MetricProducer}\n   */\n  collect(options?: CollectionOptions): Promise<CollectionResult>;\n\n  /**\n   * Shuts down the metric reader, the promise will reject after the optional timeout or resolve after completion.\n   *\n   * <p> NOTE: this operation MAY continue even after the promise rejects due to a timeout.\n   * @param options options with timeout.\n   */\n  shutdown(options?: ShutdownOptions): Promise<void>;\n\n  /**\n   * Flushes metrics read by this reader, the promise will reject after the optional timeout or resolve after completion.\n   *\n   * <p> NOTE: this operation MAY continue even after the promise rejects due to a timeout.\n   * @param options options with timeout.\n   */\n  forceFlush(options?: ForceFlushOptions): Promise<void>;\n}\n\n/**\n * A registered reader of metrics that, when linked to a {@link MetricProducer}, offers global\n * control over metrics.\n */\nexport abstract class MetricReader implements IMetricReader {\n  // Tracks the shutdown state.\n  // TODO: use BindOncePromise here once a new version of @opentelemetry/core is available.\n  private _shutdown = false;\n  // Additional MetricProducers which will be combined with the SDK's output\n  private _metricProducers: MetricProducer[];\n  // MetricProducer used by this instance which produces metrics from the SDK\n  private _sdkMetricProducer?: MetricProducer;\n  private readonly _aggregationTemporalitySelector: AggregationTemporalitySelector;\n  private readonly _aggregationSelector: AggregationSelector;\n  private readonly _cardinalitySelector?: CardinalitySelector;\n\n  constructor(options?: MetricReaderOptions) {\n    this._aggregationSelector =\n      options?.aggregationSelector ?? DEFAULT_AGGREGATION_SELECTOR;\n    this._aggregationTemporalitySelector =\n      options?.aggregationTemporalitySelector ??\n      DEFAULT_AGGREGATION_TEMPORALITY_SELECTOR;\n    this._metricProducers = options?.metricProducers ?? [];\n    this._cardinalitySelector = options?.cardinalitySelector;\n  }\n\n  setMetricProducer(metricProducer: MetricProducer) {\n    if (this._sdkMetricProducer) {\n      throw new Error(\n        'MetricReader can not be bound to a MeterProvider again.'\n      );\n    }\n    this._sdkMetricProducer = metricProducer;\n    this.onInitialized();\n  }\n\n  selectAggregation(instrumentType: InstrumentType): AggregationOption {\n    return this._aggregationSelector(instrumentType);\n  }\n\n  selectAggregationTemporality(\n    instrumentType: InstrumentType\n  ): AggregationTemporality {\n    return this._aggregationTemporalitySelector(instrumentType);\n  }\n\n  selectCardinalityLimit(instrumentType: InstrumentType): number {\n    return this._cardinalitySelector\n      ? this._cardinalitySelector(instrumentType)\n      : 2000; // default value if no selector is provided\n  }\n\n  /**\n   * Handle once the SDK has initialized this {@link MetricReader}\n   * Overriding this method is optional.\n   */\n  protected onInitialized(): void {\n    // Default implementation is empty.\n  }\n\n  /**\n   * Handle a shutdown signal by the SDK.\n   *\n   * <p> For push exporters, this should shut down any intervals and close any open connections.\n   * @protected\n   */\n  protected abstract onShutdown(): Promise<void>;\n\n  /**\n   * Handle a force flush signal by the SDK.\n   *\n   * <p> In all scenarios metrics should be collected via {@link collect()}.\n   * <p> For push exporters, this should collect and report metrics.\n   * @protected\n   */\n  protected abstract onForceFlush(): Promise<void>;\n\n  async collect(options?: CollectionOptions): Promise<CollectionResult> {\n    if (this._sdkMetricProducer === undefined) {\n      throw new Error('MetricReader is not bound to a MetricProducer');\n    }\n\n    // Subsequent invocations to collect are not allowed. SDKs SHOULD return some failure for these calls.\n    if (this._shutdown) {\n      throw new Error('MetricReader is shutdown');\n    }\n\n    const [sdkCollectionResults, ...additionalCollectionResults] =\n      await Promise.all([\n        this._sdkMetricProducer.collect({\n          timeoutMillis: options?.timeoutMillis,\n        }),\n        ...this._metricProducers.map(producer =>\n          producer.collect({\n            timeoutMillis: options?.timeoutMillis,\n          })\n        ),\n      ]);\n\n    // Merge the results, keeping the SDK's Resource\n    const errors = sdkCollectionResults.errors.concat(\n      FlatMap(additionalCollectionResults, result => result.errors)\n    );\n    const resource = sdkCollectionResults.resourceMetrics.resource;\n    const scopeMetrics =\n      sdkCollectionResults.resourceMetrics.scopeMetrics.concat(\n        FlatMap(\n          additionalCollectionResults,\n          result => result.resourceMetrics.scopeMetrics\n        )\n      );\n    return {\n      resourceMetrics: {\n        resource,\n        scopeMetrics,\n      },\n      errors,\n    };\n  }\n\n  async shutdown(options?: ShutdownOptions): Promise<void> {\n    // Do not call shutdown again if it has already been called.\n    if (this._shutdown) {\n      api.diag.error('Cannot call shutdown twice.');\n      return;\n    }\n\n    // No timeout if timeoutMillis is undefined or null.\n    if (options?.timeoutMillis == null) {\n      await this.onShutdown();\n    } else {\n      await callWithTimeout(this.onShutdown(), options.timeoutMillis);\n    }\n\n    this._shutdown = true;\n  }\n\n  async forceFlush(options?: ForceFlushOptions): Promise<void> {\n    if (this._shutdown) {\n      api.diag.warn('Cannot forceFlush on already shutdown MetricReader.');\n      return;\n    }\n\n    // No timeout if timeoutMillis is undefined or null.\n    if (options?.timeoutMillis == null) {\n      await this.onForceFlush();\n      return;\n    }\n\n    await callWithTimeout(this.onForceFlush(), options.timeoutMillis);\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as api from '@opentelemetry/api';\nimport {\n  internal,\n  ExportResultCode,\n  globalErrorHandler,\n} from '@opentelemetry/core';\nimport { MetricReader } from './MetricReader';\nimport { PushMetricExporter } from './MetricExporter';\nimport { callWithTimeout, TimeoutError } from '../utils';\nimport { MetricProducer } from './MetricProducer';\n\nexport type PeriodicExportingMetricReaderOptions = {\n  /**\n   * The backing exporter for the metric reader.\n   */\n  exporter: PushMetricExporter;\n  /**\n   * An internal milliseconds for the metric reader to initiate metric\n   * collection.\n   */\n  exportIntervalMillis?: number;\n  /**\n   * Milliseconds for the async observable callback to timeout.\n   */\n  exportTimeoutMillis?: number;\n  /**\n   * **Note, this option is experimental**. Additional MetricProducers to use as a source of\n   * aggregated metric data in addition to the SDK's metric data. The resource returned by\n   * these MetricProducers is ignored; the SDK's resource will be used instead.\n   * @experimental\n   */\n  metricProducers?: MetricProducer[];\n};\n\n/**\n * {@link MetricReader} which collects metrics based on a user-configurable time interval, and passes the metrics to\n * the configured {@link PushMetricExporter}\n */\nexport class PeriodicExportingMetricReader extends MetricReader {\n  private _interval?: ReturnType<typeof setInterval>;\n  private _exporter: PushMetricExporter;\n  private readonly _exportInterval: number;\n  private readonly _exportTimeout: number;\n\n  constructor(options: PeriodicExportingMetricReaderOptions) {\n    super({\n      aggregationSelector: options.exporter.selectAggregation?.bind(\n        options.exporter\n      ),\n      aggregationTemporalitySelector:\n        options.exporter.selectAggregationTemporality?.bind(options.exporter),\n      metricProducers: options.metricProducers,\n    });\n\n    if (\n      options.exportIntervalMillis !== undefined &&\n      options.exportIntervalMillis <= 0\n    ) {\n      throw Error('exportIntervalMillis must be greater than 0');\n    }\n\n    if (\n      options.exportTimeoutMillis !== undefined &&\n      options.exportTimeoutMillis <= 0\n    ) {\n      throw Error('exportTimeoutMillis must be greater than 0');\n    }\n\n    if (\n      options.exportTimeoutMillis !== undefined &&\n      options.exportIntervalMillis !== undefined &&\n      options.exportIntervalMillis < options.exportTimeoutMillis\n    ) {\n      throw Error(\n        'exportIntervalMillis must be greater than or equal to exportTimeoutMillis'\n      );\n    }\n\n    this._exportInterval = options.exportIntervalMillis ?? 60000;\n    this._exportTimeout = options.exportTimeoutMillis ?? 30000;\n    this._exporter = options.exporter;\n  }\n\n  private async _runOnce(): Promise<void> {\n    try {\n      await callWithTimeout(this._doRun(), this._exportTimeout);\n    } catch (err) {\n      if (err instanceof TimeoutError) {\n        api.diag.error(\n          'Export took longer than %s milliseconds and timed out.',\n          this._exportTimeout\n        );\n        return;\n      }\n\n      globalErrorHandler(err);\n    }\n  }\n\n  private async _doRun(): Promise<void> {\n    const { resourceMetrics, errors } = await this.collect({\n      timeoutMillis: this._exportTimeout,\n    });\n\n    if (errors.length > 0) {\n      api.diag.error(\n        'PeriodicExportingMetricReader: metrics collection errors',\n        ...errors\n      );\n    }\n\n    if (resourceMetrics.resource.asyncAttributesPending) {\n      try {\n        await resourceMetrics.resource.waitForAsyncAttributes?.();\n      } catch (e) {\n        api.diag.debug('Error while resolving async portion of resource: ', e);\n        globalErrorHandler(e);\n      }\n    }\n\n    if (resourceMetrics.scopeMetrics.length === 0) {\n      return;\n    }\n\n    const result = await internal._export(this._exporter, resourceMetrics);\n    if (result.code !== ExportResultCode.SUCCESS) {\n      throw new Error(\n        `PeriodicExportingMetricReader: metrics export failed (error ${result.error})`\n      );\n    }\n  }\n\n  protected override onInitialized(): void {\n    // start running the interval as soon as this reader is initialized and keep handle for shutdown.\n    this._interval = setInterval(() => {\n      // this._runOnce never rejects. Using void operator to suppress @typescript-eslint/no-floating-promises.\n      void this._runOnce();\n    }, this._exportInterval);\n\n    // depending on runtime, this may be a 'number' or NodeJS.Timeout\n    if (typeof this._interval !== 'number') {\n      this._interval.unref();\n    }\n  }\n\n  protected async onForceFlush(): Promise<void> {\n    await this._runOnce();\n    await this._exporter.forceFlush();\n  }\n\n  protected async onShutdown(): Promise<void> {\n    if (this._interval) {\n      clearInterval(this._interval);\n    }\n    await this.onForceFlush();\n    await this._exporter.shutdown();\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ExportResultCode } from '@opentelemetry/core';\nimport { ExportResult } from '@opentelemetry/core';\nimport { AggregationTemporality } from './AggregationTemporality';\nimport { InstrumentType, ResourceMetrics } from './MetricData';\nimport { PushMetricExporter } from './MetricExporter';\n\n/**\n * In-memory Metrics Exporter is a Push Metric Exporter\n * which accumulates metrics data in the local memory and\n * allows to inspect it (useful for e.g. unit tests).\n */\nexport class InMemoryMetricExporter implements PushMetricExporter {\n  protected _shutdown = false;\n  protected _aggregationTemporality: AggregationTemporality;\n  private _metrics: ResourceMetrics[] = [];\n\n  constructor(aggregationTemporality: AggregationTemporality) {\n    this._aggregationTemporality = aggregationTemporality;\n  }\n\n  /**\n   * @inheritedDoc\n   */\n  export(\n    metrics: ResourceMetrics,\n    resultCallback: (result: ExportResult) => void\n  ): void {\n    // Avoid storing metrics when exporter is shutdown\n    if (this._shutdown) {\n      setTimeout(() => resultCallback({ code: ExportResultCode.FAILED }), 0);\n      return;\n    }\n\n    this._metrics.push(metrics);\n    setTimeout(() => resultCallback({ code: ExportResultCode.SUCCESS }), 0);\n  }\n\n  /**\n   * Returns all the collected resource metrics\n   * @returns ResourceMetrics[]\n   */\n  public getMetrics(): ResourceMetrics[] {\n    return this._metrics;\n  }\n\n  forceFlush(): Promise<void> {\n    return Promise.resolve();\n  }\n\n  reset() {\n    this._metrics = [];\n  }\n\n  selectAggregationTemporality(\n    _instrumentType: InstrumentType\n  ): AggregationTemporality {\n    return this._aggregationTemporality;\n  }\n\n  shutdown(): Promise<void> {\n    this._shutdown = true;\n    return Promise.resolve();\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { ExportResult, ExportResultCode } from '@opentelemetry/core';\nimport { AggregationTemporality } from './AggregationTemporality';\nimport { ResourceMetrics, InstrumentType } from './MetricData';\nimport { PushMetricExporter } from './MetricExporter';\nimport {\n  AggregationTemporalitySelector,\n  DEFAULT_AGGREGATION_TEMPORALITY_SELECTOR,\n} from './AggregationSelector';\n\ninterface ConsoleMetricExporterOptions {\n  temporalitySelector?: AggregationTemporalitySelector;\n}\n\n/**\n * This is an implementation of {@link PushMetricExporter} that prints metrics to the\n * console. This class can be used for diagnostic purposes.\n *\n * NOTE: This {@link PushMetricExporter} is intended for diagnostics use only, output rendered to the console may change at any time.\n */\n\n/* eslint-disable no-console */\nexport class ConsoleMetricExporter implements PushMetricExporter {\n  protected _shutdown = false;\n  protected _temporalitySelector: AggregationTemporalitySelector;\n\n  constructor(options?: ConsoleMetricExporterOptions) {\n    this._temporalitySelector =\n      options?.temporalitySelector ?? DEFAULT_AGGREGATION_TEMPORALITY_SELECTOR;\n  }\n\n  export(\n    metrics: ResourceMetrics,\n    resultCallback: (result: ExportResult) => void\n  ): void {\n    if (this._shutdown) {\n      // If the exporter is shutting down, by spec, we need to return FAILED as export result\n      setImmediate(resultCallback, { code: ExportResultCode.FAILED });\n      return;\n    }\n\n    return ConsoleMetricExporter._sendMetrics(metrics, resultCallback);\n  }\n\n  forceFlush(): Promise<void> {\n    return Promise.resolve();\n  }\n\n  selectAggregationTemporality(\n    _instrumentType: InstrumentType\n  ): AggregationTemporality {\n    return this._temporalitySelector(_instrumentType);\n  }\n\n  shutdown(): Promise<void> {\n    this._shutdown = true;\n    return Promise.resolve();\n  }\n\n  private static _sendMetrics(\n    metrics: ResourceMetrics,\n    done: (result: ExportResult) => void\n  ): void {\n    for (const scopeMetrics of metrics.scopeMetrics) {\n      for (const metric of scopeMetrics.metrics) {\n        console.dir(\n          {\n            descriptor: metric.descriptor,\n            dataPointType: metric.dataPointType,\n            dataPoints: metric.dataPoints,\n          },\n          { depth: null }\n        );\n      }\n    }\n\n    done({ code: ExportResultCode.SUCCESS });\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { InstrumentationScope } from '@opentelemetry/core';\nimport { InstrumentDescriptor } from '../InstrumentDescriptor';\nimport { InstrumentSelector } from './InstrumentSelector';\nimport { MeterSelector } from './MeterSelector';\nimport { View } from './View';\n\nexport class ViewRegistry {\n  private _registeredViews: View[] = [];\n\n  addView(view: View) {\n    this._registeredViews.push(view);\n  }\n\n  findViews(\n    instrument: InstrumentDescriptor,\n    meter: InstrumentationScope\n  ): View[] {\n    const views = this._registeredViews.filter(registeredView => {\n      return (\n        this._matchInstrument(registeredView.instrumentSelector, instrument) &&\n        this._matchMeter(registeredView.meterSelector, meter)\n      );\n    });\n\n    return views;\n  }\n\n  private _matchInstrument(\n    selector: InstrumentSelector,\n    instrument: InstrumentDescriptor\n  ): boolean {\n    return (\n      (selector.getType() === undefined ||\n        instrument.type === selector.getType()) &&\n      selector.getNameFilter().match(instrument.name) &&\n      selector.getUnitFilter().match(instrument.unit)\n    );\n  }\n\n  private _matchMeter(\n    selector: MeterSelector,\n    meter: InstrumentationScope\n  ): boolean {\n    return (\n      selector.getNameFilter().match(meter.name) &&\n      (meter.version === undefined ||\n        selector.getVersionFilter().match(meter.version)) &&\n      (meter.schemaUrl === undefined ||\n        selector.getSchemaUrlFilter().match(meter.schemaUrl))\n    );\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  MetricAdvice,\n  MetricOptions,\n  ValueType,\n  diag,\n} from '@opentelemetry/api';\nimport { View } from './view/View';\nimport { equalsCaseInsensitive } from './utils';\nimport { InstrumentType, MetricDescriptor } from './export/MetricData';\n\n/**\n * An internal interface describing the instrument.\n *\n * This is intentionally distinguished from the public MetricDescriptor (a.k.a. InstrumentDescriptor)\n * which may not contains internal fields like metric advice.\n */\nexport interface InstrumentDescriptor extends MetricDescriptor {\n  /**\n   * For internal use; exporter should avoid depending on the type of the\n   * instrument as their resulting aggregator can be re-mapped with views.\n   */\n  readonly type: InstrumentType;\n\n  /**\n   * See {@link MetricAdvice}\n   *\n   * @experimental\n   */\n  readonly advice: MetricAdvice;\n}\n\nexport function createInstrumentDescriptor(\n  name: string,\n  type: InstrumentType,\n  options?: MetricOptions\n): InstrumentDescriptor {\n  if (!isValidName(name)) {\n    diag.warn(\n      `Invalid metric name: \"${name}\". The metric name should be a ASCII string with a length no greater than 255 characters.`\n    );\n  }\n  return {\n    name,\n    type,\n    description: options?.description ?? '',\n    unit: options?.unit ?? '',\n    valueType: options?.valueType ?? ValueType.DOUBLE,\n    advice: options?.advice ?? {},\n  };\n}\n\nexport function createInstrumentDescriptorWithView(\n  view: View,\n  instrument: InstrumentDescriptor\n): InstrumentDescriptor {\n  return {\n    name: view.name ?? instrument.name,\n    description: view.description ?? instrument.description,\n    type: instrument.type,\n    unit: instrument.unit,\n    valueType: instrument.valueType,\n    advice: instrument.advice,\n  };\n}\n\nexport function isDescriptorCompatibleWith(\n  descriptor: InstrumentDescriptor,\n  otherDescriptor: InstrumentDescriptor\n) {\n  // Names are case-insensitive strings.\n  return (\n    equalsCaseInsensitive(descriptor.name, otherDescriptor.name) &&\n    descriptor.unit === otherDescriptor.unit &&\n    descriptor.type === otherDescriptor.type &&\n    descriptor.valueType === otherDescriptor.valueType\n  );\n}\n\n// ASCII string with a length no greater than 255 characters.\n// NB: the first character counted separately from the rest.\nconst NAME_REGEXP = /^[a-z][a-z0-9_.\\-/]{0,254}$/i;\nexport function isValidName(name: string): boolean {\n  return name.match(NAME_REGEXP) != null;\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  context as contextApi,\n  diag,\n  Context,\n  Attributes,\n  ValueType,\n  UpDownCounter,\n  Counter,\n  Gauge,\n  Histogram,\n  Observable,\n  ObservableCallback,\n  ObservableCounter,\n  ObservableGauge,\n  ObservableUpDownCounter,\n} from '@opentelemetry/api';\nimport { millisToHrTime } from '@opentelemetry/core';\nimport { InstrumentDescriptor } from './InstrumentDescriptor';\nimport { ObservableRegistry } from './state/ObservableRegistry';\nimport {\n  AsyncWritableMetricStorage,\n  WritableMetricStorage,\n} from './state/WritableMetricStorage';\n\nexport class SyncInstrument {\n  constructor(\n    private _writableMetricStorage: WritableMetricStorage,\n    protected _descriptor: InstrumentDescriptor\n  ) {}\n\n  protected _record(\n    value: number,\n    attributes: Attributes = {},\n    context: Context = contextApi.active()\n  ) {\n    if (typeof value !== 'number') {\n      diag.warn(\n        `non-number value provided to metric ${this._descriptor.name}: ${value}`\n      );\n      return;\n    }\n    if (\n      this._descriptor.valueType === ValueType.INT &&\n      !Number.isInteger(value)\n    ) {\n      diag.warn(\n        `INT value type cannot accept a floating-point value for ${this._descriptor.name}, ignoring the fractional digits.`\n      );\n      value = Math.trunc(value);\n      // ignore non-finite values.\n      if (!Number.isInteger(value)) {\n        return;\n      }\n    }\n    this._writableMetricStorage.record(\n      value,\n      attributes,\n      context,\n      millisToHrTime(Date.now())\n    );\n  }\n}\n\n/**\n * The class implements {@link UpDownCounter} interface.\n */\nexport class UpDownCounterInstrument\n  extends SyncInstrument\n  implements UpDownCounter\n{\n  /**\n   * Increment value of counter by the input. Inputs may be negative.\n   */\n  add(value: number, attributes?: Attributes, ctx?: Context): void {\n    this._record(value, attributes, ctx);\n  }\n}\n\n/**\n * The class implements {@link Counter} interface.\n */\nexport class CounterInstrument extends SyncInstrument implements Counter {\n  /**\n   * Increment value of counter by the input. Inputs may not be negative.\n   */\n  add(value: number, attributes?: Attributes, ctx?: Context): void {\n    if (value < 0) {\n      diag.warn(\n        `negative value provided to counter ${this._descriptor.name}: ${value}`\n      );\n      return;\n    }\n\n    this._record(value, attributes, ctx);\n  }\n}\n\n/**\n * The class implements {@link Gauge} interface.\n */\nexport class GaugeInstrument extends SyncInstrument implements Gauge {\n  /**\n   * Records a measurement.\n   */\n  record(value: number, attributes?: Attributes, ctx?: Context): void {\n    this._record(value, attributes, ctx);\n  }\n}\n\n/**\n * The class implements {@link Histogram} interface.\n */\nexport class HistogramInstrument extends SyncInstrument implements Histogram {\n  /**\n   * Records a measurement. Value of the measurement must not be negative.\n   */\n  record(value: number, attributes?: Attributes, ctx?: Context): void {\n    if (value < 0) {\n      diag.warn(\n        `negative value provided to histogram ${this._descriptor.name}: ${value}`\n      );\n      return;\n    }\n    this._record(value, attributes, ctx);\n  }\n}\n\nexport class ObservableInstrument implements Observable {\n  /** @internal */\n  _metricStorages: AsyncWritableMetricStorage[];\n  /** @internal */\n  _descriptor: InstrumentDescriptor;\n\n  constructor(\n    descriptor: InstrumentDescriptor,\n    metricStorages: AsyncWritableMetricStorage[],\n    private _observableRegistry: ObservableRegistry\n  ) {\n    this._descriptor = descriptor;\n    this._metricStorages = metricStorages;\n  }\n\n  /**\n   * @see {Observable.addCallback}\n   */\n  addCallback(callback: ObservableCallback) {\n    this._observableRegistry.addCallback(callback, this);\n  }\n\n  /**\n   * @see {Observable.removeCallback}\n   */\n  removeCallback(callback: ObservableCallback) {\n    this._observableRegistry.removeCallback(callback, this);\n  }\n}\n\nexport class ObservableCounterInstrument\n  extends ObservableInstrument\n  implements ObservableCounter {}\nexport class ObservableGaugeInstrument\n  extends ObservableInstrument\n  implements ObservableGauge {}\nexport class ObservableUpDownCounterInstrument\n  extends ObservableInstrument\n  implements ObservableUpDownCounter {}\n\nexport function isObservableInstrument(\n  it: unknown\n): it is ObservableInstrument {\n  return it instanceof ObservableInstrument;\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Meter as IMeter,\n  MetricOptions,\n  Gauge,\n  Histogram,\n  Counter,\n  UpDownCounter,\n  ObservableGauge,\n  ObservableCounter,\n  ObservableUpDownCounter,\n  BatchObservableCallback,\n  Observable,\n} from '@opentelemetry/api';\nimport { createInstrumentDescriptor } from './InstrumentDescriptor';\nimport {\n  CounterInstrument,\n  GaugeInstrument,\n  HistogramInstrument,\n  ObservableCounterInstrument,\n  ObservableGaugeInstrument,\n  ObservableUpDownCounterInstrument,\n  UpDownCounterInstrument,\n} from './Instruments';\nimport { MeterSharedState } from './state/MeterSharedState';\nimport { InstrumentType } from './export/MetricData';\n\n/**\n * This class implements the {@link IMeter} interface.\n */\nexport class Meter implements IMeter {\n  constructor(private _meterSharedState: MeterSharedState) {}\n\n  /**\n   * Create a {@link Gauge} instrument.\n   */\n  createGauge(name: string, options?: MetricOptions): Gauge {\n    const descriptor = createInstrumentDescriptor(\n      name,\n      InstrumentType.GAUGE,\n      options\n    );\n    const storage = this._meterSharedState.registerMetricStorage(descriptor);\n    return new GaugeInstrument(storage, descriptor);\n  }\n\n  /**\n   * Create a {@link Histogram} instrument.\n   */\n  createHistogram(name: string, options?: MetricOptions): Histogram {\n    const descriptor = createInstrumentDescriptor(\n      name,\n      InstrumentType.HISTOGRAM,\n      options\n    );\n    const storage = this._meterSharedState.registerMetricStorage(descriptor);\n    return new HistogramInstrument(storage, descriptor);\n  }\n\n  /**\n   * Create a {@link Counter} instrument.\n   */\n  createCounter(name: string, options?: MetricOptions): Counter {\n    const descriptor = createInstrumentDescriptor(\n      name,\n      InstrumentType.COUNTER,\n      options\n    );\n    const storage = this._meterSharedState.registerMetricStorage(descriptor);\n    return new CounterInstrument(storage, descriptor);\n  }\n\n  /**\n   * Create a {@link UpDownCounter} instrument.\n   */\n  createUpDownCounter(name: string, options?: MetricOptions): UpDownCounter {\n    const descriptor = createInstrumentDescriptor(\n      name,\n      InstrumentType.UP_DOWN_COUNTER,\n      options\n    );\n    const storage = this._meterSharedState.registerMetricStorage(descriptor);\n    return new UpDownCounterInstrument(storage, descriptor);\n  }\n\n  /**\n   * Create a {@link ObservableGauge} instrument.\n   */\n  createObservableGauge(\n    name: string,\n    options?: MetricOptions\n  ): ObservableGauge {\n    const descriptor = createInstrumentDescriptor(\n      name,\n      InstrumentType.OBSERVABLE_GAUGE,\n      options\n    );\n    const storages =\n      this._meterSharedState.registerAsyncMetricStorage(descriptor);\n    return new ObservableGaugeInstrument(\n      descriptor,\n      storages,\n      this._meterSharedState.observableRegistry\n    );\n  }\n\n  /**\n   * Create a {@link ObservableCounter} instrument.\n   */\n  createObservableCounter(\n    name: string,\n    options?: MetricOptions\n  ): ObservableCounter {\n    const descriptor = createInstrumentDescriptor(\n      name,\n      InstrumentType.OBSERVABLE_COUNTER,\n      options\n    );\n    const storages =\n      this._meterSharedState.registerAsyncMetricStorage(descriptor);\n    return new ObservableCounterInstrument(\n      descriptor,\n      storages,\n      this._meterSharedState.observableRegistry\n    );\n  }\n\n  /**\n   * Create a {@link ObservableUpDownCounter} instrument.\n   */\n  createObservableUpDownCounter(\n    name: string,\n    options?: MetricOptions\n  ): ObservableUpDownCounter {\n    const descriptor = createInstrumentDescriptor(\n      name,\n      InstrumentType.OBSERVABLE_UP_DOWN_COUNTER,\n      options\n    );\n    const storages =\n      this._meterSharedState.registerAsyncMetricStorage(descriptor);\n    return new ObservableUpDownCounterInstrument(\n      descriptor,\n      storages,\n      this._meterSharedState.observableRegistry\n    );\n  }\n\n  /**\n   * @see {@link Meter.addBatchObservableCallback}\n   */\n  addBatchObservableCallback(\n    callback: BatchObservableCallback,\n    observables: Observable[]\n  ) {\n    this._meterSharedState.observableRegistry.addBatchCallback(\n      callback,\n      observables\n    );\n  }\n\n  /**\n   * @see {@link Meter.removeBatchObservableCallback}\n   */\n  removeBatchObservableCallback(\n    callback: BatchObservableCallback,\n    observables: Observable[]\n  ) {\n    this._meterSharedState.observableRegistry.removeBatchCallback(\n      callback,\n      observables\n    );\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { HrTime } from '@opentelemetry/api';\nimport { MetricData } from '../export/MetricData';\nimport { Maybe } from '../utils';\nimport { MetricCollectorHandle } from './MetricCollector';\nimport {\n  createInstrumentDescriptor,\n  InstrumentDescriptor,\n} from '../InstrumentDescriptor';\n\n/**\n * Internal interface.\n *\n * Represents a storage from which we can collect metrics.\n */\nexport abstract class MetricStorage {\n  constructor(protected _instrumentDescriptor: InstrumentDescriptor) {}\n\n  /**\n   * Collects the metrics from this storage.\n   *\n   * Note: This is a stateful operation and may reset any interval-related\n   * state for the MetricCollector.\n   */\n  abstract collect(\n    collector: MetricCollectorHandle,\n    collectionTime: HrTime\n  ): Maybe<MetricData>;\n\n  getInstrumentDescriptor(): Readonly<InstrumentDescriptor> {\n    return this._instrumentDescriptor;\n  }\n\n  updateDescription(description: string): void {\n    this._instrumentDescriptor = createInstrumentDescriptor(\n      this._instrumentDescriptor.name,\n      this._instrumentDescriptor.type,\n      {\n        description: description,\n        valueType: this._instrumentDescriptor.valueType,\n        unit: this._instrumentDescriptor.unit,\n        advice: this._instrumentDescriptor.advice,\n      }\n    );\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Attributes } from '@opentelemetry/api';\nimport { hashAttributes } from '../utils';\n\nexport interface Hash<ValueType, HashCodeType> {\n  (value: ValueType): HashCodeType;\n}\n\nexport class HashMap<KeyType, ValueType, HashCodeType> {\n  private _valueMap = new Map<HashCodeType, ValueType>();\n  private _keyMap = new Map<HashCodeType, KeyType>();\n\n  constructor(private _hash: Hash<KeyType, HashCodeType>) {}\n\n  get(key: KeyType, hashCode?: HashCodeType) {\n    hashCode ??= this._hash(key);\n    return this._valueMap.get(hashCode);\n  }\n\n  getOrDefault(key: KeyType, defaultFactory: () => ValueType) {\n    const hash = this._hash(key);\n    if (this._valueMap.has(hash)) {\n      return this._valueMap.get(hash);\n    }\n    const val = defaultFactory();\n    if (!this._keyMap.has(hash)) {\n      this._keyMap.set(hash, key);\n    }\n    this._valueMap.set(hash, val);\n    return val;\n  }\n\n  set(key: KeyType, value: ValueType, hashCode?: HashCodeType) {\n    hashCode ??= this._hash(key);\n    if (!this._keyMap.has(hashCode)) {\n      this._keyMap.set(hashCode, key);\n    }\n    this._valueMap.set(hashCode, value);\n  }\n\n  has(key: KeyType, hashCode?: HashCodeType) {\n    hashCode ??= this._hash(key);\n    return this._valueMap.has(hashCode);\n  }\n\n  *keys(): IterableIterator<[KeyType, HashCodeType]> {\n    const keyIterator = this._keyMap.entries();\n    let next = keyIterator.next();\n    while (next.done !== true) {\n      yield [next.value[1], next.value[0]];\n      next = keyIterator.next();\n    }\n  }\n\n  *entries(): IterableIterator<[KeyType, ValueType, HashCodeType]> {\n    const valueIterator = this._valueMap.entries();\n    let next = valueIterator.next();\n    while (next.done !== true) {\n      // next.value[0] here can not be undefined\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      yield [this._keyMap.get(next.value[0])!, next.value[1], next.value[0]];\n      next = valueIterator.next();\n    }\n  }\n\n  get size() {\n    return this._valueMap.size;\n  }\n}\n\nexport class AttributeHashMap<ValueType> extends HashMap<\n  Attributes,\n  ValueType,\n  string\n> {\n  constructor() {\n    super(hashAttributes);\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Context, HrTime, Attributes } from '@opentelemetry/api';\nimport { Maybe, hashAttributes } from '../utils';\nimport { Accumulation, Aggregator } from '../aggregator/types';\nimport { AttributeHashMap } from './HashMap';\n\n/**\n * Internal interface.\n *\n * Allows synchronous collection of metrics. This processor should allow\n * allocation of new aggregation cells for metrics and convert cumulative\n * recording to delta data points.\n */\nexport class DeltaMetricProcessor<T extends Maybe<Accumulation>> {\n  private _activeCollectionStorage = new AttributeHashMap<T>();\n  // TODO: find a reasonable mean to clean the memo;\n  // https://github.com/open-telemetry/opentelemetry-specification/pull/2208\n  private _cumulativeMemoStorage = new AttributeHashMap<T>();\n  private _cardinalityLimit: number;\n  private _overflowAttributes = { 'otel.metric.overflow': true };\n  private _overflowHashCode: string;\n\n  constructor(\n    private _aggregator: Aggregator<T>,\n    aggregationCardinalityLimit?: number\n  ) {\n    this._cardinalityLimit = (aggregationCardinalityLimit ?? 2000) - 1;\n    this._overflowHashCode = hashAttributes(this._overflowAttributes);\n  }\n\n  record(\n    value: number,\n    attributes: Attributes,\n    _context: Context,\n    collectionTime: HrTime\n  ) {\n    let accumulation = this._activeCollectionStorage.get(attributes);\n\n    if (!accumulation) {\n      if (this._activeCollectionStorage.size >= this._cardinalityLimit) {\n        const overflowAccumulation = this._activeCollectionStorage.getOrDefault(\n          this._overflowAttributes,\n          () => this._aggregator.createAccumulation(collectionTime)\n        );\n        overflowAccumulation?.record(value);\n        return;\n      }\n\n      accumulation = this._aggregator.createAccumulation(collectionTime);\n      this._activeCollectionStorage.set(attributes, accumulation);\n    }\n\n    accumulation?.record(value);\n  }\n\n  batchCumulate(\n    measurements: AttributeHashMap<number>,\n    collectionTime: HrTime\n  ) {\n    Array.from(measurements.entries()).forEach(\n      ([attributes, value, hashCode]) => {\n        const accumulation =\n          this._aggregator.createAccumulation(collectionTime);\n        accumulation?.record(value);\n        let delta = accumulation;\n        // Diff with recorded cumulative memo.\n        if (this._cumulativeMemoStorage.has(attributes, hashCode)) {\n          // has() returned true, previous is present.\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          const previous = this._cumulativeMemoStorage.get(\n            attributes,\n            hashCode\n          )!;\n          delta = this._aggregator.diff(previous, accumulation);\n        } else {\n          // If the cardinality limit is reached, we need to change the attributes\n          if (this._cumulativeMemoStorage.size >= this._cardinalityLimit) {\n            attributes = this._overflowAttributes;\n            hashCode = this._overflowHashCode;\n            if (this._cumulativeMemoStorage.has(attributes, hashCode)) {\n              // has() returned true, previous is present.\n              // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n              const previous = this._cumulativeMemoStorage.get(\n                attributes,\n                hashCode\n              )!;\n              delta = this._aggregator.diff(previous, accumulation);\n            }\n          }\n        }\n        // Merge with uncollected active delta.\n        if (this._activeCollectionStorage.has(attributes, hashCode)) {\n          // has() returned true, active is present.\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          const active = this._activeCollectionStorage.get(\n            attributes,\n            hashCode\n          )!;\n          delta = this._aggregator.merge(active, delta);\n        }\n\n        // Save the current record and the delta record.\n        this._cumulativeMemoStorage.set(attributes, accumulation, hashCode);\n        this._activeCollectionStorage.set(attributes, delta, hashCode);\n      }\n    );\n  }\n\n  /**\n   * Returns a collection of delta metrics. Start time is the when first\n   * time event collected.\n   */\n  collect() {\n    const unreportedDelta = this._activeCollectionStorage;\n    this._activeCollectionStorage = new AttributeHashMap();\n\n    return unreportedDelta;\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { HrTime } from '@opentelemetry/api';\nimport {\n  Accumulation,\n  AccumulationRecord,\n  Aggregator,\n} from '../aggregator/types';\nimport { MetricData } from '../export/MetricData';\nimport { InstrumentDescriptor } from '../InstrumentDescriptor';\nimport { AggregationTemporality } from '../export/AggregationTemporality';\nimport { Maybe } from '../utils';\nimport { MetricCollectorHandle } from './MetricCollector';\nimport { AttributeHashMap } from './HashMap';\n\n/**\n * Remembers what was presented to a specific exporter.\n */\ninterface LastReportedHistory<T extends Maybe<Accumulation>> {\n  /**\n   * The last accumulation of metric data.\n   */\n  accumulations: AttributeHashMap<T>;\n  /**\n   * The timestamp the data was reported.\n   */\n  collectionTime: HrTime;\n  /**\n   * The AggregationTemporality used to aggregate reports.\n   */\n  aggregationTemporality: AggregationTemporality;\n}\n\n/**\n * Internal interface.\n *\n * Provides unique reporting for each collector. Allows synchronous collection\n * of metrics and reports given temporality values.\n */\nexport class TemporalMetricProcessor<T extends Maybe<Accumulation>> {\n  private _unreportedAccumulations = new Map<\n    MetricCollectorHandle,\n    AttributeHashMap<T>[]\n  >();\n  private _reportHistory = new Map<\n    MetricCollectorHandle,\n    LastReportedHistory<T>\n  >();\n\n  constructor(\n    private _aggregator: Aggregator<T>,\n    collectorHandles: MetricCollectorHandle[]\n  ) {\n    collectorHandles.forEach(handle => {\n      this._unreportedAccumulations.set(handle, []);\n    });\n  }\n\n  /**\n   * Builds the {@link MetricData} streams to report against a specific MetricCollector.\n   * @param collector The information of the MetricCollector.\n   * @param collectors The registered collectors.\n   * @param instrumentDescriptor The instrumentation descriptor that these metrics generated with.\n   * @param currentAccumulations The current accumulation of metric data from instruments.\n   * @param collectionTime The current collection timestamp.\n   * @returns The {@link MetricData} points or `null`.\n   */\n  buildMetrics(\n    collector: MetricCollectorHandle,\n    instrumentDescriptor: InstrumentDescriptor,\n    currentAccumulations: AttributeHashMap<T>,\n    collectionTime: HrTime\n  ): Maybe<MetricData> {\n    this._stashAccumulations(currentAccumulations);\n    const unreportedAccumulations =\n      this._getMergedUnreportedAccumulations(collector);\n\n    let result = unreportedAccumulations;\n    let aggregationTemporality: AggregationTemporality;\n    // Check our last report time.\n    if (this._reportHistory.has(collector)) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      const last = this._reportHistory.get(collector)!;\n      const lastCollectionTime = last.collectionTime;\n      aggregationTemporality = last.aggregationTemporality;\n\n      // Use aggregation temporality + instrument to determine if we do a merge or a diff of\n      // previous. We have the following four scenarios:\n      // 1. Cumulative Aggregation (temporality) + Delta recording (sync instrument).\n      //    Here we merge with our last record to get a cumulative aggregation.\n      // 2. Cumulative Aggregation + Cumulative recording (async instrument).\n      //    Cumulative records are converted to delta recording with DeltaMetricProcessor.\n      //    Here we merge with our last record to get a cumulative aggregation.\n      // 3. Delta Aggregation + Delta recording\n      //    Calibrate the startTime of metric streams to be the reader's lastCollectionTime.\n      // 4. Delta Aggregation + Cumulative recording.\n      //    Cumulative records are converted to delta recording with DeltaMetricProcessor.\n      //    Calibrate the startTime of metric streams to be the reader's lastCollectionTime.\n      if (aggregationTemporality === AggregationTemporality.CUMULATIVE) {\n        // We need to make sure the current delta recording gets merged into the previous cumulative\n        // for the next cumulative recording.\n        result = TemporalMetricProcessor.merge(\n          last.accumulations,\n          unreportedAccumulations,\n          this._aggregator\n        );\n      } else {\n        result = TemporalMetricProcessor.calibrateStartTime(\n          last.accumulations,\n          unreportedAccumulations,\n          lastCollectionTime\n        );\n      }\n    } else {\n      // Call into user code to select aggregation temporality for the instrument.\n      aggregationTemporality = collector.selectAggregationTemporality(\n        instrumentDescriptor.type\n      );\n    }\n\n    // Update last reported (cumulative) accumulation.\n    this._reportHistory.set(collector, {\n      accumulations: result,\n      collectionTime,\n      aggregationTemporality,\n    });\n\n    const accumulationRecords = AttributesMapToAccumulationRecords(result);\n\n    // do not convert to metric data if there is nothing to convert.\n    if (accumulationRecords.length === 0) {\n      return undefined;\n    }\n\n    return this._aggregator.toMetricData(\n      instrumentDescriptor,\n      aggregationTemporality,\n      accumulationRecords,\n      /* endTime */ collectionTime\n    );\n  }\n\n  private _stashAccumulations(currentAccumulation: AttributeHashMap<T>) {\n    const registeredCollectors = this._unreportedAccumulations.keys();\n    for (const collector of registeredCollectors) {\n      let stash = this._unreportedAccumulations.get(collector);\n      if (stash === undefined) {\n        stash = [];\n        this._unreportedAccumulations.set(collector, stash);\n      }\n      stash.push(currentAccumulation);\n    }\n  }\n\n  private _getMergedUnreportedAccumulations(collector: MetricCollectorHandle) {\n    let result = new AttributeHashMap<T>();\n    const unreportedList = this._unreportedAccumulations.get(collector);\n    this._unreportedAccumulations.set(collector, []);\n    if (unreportedList === undefined) {\n      return result;\n    }\n    for (const it of unreportedList) {\n      result = TemporalMetricProcessor.merge(result, it, this._aggregator);\n    }\n    return result;\n  }\n\n  static merge<T extends Maybe<Accumulation>>(\n    last: AttributeHashMap<T>,\n    current: AttributeHashMap<T>,\n    aggregator: Aggregator<T>\n  ) {\n    const result = last;\n    const iterator = current.entries();\n    let next = iterator.next();\n    while (next.done !== true) {\n      const [key, record, hash] = next.value;\n      if (last.has(key, hash)) {\n        const lastAccumulation = last.get(key, hash);\n        // last.has() returned true, lastAccumulation is present.\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const accumulation = aggregator.merge(lastAccumulation!, record);\n        result.set(key, accumulation, hash);\n      } else {\n        result.set(key, record, hash);\n      }\n\n      next = iterator.next();\n    }\n    return result;\n  }\n\n  /**\n   * Calibrate the reported metric streams' startTime to lastCollectionTime. Leaves\n   * the new stream to be the initial observation time unchanged.\n   */\n  static calibrateStartTime<T extends Maybe<Accumulation>>(\n    last: AttributeHashMap<T>,\n    current: AttributeHashMap<T>,\n    lastCollectionTime: HrTime\n  ) {\n    for (const [key, hash] of last.keys()) {\n      const currentAccumulation = current.get(key, hash);\n      currentAccumulation?.setStartTime(lastCollectionTime);\n    }\n    return current;\n  }\n}\n\n// TypeScript complains about converting 3 elements tuple to AccumulationRecord<T>.\nfunction AttributesMapToAccumulationRecords<T>(\n  map: AttributeHashMap<T>\n): AccumulationRecord<T>[] {\n  return Array.from(map.entries()) as unknown as AccumulationRecord<T>[];\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { HrTime } from '@opentelemetry/api';\nimport { Accumulation, Aggregator } from '../aggregator/types';\nimport { InstrumentDescriptor } from '../InstrumentDescriptor';\nimport { MetricStorage } from './MetricStorage';\nimport { MetricData } from '../export/MetricData';\nimport { DeltaMetricProcessor } from './DeltaMetricProcessor';\nimport { TemporalMetricProcessor } from './TemporalMetricProcessor';\nimport { Maybe } from '../utils';\nimport { MetricCollectorHandle } from './MetricCollector';\nimport { AttributeHashMap } from './HashMap';\nimport { AsyncWritableMetricStorage } from './WritableMetricStorage';\nimport { IAttributesProcessor } from '../view/AttributesProcessor';\n\n/**\n * Internal interface.\n *\n * Stores and aggregates {@link MetricData} for asynchronous instruments.\n */\nexport class AsyncMetricStorage<T extends Maybe<Accumulation>>\n  extends MetricStorage\n  implements AsyncWritableMetricStorage\n{\n  private _deltaMetricStorage: DeltaMetricProcessor<T>;\n  private _temporalMetricStorage: TemporalMetricProcessor<T>;\n\n  constructor(\n    _instrumentDescriptor: InstrumentDescriptor,\n    aggregator: Aggregator<T>,\n    private _attributesProcessor: IAttributesProcessor,\n    collectorHandles: MetricCollectorHandle[],\n    private _aggregationCardinalityLimit?: number\n  ) {\n    super(_instrumentDescriptor);\n    this._deltaMetricStorage = new DeltaMetricProcessor(\n      aggregator,\n      this._aggregationCardinalityLimit\n    );\n    this._temporalMetricStorage = new TemporalMetricProcessor(\n      aggregator,\n      collectorHandles\n    );\n  }\n\n  record(measurements: AttributeHashMap<number>, observationTime: HrTime) {\n    const processed = new AttributeHashMap<number>();\n    Array.from(measurements.entries()).forEach(([attributes, value]) => {\n      processed.set(this._attributesProcessor.process(attributes), value);\n    });\n    this._deltaMetricStorage.batchCumulate(processed, observationTime);\n  }\n\n  /**\n   * Collects the metrics from this storage. The ObservableCallback is invoked\n   * during the collection.\n   *\n   * Note: This is a stateful operation and may reset any interval-related\n   * state for the MetricCollector.\n   */\n  collect(\n    collector: MetricCollectorHandle,\n    collectionTime: HrTime\n  ): Maybe<MetricData> {\n    const accumulations = this._deltaMetricStorage.collect();\n\n    return this._temporalMetricStorage.buildMetrics(\n      collector,\n      this._instrumentDescriptor,\n      accumulations,\n      collectionTime\n    );\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { InstrumentSelectorCriteria } from './InstrumentSelector';\nimport { InstrumentDescriptor } from '../InstrumentDescriptor';\n\nexport function getIncompatibilityDetails(\n  existing: InstrumentDescriptor,\n  otherDescriptor: InstrumentDescriptor\n) {\n  let incompatibility = '';\n  if (existing.unit !== otherDescriptor.unit) {\n    incompatibility += `\\t- Unit '${existing.unit}' does not match '${otherDescriptor.unit}'\\n`;\n  }\n  if (existing.type !== otherDescriptor.type) {\n    incompatibility += `\\t- Type '${existing.type}' does not match '${otherDescriptor.type}'\\n`;\n  }\n  if (existing.valueType !== otherDescriptor.valueType) {\n    incompatibility += `\\t- Value Type '${existing.valueType}' does not match '${otherDescriptor.valueType}'\\n`;\n  }\n  if (existing.description !== otherDescriptor.description) {\n    incompatibility += `\\t- Description '${existing.description}' does not match '${otherDescriptor.description}'\\n`;\n  }\n\n  return incompatibility;\n}\n\nexport function getValueTypeConflictResolutionRecipe(\n  existing: InstrumentDescriptor,\n  otherDescriptor: InstrumentDescriptor\n) {\n  return `\\t- use valueType '${existing.valueType}' on instrument creation or use an instrument name other than '${otherDescriptor.name}'`;\n}\n\nexport function getUnitConflictResolutionRecipe(\n  existing: InstrumentDescriptor,\n  otherDescriptor: InstrumentDescriptor\n) {\n  return `\\t- use unit '${existing.unit}' on instrument creation or use an instrument name other than '${otherDescriptor.name}'`;\n}\n\nexport function getTypeConflictResolutionRecipe(\n  existing: InstrumentDescriptor,\n  otherDescriptor: InstrumentDescriptor\n) {\n  const selector: InstrumentSelectorCriteria = {\n    name: otherDescriptor.name,\n    type: otherDescriptor.type,\n    unit: otherDescriptor.unit,\n  };\n\n  const selectorString = JSON.stringify(selector);\n\n  return `\\t- create a new view with a name other than '${existing.name}' and InstrumentSelector '${selectorString}'`;\n}\n\nexport function getDescriptionResolutionRecipe(\n  existing: InstrumentDescriptor,\n  otherDescriptor: InstrumentDescriptor\n): string {\n  const selector: InstrumentSelectorCriteria = {\n    name: otherDescriptor.name,\n    type: otherDescriptor.type,\n    unit: otherDescriptor.unit,\n  };\n\n  const selectorString = JSON.stringify(selector);\n\n  return `\\t- create a new view with a name other than '${existing.name}' and InstrumentSelector '${selectorString}'\n    \\t- OR - create a new view with the name ${existing.name} and description '${existing.description}' and InstrumentSelector ${selectorString}\n    \\t- OR - create a new view with the name ${otherDescriptor.name} and description '${existing.description}' and InstrumentSelector ${selectorString}`;\n}\n\nexport function getConflictResolutionRecipe(\n  existing: InstrumentDescriptor,\n  otherDescriptor: InstrumentDescriptor\n): string {\n  // Conflicts that cannot be solved via views.\n  if (existing.valueType !== otherDescriptor.valueType) {\n    return getValueTypeConflictResolutionRecipe(existing, otherDescriptor);\n  }\n\n  if (existing.unit !== otherDescriptor.unit) {\n    return getUnitConflictResolutionRecipe(existing, otherDescriptor);\n  }\n\n  // Conflicts that can be solved via views.\n  if (existing.type !== otherDescriptor.type) {\n    // this will automatically solve possible description conflicts.\n    return getTypeConflictResolutionRecipe(existing, otherDescriptor);\n  }\n\n  if (existing.description !== otherDescriptor.description) {\n    return getDescriptionResolutionRecipe(existing, otherDescriptor);\n  }\n\n  return '';\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { MetricStorage } from './MetricStorage';\nimport {\n  InstrumentDescriptor,\n  isDescriptorCompatibleWith,\n} from '../InstrumentDescriptor';\nimport * as api from '@opentelemetry/api';\nimport {\n  getConflictResolutionRecipe,\n  getIncompatibilityDetails,\n} from '../view/RegistrationConflicts';\nimport { MetricCollectorHandle } from './MetricCollector';\n\ntype StorageMap = Map<string, MetricStorage[]>;\n\n/**\n * Internal class for storing {@link MetricStorage}\n */\nexport class MetricStorageRegistry {\n  private readonly _sharedRegistry: StorageMap = new Map();\n  private readonly _perCollectorRegistry = new Map<\n    MetricCollectorHandle,\n    StorageMap\n  >();\n\n  static create() {\n    return new MetricStorageRegistry();\n  }\n\n  getStorages(collector: MetricCollectorHandle): MetricStorage[] {\n    let storages: MetricStorage[] = [];\n    for (const metricStorages of this._sharedRegistry.values()) {\n      storages = storages.concat(metricStorages);\n    }\n\n    const perCollectorStorages = this._perCollectorRegistry.get(collector);\n    if (perCollectorStorages != null) {\n      for (const metricStorages of perCollectorStorages.values()) {\n        storages = storages.concat(metricStorages);\n      }\n    }\n\n    return storages;\n  }\n\n  register(storage: MetricStorage) {\n    this._registerStorage(storage, this._sharedRegistry);\n  }\n\n  registerForCollector(\n    collector: MetricCollectorHandle,\n    storage: MetricStorage\n  ) {\n    let storageMap = this._perCollectorRegistry.get(collector);\n    if (storageMap == null) {\n      storageMap = new Map();\n      this._perCollectorRegistry.set(collector, storageMap);\n    }\n    this._registerStorage(storage, storageMap);\n  }\n\n  findOrUpdateCompatibleStorage<T extends MetricStorage>(\n    expectedDescriptor: InstrumentDescriptor\n  ): T | null {\n    const storages = this._sharedRegistry.get(expectedDescriptor.name);\n    if (storages === undefined) {\n      return null;\n    }\n\n    // If the descriptor is compatible, the type of their metric storage\n    // (either SyncMetricStorage or AsyncMetricStorage) must be compatible.\n    return this._findOrUpdateCompatibleStorage<T>(expectedDescriptor, storages);\n  }\n\n  findOrUpdateCompatibleCollectorStorage<T extends MetricStorage>(\n    collector: MetricCollectorHandle,\n    expectedDescriptor: InstrumentDescriptor\n  ): T | null {\n    const storageMap = this._perCollectorRegistry.get(collector);\n    if (storageMap === undefined) {\n      return null;\n    }\n\n    const storages = storageMap.get(expectedDescriptor.name);\n    if (storages === undefined) {\n      return null;\n    }\n\n    // If the descriptor is compatible, the type of their metric storage\n    // (either SyncMetricStorage or AsyncMetricStorage) must be compatible.\n    return this._findOrUpdateCompatibleStorage<T>(expectedDescriptor, storages);\n  }\n\n  private _registerStorage(storage: MetricStorage, storageMap: StorageMap) {\n    const descriptor = storage.getInstrumentDescriptor();\n    const storages = storageMap.get(descriptor.name);\n\n    if (storages === undefined) {\n      storageMap.set(descriptor.name, [storage]);\n      return;\n    }\n\n    storages.push(storage);\n  }\n\n  private _findOrUpdateCompatibleStorage<T extends MetricStorage>(\n    expectedDescriptor: InstrumentDescriptor,\n    existingStorages: MetricStorage[]\n  ): T | null {\n    let compatibleStorage = null;\n\n    for (const existingStorage of existingStorages) {\n      const existingDescriptor = existingStorage.getInstrumentDescriptor();\n\n      if (isDescriptorCompatibleWith(existingDescriptor, expectedDescriptor)) {\n        // Use the longer description if it does not match.\n        if (existingDescriptor.description !== expectedDescriptor.description) {\n          if (\n            expectedDescriptor.description.length >\n            existingDescriptor.description.length\n          ) {\n            existingStorage.updateDescription(expectedDescriptor.description);\n          }\n\n          api.diag.warn(\n            'A view or instrument with the name ',\n            expectedDescriptor.name,\n            ' has already been registered, but has a different description and is incompatible with another registered view.\\n',\n            'Details:\\n',\n            getIncompatibilityDetails(existingDescriptor, expectedDescriptor),\n            'The longer description will be used.\\nTo resolve the conflict:',\n            getConflictResolutionRecipe(existingDescriptor, expectedDescriptor)\n          );\n        }\n        // Storage is fully compatible. There will never be more than one pre-existing fully compatible storage.\n        compatibleStorage = existingStorage as T;\n      } else {\n        // The implementation SHOULD warn about duplicate instrument registration\n        // conflicts after applying View configuration.\n        api.diag.warn(\n          'A view or instrument with the name ',\n          expectedDescriptor.name,\n          ' has already been registered and is incompatible with another registered view.\\n',\n          'Details:\\n',\n          getIncompatibilityDetails(existingDescriptor, expectedDescriptor),\n          'To resolve the conflict:\\n',\n          getConflictResolutionRecipe(existingDescriptor, expectedDescriptor)\n        );\n      }\n    }\n\n    return compatibleStorage;\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Context, HrTime, Attributes } from '@opentelemetry/api';\nimport { WritableMetricStorage } from './WritableMetricStorage';\n\n/**\n * Internal interface.\n */\nexport class MultiMetricStorage implements WritableMetricStorage {\n  constructor(private readonly _backingStorages: WritableMetricStorage[]) {}\n\n  record(\n    value: number,\n    attributes: Attributes,\n    context: Context,\n    recordTime: HrTime\n  ) {\n    this._backingStorages.forEach(it => {\n      it.record(value, attributes, context, recordTime);\n    });\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  diag,\n  ObservableResult,\n  Attributes,\n  ValueType,\n  BatchObservableResult,\n  Observable,\n} from '@opentelemetry/api';\nimport { AttributeHashMap } from './state/HashMap';\nimport { isObservableInstrument, ObservableInstrument } from './Instruments';\n\n/**\n * The class implements {@link ObservableResult} interface.\n */\nexport class ObservableResultImpl implements ObservableResult {\n  /**\n   * @internal\n   */\n  _buffer = new AttributeHashMap<number>();\n\n  constructor(\n    private _instrumentName: string,\n    private _valueType: ValueType\n  ) {}\n\n  /**\n   * Observe a measurement of the value associated with the given attributes.\n   */\n  observe(value: number, attributes: Attributes = {}): void {\n    if (typeof value !== 'number') {\n      diag.warn(\n        `non-number value provided to metric ${this._instrumentName}: ${value}`\n      );\n      return;\n    }\n    if (this._valueType === ValueType.INT && !Number.isInteger(value)) {\n      diag.warn(\n        `INT value type cannot accept a floating-point value for ${this._instrumentName}, ignoring the fractional digits.`\n      );\n      value = Math.trunc(value);\n      // ignore non-finite values.\n      if (!Number.isInteger(value)) {\n        return;\n      }\n    }\n    this._buffer.set(attributes, value);\n  }\n}\n\n/**\n * The class implements {@link BatchObservableCallback} interface.\n */\nexport class BatchObservableResultImpl implements BatchObservableResult {\n  /**\n   * @internal\n   */\n  _buffer: Map<ObservableInstrument, AttributeHashMap<number>> = new Map();\n\n  /**\n   * Observe a measurement of the value associated with the given attributes.\n   */\n  observe(\n    metric: Observable,\n    value: number,\n    attributes: Attributes = {}\n  ): void {\n    if (!isObservableInstrument(metric)) {\n      return;\n    }\n    let map = this._buffer.get(metric);\n    if (map == null) {\n      map = new AttributeHashMap();\n      this._buffer.set(metric, map);\n    }\n    if (typeof value !== 'number') {\n      diag.warn(\n        `non-number value provided to metric ${metric._descriptor.name}: ${value}`\n      );\n      return;\n    }\n    if (\n      metric._descriptor.valueType === ValueType.INT &&\n      !Number.isInteger(value)\n    ) {\n      diag.warn(\n        `INT value type cannot accept a floating-point value for ${metric._descriptor.name}, ignoring the fractional digits.`\n      );\n      value = Math.trunc(value);\n      // ignore non-finite values.\n      if (!Number.isInteger(value)) {\n        return;\n      }\n    }\n    map.set(attributes, value);\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  diag,\n  HrTime,\n  BatchObservableCallback,\n  Observable,\n  ObservableCallback,\n} from '@opentelemetry/api';\nimport { isObservableInstrument, ObservableInstrument } from '../Instruments';\nimport {\n  BatchObservableResultImpl,\n  ObservableResultImpl,\n} from '../ObservableResult';\nimport {\n  callWithTimeout,\n  PromiseAllSettled,\n  isPromiseAllSettledRejectionResult,\n  setEquals,\n} from '../utils';\n\n/**\n * Records for single instrument observable callback.\n */\ninterface ObservableCallbackRecord {\n  callback: ObservableCallback;\n  instrument: ObservableInstrument;\n}\n\n/**\n * Records for multiple instruments observable callback.\n */\ninterface BatchObservableCallbackRecord {\n  callback: BatchObservableCallback;\n  instruments: Set<ObservableInstrument>;\n}\n\n/**\n * An internal interface for managing ObservableCallbacks.\n *\n * Every registered callback associated with a set of instruments are be evaluated\n * exactly once during collection prior to reading data for that instrument.\n */\nexport class ObservableRegistry {\n  private _callbacks: ObservableCallbackRecord[] = [];\n  private _batchCallbacks: BatchObservableCallbackRecord[] = [];\n\n  addCallback(callback: ObservableCallback, instrument: ObservableInstrument) {\n    const idx = this._findCallback(callback, instrument);\n    if (idx >= 0) {\n      return;\n    }\n    this._callbacks.push({ callback, instrument });\n  }\n\n  removeCallback(\n    callback: ObservableCallback,\n    instrument: ObservableInstrument\n  ) {\n    const idx = this._findCallback(callback, instrument);\n    if (idx < 0) {\n      return;\n    }\n    this._callbacks.splice(idx, 1);\n  }\n\n  addBatchCallback(\n    callback: BatchObservableCallback,\n    instruments: Observable[]\n  ) {\n    // Create a set of unique instruments.\n    const observableInstruments = new Set(\n      instruments.filter(isObservableInstrument)\n    );\n    if (observableInstruments.size === 0) {\n      diag.error(\n        'BatchObservableCallback is not associated with valid instruments',\n        instruments\n      );\n      return;\n    }\n    const idx = this._findBatchCallback(callback, observableInstruments);\n    if (idx >= 0) {\n      return;\n    }\n    this._batchCallbacks.push({ callback, instruments: observableInstruments });\n  }\n\n  removeBatchCallback(\n    callback: BatchObservableCallback,\n    instruments: Observable[]\n  ) {\n    // Create a set of unique instruments.\n    const observableInstruments = new Set(\n      instruments.filter(isObservableInstrument)\n    );\n    const idx = this._findBatchCallback(callback, observableInstruments);\n    if (idx < 0) {\n      return;\n    }\n    this._batchCallbacks.splice(idx, 1);\n  }\n\n  /**\n   * @returns a promise of rejected reasons for invoking callbacks.\n   */\n  async observe(\n    collectionTime: HrTime,\n    timeoutMillis?: number\n  ): Promise<unknown[]> {\n    const callbackFutures = this._observeCallbacks(\n      collectionTime,\n      timeoutMillis\n    );\n    const batchCallbackFutures = this._observeBatchCallbacks(\n      collectionTime,\n      timeoutMillis\n    );\n\n    const results = await PromiseAllSettled([\n      ...callbackFutures,\n      ...batchCallbackFutures,\n    ]);\n\n    const rejections = results\n      .filter(isPromiseAllSettledRejectionResult)\n      .map(it => it.reason);\n    return rejections;\n  }\n\n  private _observeCallbacks(observationTime: HrTime, timeoutMillis?: number) {\n    return this._callbacks.map(async ({ callback, instrument }) => {\n      const observableResult = new ObservableResultImpl(\n        instrument._descriptor.name,\n        instrument._descriptor.valueType\n      );\n      let callPromise: Promise<void> = Promise.resolve(\n        callback(observableResult)\n      );\n      if (timeoutMillis != null) {\n        callPromise = callWithTimeout(callPromise, timeoutMillis);\n      }\n      await callPromise;\n      instrument._metricStorages.forEach(metricStorage => {\n        metricStorage.record(observableResult._buffer, observationTime);\n      });\n    });\n  }\n\n  private _observeBatchCallbacks(\n    observationTime: HrTime,\n    timeoutMillis?: number\n  ) {\n    return this._batchCallbacks.map(async ({ callback, instruments }) => {\n      const observableResult = new BatchObservableResultImpl();\n      let callPromise: Promise<void> = Promise.resolve(\n        callback(observableResult)\n      );\n      if (timeoutMillis != null) {\n        callPromise = callWithTimeout(callPromise, timeoutMillis);\n      }\n      await callPromise;\n      instruments.forEach(instrument => {\n        const buffer = observableResult._buffer.get(instrument);\n        if (buffer == null) {\n          return;\n        }\n        instrument._metricStorages.forEach(metricStorage => {\n          metricStorage.record(buffer, observationTime);\n        });\n      });\n    });\n  }\n\n  private _findCallback(\n    callback: ObservableCallback,\n    instrument: ObservableInstrument\n  ) {\n    return this._callbacks.findIndex(record => {\n      return record.callback === callback && record.instrument === instrument;\n    });\n  }\n\n  private _findBatchCallback(\n    callback: BatchObservableCallback,\n    instruments: Set<ObservableInstrument>\n  ) {\n    return this._batchCallbacks.findIndex(record => {\n      return (\n        record.callback === callback &&\n        setEquals(record.instruments, instruments)\n      );\n    });\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Context, HrTime, Attributes } from '@opentelemetry/api';\nimport { WritableMetricStorage } from './WritableMetricStorage';\nimport { Accumulation, Aggregator } from '../aggregator/types';\nimport { InstrumentDescriptor } from '../InstrumentDescriptor';\nimport { IAttributesProcessor } from '../view/AttributesProcessor';\nimport { MetricStorage } from './MetricStorage';\nimport { MetricData } from '../export/MetricData';\nimport { DeltaMetricProcessor } from './DeltaMetricProcessor';\nimport { TemporalMetricProcessor } from './TemporalMetricProcessor';\nimport { Maybe } from '../utils';\nimport { MetricCollectorHandle } from './MetricCollector';\n\n/**\n * Internal interface.\n *\n * Stores and aggregates {@link MetricData} for synchronous instruments.\n */\nexport class SyncMetricStorage<T extends Maybe<Accumulation>>\n  extends MetricStorage\n  implements WritableMetricStorage\n{\n  private _deltaMetricStorage: DeltaMetricProcessor<T>;\n  private _temporalMetricStorage: TemporalMetricProcessor<T>;\n\n  constructor(\n    instrumentDescriptor: InstrumentDescriptor,\n    aggregator: Aggregator<T>,\n    private _attributesProcessor: IAttributesProcessor,\n    collectorHandles: MetricCollectorHandle[],\n    private _aggregationCardinalityLimit?: number\n  ) {\n    super(instrumentDescriptor);\n    this._deltaMetricStorage = new DeltaMetricProcessor(\n      aggregator,\n      this._aggregationCardinalityLimit\n    );\n    this._temporalMetricStorage = new TemporalMetricProcessor(\n      aggregator,\n      collectorHandles\n    );\n  }\n\n  record(\n    value: number,\n    attributes: Attributes,\n    context: Context,\n    recordTime: HrTime\n  ) {\n    attributes = this._attributesProcessor.process(attributes, context);\n    this._deltaMetricStorage.record(value, attributes, context, recordTime);\n  }\n\n  /**\n   * Collects the metrics from this storage.\n   *\n   * Note: This is a stateful operation and may reset any interval-related\n   * state for the MetricCollector.\n   */\n  collect(\n    collector: MetricCollectorHandle,\n    collectionTime: HrTime\n  ): Maybe<MetricData> {\n    const accumulations = this._deltaMetricStorage.collect();\n\n    return this._temporalMetricStorage.buildMetrics(\n      collector,\n      this._instrumentDescriptor,\n      accumulations,\n      collectionTime\n    );\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Context, Attributes } from '@opentelemetry/api';\n\n/**\n * The {@link AttributesProcessor} is responsible for customizing which\n * attribute(s) are to be reported as metrics dimension(s) and adding\n * additional dimension(s) from the {@link Context}.\n */\nexport interface IAttributesProcessor {\n  /**\n   * Process the metric instrument attributes.\n   *\n   * @param incoming The metric instrument attributes.\n   * @param context The active context when the instrument is synchronous.\n   * `undefined` otherwise.\n   */\n  process: (incoming: Attributes, context?: Context) => Attributes;\n}\n\nclass NoopAttributesProcessor implements IAttributesProcessor {\n  process(incoming: Attributes, _context?: Context) {\n    return incoming;\n  }\n}\n\nclass MultiAttributesProcessor implements IAttributesProcessor {\n  constructor(private readonly _processors: IAttributesProcessor[]) {}\n  process(incoming: Attributes, context?: Context): Attributes {\n    let filteredAttributes = incoming;\n    for (const processor of this._processors) {\n      filteredAttributes = processor.process(filteredAttributes, context);\n    }\n    return filteredAttributes;\n  }\n}\n\nclass AllowListProcessor implements IAttributesProcessor {\n  constructor(private _allowedAttributeNames: string[]) {}\n\n  process(incoming: Attributes, _context?: Context): Attributes {\n    const filteredAttributes: Attributes = {};\n    Object.keys(incoming)\n      .filter(attributeName =>\n        this._allowedAttributeNames.includes(attributeName)\n      )\n      .forEach(\n        attributeName =>\n          (filteredAttributes[attributeName] = incoming[attributeName])\n      );\n    return filteredAttributes;\n  }\n}\n\nclass DenyListProcessor implements IAttributesProcessor {\n  constructor(private _deniedAttributeNames: string[]) {}\n\n  process(incoming: Attributes, _context?: Context): Attributes {\n    const filteredAttributes: Attributes = {};\n    Object.keys(incoming)\n      .filter(\n        attributeName => !this._deniedAttributeNames.includes(attributeName)\n      )\n      .forEach(\n        attributeName =>\n          (filteredAttributes[attributeName] = incoming[attributeName])\n      );\n    return filteredAttributes;\n  }\n}\n\n/**\n * @internal\n *\n * Create an {@link IAttributesProcessor} that acts as a simple pass-through for attributes.\n */\nexport function createNoopAttributesProcessor(): IAttributesProcessor {\n  return NOOP;\n}\n\n/**\n * @internal\n *\n * Create an {@link IAttributesProcessor} that applies all processors from the provided list in order.\n *\n * @param processors Processors to apply in order.\n */\nexport function createMultiAttributesProcessor(\n  processors: IAttributesProcessor[]\n): IAttributesProcessor {\n  return new MultiAttributesProcessor(processors);\n}\n\n/**\n * Create an {@link IAttributesProcessor} that filters by allowed attribute names and drops any names that are not in the\n * allow list.\n */\nexport function createAllowListAttributesProcessor(\n  attributeAllowList: string[]\n): IAttributesProcessor {\n  return new AllowListProcessor(attributeAllowList);\n}\n\n/**\n * Create an {@link IAttributesProcessor} that drops attributes based on the names provided in the deny list\n */\nexport function createDenyListAttributesProcessor(\n  attributeDenyList: string[]\n): IAttributesProcessor {\n  return new DenyListProcessor(attributeDenyList);\n}\n\nconst NOOP = new NoopAttributesProcessor();\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { HrTime } from '@opentelemetry/api';\nimport { InstrumentationScope } from '@opentelemetry/core';\nimport { MetricCollectOptions } from '../export/MetricProducer';\nimport { ScopeMetrics } from '../export/MetricData';\nimport {\n  createInstrumentDescriptorWithView,\n  InstrumentDescriptor,\n} from '../InstrumentDescriptor';\nimport { Meter } from '../Meter';\nimport { isNotNullish, Maybe } from '../utils';\nimport { AsyncMetricStorage } from './AsyncMetricStorage';\nimport { MeterProviderSharedState } from './MeterProviderSharedState';\nimport { MetricCollectorHandle } from './MetricCollector';\nimport { MetricStorageRegistry } from './MetricStorageRegistry';\nimport { MultiMetricStorage } from './MultiWritableMetricStorage';\nimport { ObservableRegistry } from './ObservableRegistry';\nimport { SyncMetricStorage } from './SyncMetricStorage';\nimport { Accumulation, Aggregator } from '../aggregator/types';\nimport {\n  createNoopAttributesProcessor,\n  IAttributesProcessor,\n} from '../view/AttributesProcessor';\nimport { MetricStorage } from './MetricStorage';\n\n/**\n * An internal record for shared meter provider states.\n */\nexport class MeterSharedState {\n  metricStorageRegistry = new MetricStorageRegistry();\n  observableRegistry = new ObservableRegistry();\n  meter: Meter;\n\n  constructor(\n    private _meterProviderSharedState: MeterProviderSharedState,\n    private _instrumentationScope: InstrumentationScope\n  ) {\n    this.meter = new Meter(this);\n  }\n\n  registerMetricStorage(descriptor: InstrumentDescriptor) {\n    const storages = this._registerMetricStorage(descriptor, SyncMetricStorage);\n\n    if (storages.length === 1) {\n      return storages[0];\n    }\n    return new MultiMetricStorage(storages);\n  }\n\n  registerAsyncMetricStorage(descriptor: InstrumentDescriptor) {\n    const storages = this._registerMetricStorage(\n      descriptor,\n      AsyncMetricStorage\n    );\n\n    return storages;\n  }\n\n  /**\n   * @param collector opaque handle of {@link MetricCollector} which initiated the collection.\n   * @param collectionTime the HrTime at which the collection was initiated.\n   * @param options options for collection.\n   * @returns the list of metric data collected.\n   */\n  async collect(\n    collector: MetricCollectorHandle,\n    collectionTime: HrTime,\n    options?: MetricCollectOptions\n  ): Promise<ScopeMetricsResult | null> {\n    /**\n     * 1. Call all observable callbacks first.\n     * 2. Collect metric result for the collector.\n     */\n    const errors = await this.observableRegistry.observe(\n      collectionTime,\n      options?.timeoutMillis\n    );\n    const storages = this.metricStorageRegistry.getStorages(collector);\n\n    // prevent more allocations if there are no storages.\n    if (storages.length === 0) {\n      return null;\n    }\n\n    const metricDataList = storages\n      .map(metricStorage => {\n        return metricStorage.collect(collector, collectionTime);\n      })\n      .filter(isNotNullish);\n\n    // skip this scope if no data was collected (storage created, but no data observed)\n    if (metricDataList.length === 0) {\n      return { errors };\n    }\n\n    return {\n      scopeMetrics: {\n        scope: this._instrumentationScope,\n        metrics: metricDataList,\n      },\n      errors,\n    };\n  }\n\n  private _registerMetricStorage<\n    MetricStorageType extends MetricStorageConstructor,\n    R extends InstanceType<MetricStorageType>,\n  >(\n    descriptor: InstrumentDescriptor,\n    MetricStorageType: MetricStorageType\n  ): R[] {\n    const views = this._meterProviderSharedState.viewRegistry.findViews(\n      descriptor,\n      this._instrumentationScope\n    );\n    let storages = views.map(view => {\n      const viewDescriptor = createInstrumentDescriptorWithView(\n        view,\n        descriptor\n      );\n      const compatibleStorage =\n        this.metricStorageRegistry.findOrUpdateCompatibleStorage<R>(\n          viewDescriptor\n        );\n      if (compatibleStorage != null) {\n        return compatibleStorage;\n      }\n      const aggregator = view.aggregation.createAggregator(viewDescriptor);\n      const viewStorage = new MetricStorageType(\n        viewDescriptor,\n        aggregator,\n        view.attributesProcessor,\n        this._meterProviderSharedState.metricCollectors,\n        view.aggregationCardinalityLimit\n      ) as R;\n      this.metricStorageRegistry.register(viewStorage);\n      return viewStorage;\n    });\n\n    // Fallback to the per-collector aggregations if no view is configured for the instrument.\n    if (storages.length === 0) {\n      const perCollectorAggregations =\n        this._meterProviderSharedState.selectAggregations(descriptor.type);\n      const collectorStorages = perCollectorAggregations.map(\n        ([collector, aggregation]) => {\n          const compatibleStorage =\n            this.metricStorageRegistry.findOrUpdateCompatibleCollectorStorage<R>(\n              collector,\n              descriptor\n            );\n          if (compatibleStorage != null) {\n            return compatibleStorage;\n          }\n\n          const aggregator = aggregation.createAggregator(descriptor);\n          const cardinalityLimit = collector.selectCardinalityLimit(\n            descriptor.type\n          );\n          const storage = new MetricStorageType(\n            descriptor,\n            aggregator,\n            createNoopAttributesProcessor(),\n            [collector],\n            cardinalityLimit\n          ) as R;\n          this.metricStorageRegistry.registerForCollector(collector, storage);\n          return storage;\n        }\n      );\n      storages = storages.concat(collectorStorages);\n    }\n\n    return storages;\n  }\n}\n\ninterface ScopeMetricsResult {\n  scopeMetrics?: ScopeMetrics;\n  errors: unknown[];\n}\n\ninterface MetricStorageConstructor {\n  new (\n    instrumentDescriptor: InstrumentDescriptor,\n    aggregator: Aggregator<Maybe<Accumulation>>,\n    attributesProcessor: IAttributesProcessor,\n    collectors: MetricCollectorHandle[],\n    aggregationCardinalityLimit?: number\n  ): MetricStorage;\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { InstrumentationScope } from '@opentelemetry/core';\nimport { Resource } from '@opentelemetry/resources';\nimport { instrumentationScopeId } from '../utils';\nimport { ViewRegistry } from '../view/ViewRegistry';\nimport { MeterSharedState } from './MeterSharedState';\nimport { MetricCollector, MetricCollectorHandle } from './MetricCollector';\nimport { toAggregation } from '../view/AggregationOption';\nimport { Aggregation } from '../view/Aggregation';\nimport { InstrumentType } from '../export/MetricData';\n\n/**\n * An internal record for shared meter provider states.\n */\nexport class MeterProviderSharedState {\n  viewRegistry = new ViewRegistry();\n\n  metricCollectors: MetricCollector[] = [];\n\n  meterSharedStates: Map<string, MeterSharedState> = new Map();\n\n  constructor(public resource: Resource) {}\n\n  getMeterSharedState(instrumentationScope: InstrumentationScope) {\n    const id = instrumentationScopeId(instrumentationScope);\n    let meterSharedState = this.meterSharedStates.get(id);\n    if (meterSharedState == null) {\n      meterSharedState = new MeterSharedState(this, instrumentationScope);\n      this.meterSharedStates.set(id, meterSharedState);\n    }\n    return meterSharedState;\n  }\n\n  selectAggregations(instrumentType: InstrumentType) {\n    const result: [MetricCollectorHandle, Aggregation][] = [];\n    for (const collector of this.metricCollectors) {\n      result.push([\n        collector,\n        toAggregation(collector.selectAggregation(instrumentType)),\n      ]);\n    }\n    return result;\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { millisToHrTime } from '@opentelemetry/core';\nimport { AggregationTemporalitySelector } from '../export/AggregationSelector';\nimport {\n  CollectionResult,\n  InstrumentType,\n  ScopeMetrics,\n} from '../export/MetricData';\nimport { MetricCollectOptions, MetricProducer } from '../export/MetricProducer';\nimport { IMetricReader } from '../export/MetricReader';\nimport { ForceFlushOptions, ShutdownOptions } from '../types';\nimport { MeterProviderSharedState } from './MeterProviderSharedState';\n\n/**\n * An internal opaque interface that the MetricReader receives as\n * MetricProducer. It acts as the storage key to the internal metric stream\n * state for each MetricReader.\n */\nexport class MetricCollector implements MetricProducer {\n  constructor(\n    private _sharedState: MeterProviderSharedState,\n    private _metricReader: IMetricReader\n  ) {}\n\n  async collect(options?: MetricCollectOptions): Promise<CollectionResult> {\n    const collectionTime = millisToHrTime(Date.now());\n    const scopeMetrics: ScopeMetrics[] = [];\n    const errors: unknown[] = [];\n\n    const meterCollectionPromises = Array.from(\n      this._sharedState.meterSharedStates.values()\n    ).map(async meterSharedState => {\n      const current = await meterSharedState.collect(\n        this,\n        collectionTime,\n        options\n      );\n\n      // only add scope metrics if available\n      if (current?.scopeMetrics != null) {\n        scopeMetrics.push(current.scopeMetrics);\n      }\n\n      // only add errors if available\n      if (current?.errors != null) {\n        errors.push(...current.errors);\n      }\n    });\n    await Promise.all(meterCollectionPromises);\n\n    return {\n      resourceMetrics: {\n        resource: this._sharedState.resource,\n        scopeMetrics: scopeMetrics,\n      },\n      errors: errors,\n    };\n  }\n\n  /**\n   * Delegates for MetricReader.forceFlush.\n   */\n  async forceFlush(options?: ForceFlushOptions): Promise<void> {\n    await this._metricReader.forceFlush(options);\n  }\n\n  /**\n   * Delegates for MetricReader.shutdown.\n   */\n  async shutdown(options?: ShutdownOptions): Promise<void> {\n    await this._metricReader.shutdown(options);\n  }\n\n  selectAggregationTemporality(instrumentType: InstrumentType) {\n    return this._metricReader.selectAggregationTemporality(instrumentType);\n  }\n\n  selectAggregation(instrumentType: InstrumentType) {\n    return this._metricReader.selectAggregation(instrumentType);\n  }\n\n  /**\n   * Select the cardinality limit for the given {@link InstrumentType} for this\n   * collector.\n   */\n  selectCardinalityLimit(instrumentType: InstrumentType): number {\n    return this._metricReader.selectCardinalityLimit?.(instrumentType) ?? 2000;\n  }\n}\n\n/**\n * An internal interface for MetricCollector. Exposes the necessary\n * information for metric collection.\n */\nexport interface MetricCollectorHandle {\n  selectAggregationTemporality: AggregationTemporalitySelector;\n  selectCardinalityLimit(instrumentType: InstrumentType): number;\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// https://tc39.es/proposal-regex-escaping\n// escape ^ $ \\ .  + ? ( ) [ ] { } |\n// do not need to escape * as we interpret it as wildcard\nconst ESCAPE = /[\\^$\\\\.+?()[\\]{}|]/g;\n\nexport interface Predicate {\n  match(str: string): boolean;\n}\n\n/**\n * Wildcard pattern predicate, supports patterns like `*`, `foo*`, `*bar`.\n */\nexport class PatternPredicate implements Predicate {\n  private _matchAll: boolean;\n  private _regexp: RegExp;\n\n  constructor(pattern: string) {\n    if (pattern === '*') {\n      this._matchAll = true;\n      this._regexp = /.*/;\n    } else {\n      this._matchAll = false;\n      this._regexp = new RegExp(PatternPredicate.escapePattern(pattern));\n    }\n  }\n\n  match(str: string): boolean {\n    if (this._matchAll) {\n      return true;\n    }\n\n    return this._regexp.test(str);\n  }\n\n  static escapePattern(pattern: string): string {\n    return `^${pattern.replace(ESCAPE, '\\\\$&').replace('*', '.*')}$`;\n  }\n\n  static hasWildcard(pattern: string): boolean {\n    return pattern.includes('*');\n  }\n}\n\nexport class ExactPredicate implements Predicate {\n  private _matchAll: boolean;\n  private _pattern?: string;\n\n  constructor(pattern?: string) {\n    this._matchAll = pattern === undefined;\n    this._pattern = pattern;\n  }\n\n  match(str: string): boolean {\n    if (this._matchAll) {\n      return true;\n    }\n    if (str === this._pattern) {\n      return true;\n    }\n    return false;\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ExactPredicate, PatternPredicate, Predicate } from './Predicate';\nimport { InstrumentType } from '../export/MetricData';\n\nexport interface InstrumentSelectorCriteria {\n  name?: string;\n  type?: InstrumentType;\n  unit?: string;\n}\n\nexport class InstrumentSelector {\n  private _nameFilter: Predicate;\n  private _type?: InstrumentType;\n  private _unitFilter: Predicate;\n\n  constructor(criteria?: InstrumentSelectorCriteria) {\n    this._nameFilter = new PatternPredicate(criteria?.name ?? '*');\n    this._type = criteria?.type;\n    this._unitFilter = new ExactPredicate(criteria?.unit);\n  }\n\n  getType() {\n    return this._type;\n  }\n\n  getNameFilter() {\n    return this._nameFilter;\n  }\n\n  getUnitFilter() {\n    return this._unitFilter;\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ExactPredicate, Predicate } from './Predicate';\n\nexport interface MeterSelectorCriteria {\n  name?: string;\n  version?: string;\n  schemaUrl?: string;\n}\n\nexport class MeterSelector {\n  private _nameFilter: Predicate;\n  private _versionFilter: Predicate;\n  private _schemaUrlFilter: Predicate;\n\n  constructor(criteria?: MeterSelectorCriteria) {\n    this._nameFilter = new ExactPredicate(criteria?.name);\n    this._versionFilter = new ExactPredicate(criteria?.version);\n    this._schemaUrlFilter = new ExactPredicate(criteria?.schemaUrl);\n  }\n\n  getNameFilter() {\n    return this._nameFilter;\n  }\n\n  /**\n   * TODO: semver filter? no spec yet.\n   */\n  getVersionFilter() {\n    return this._versionFilter;\n  }\n\n  getSchemaUrlFilter() {\n    return this._schemaUrlFilter;\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { PatternPredicate } from './Predicate';\nimport {\n  createMultiAttributesProcessor,\n  createNoopAttributesProcessor,\n  IAttributesProcessor,\n} from './AttributesProcessor';\nimport { InstrumentSelector } from './InstrumentSelector';\nimport { MeterSelector } from './MeterSelector';\nimport { Aggregation } from './Aggregation';\nimport {\n  AggregationOption,\n  AggregationType,\n  toAggregation,\n} from './AggregationOption';\nimport { InstrumentType } from '../export/MetricData';\n\nexport type ViewOptions = {\n  /**\n   *  Alters the metric stream:\n   *  This will be used as the name of the metrics stream.\n   *  If not provided, the original Instrument name will be used.\n   */\n  name?: string;\n  /**\n   * Alters the metric stream:\n   * This will be used as the description of the metrics stream.\n   * If not provided, the original Instrument description will be used by default.\n   *\n   * @example <caption>changes the description of all selected instruments to 'sample description'</caption>\n   * description: 'sample description'\n   */\n  description?: string;\n  /**\n   * Alters the metric stream:\n   * If provided, the attributes will be modified as defined by the processors in the list. Processors are applied\n   * in the order they're provided.\n   * If not provided, all attribute keys will be used by default.\n   *\n   * @example <caption>drops all attributes with top-level keys except for 'myAttr' and 'myOtherAttr'</caption>\n   * attributesProcessors: [createAllowListProcessor(['myAttr', 'myOtherAttr'])]\n   * @example <caption>drops all attributes</caption>\n   * attributesProcessors: [createAllowListProcessor([])]\n   * @example <caption>allows all attributes except for 'myAttr'</caption>\n   * attributesProcessors: [createDenyListProcessor(['myAttr']]\n   */\n  attributesProcessors?: IAttributesProcessor[];\n  /**\n   * Alters the metric stream:\n   * Alters the Aggregation of the metric stream.\n   *\n   * @example <caption>changes the aggregation of the selected instrument(s) to ExplicitBucketHistogramAggregation</caption>\n   * aggregation: { type: AggregationType.EXPLICIT_BUCKET_HISTOGRAM, options: { boundaries: [1, 10, 100] } }\n   * @example <caption>changes the aggregation of the selected instrument(s) to LastValueAggregation</caption>\n   * aggregation: { type: AggregationType.LAST_VALUE, options: { boundaries: [1, 10, 100] } }\n   */\n  aggregation?: AggregationOption;\n  /**\n   * Alters the metric stream:\n   * Sets a limit on the number of unique attribute combinations (cardinality) that can be aggregated.\n   * If not provided, the default limit will be used.\n   *\n   * @example <caption>sets the cardinality limit to 1000</caption>\n   * aggregationCardinalityLimit: 1000\n   */\n  aggregationCardinalityLimit?: number;\n  /**\n   * Instrument selection criteria:\n   * The original type of the Instrument(s).\n   *\n   * @example <caption>selects all counters</caption>\n   * instrumentType: InstrumentType.COUNTER\n   * @example <caption>selects all histograms</caption>\n   * instrumentType: InstrumentType.HISTOGRAM\n   */\n  instrumentType?: InstrumentType;\n  /**\n   * Instrument selection criteria:\n   * Original name of the Instrument(s) with wildcard support.\n   *\n   * @example <caption>select all instruments</caption>\n   * instrumentName: '*'\n   * @example <caption>select all instruments starting with 'my.instruments.'</caption>\n   * instrumentName: 'my.instruments.*'\n   * @example <caption>select all instruments named 'my.instrument.requests' exactly</caption>\n   * instrumentName: 'my.instruments.requests'\n   */\n  instrumentName?: string;\n  /**\n   * Instrument selection criteria:\n   * The unit of the Instrument(s).\n   *\n   * @example <caption>select all instruments with unit 'ms'</caption>\n   * instrumentUnit: 'ms'\n   */\n  instrumentUnit?: string;\n  /**\n   * Instrument selection criteria:\n   * The name of the Meter. No wildcard support, name must match the meter exactly.\n   *\n   * @example <caption>select all meters named 'example.component.app' exactly</caption>\n   * meterName: 'example.component.app'\n   */\n  meterName?: string;\n  /**\n   * Instrument selection criteria:\n   * The version of the Meter. No wildcard support, version must match exactly.\n   *\n   * @example\n   * meterVersion: '1.0.1'\n   */\n  meterVersion?: string;\n  /**\n   * Instrument selection criteria:\n   * The schema URL of the Meter. No wildcard support, schema URL must match exactly.\n   *\n   * @example <caption>Select all meters with schema URL 'https://example.com/schema' exactly.</caption>\n   * meterSchemaUrl: 'https://example.com/schema'\n   */\n  meterSchemaUrl?: string;\n};\n\nfunction isSelectorNotProvided(options: ViewOptions): boolean {\n  return (\n    options.instrumentName == null &&\n    options.instrumentType == null &&\n    options.instrumentUnit == null &&\n    options.meterName == null &&\n    options.meterVersion == null &&\n    options.meterSchemaUrl == null\n  );\n}\n\nfunction validateViewOptions(viewOptions: ViewOptions) {\n  // If no criteria is provided, the SDK SHOULD treat it as an error.\n  // It is recommended that the SDK implementations fail fast.\n  if (isSelectorNotProvided(viewOptions)) {\n    throw new Error('Cannot create view with no selector arguments supplied');\n  }\n\n  // the SDK SHOULD NOT allow Views with a specified name to be declared with instrument selectors that\n  // may select more than one instrument (e.g. wild card instrument name) in the same Meter.\n  if (\n    viewOptions.name != null &&\n    (viewOptions?.instrumentName == null ||\n      PatternPredicate.hasWildcard(viewOptions.instrumentName))\n  ) {\n    throw new Error(\n      'Views with a specified name must be declared with an instrument selector that selects at most one instrument per meter.'\n    );\n  }\n}\n\n/**\n * Can be passed to a {@link MeterProvider} to select instruments and alter their metric stream.\n */\nexport class View {\n  readonly name?: string;\n  readonly description?: string;\n  readonly aggregation: Aggregation;\n  readonly attributesProcessor: IAttributesProcessor;\n  readonly instrumentSelector: InstrumentSelector;\n  readonly meterSelector: MeterSelector;\n  readonly aggregationCardinalityLimit?: number;\n\n  /**\n   * Create a new {@link View} instance.\n   *\n   * Parameters can be categorized as two types:\n   *  Instrument selection criteria: Used to describe the instrument(s) this view will be applied to.\n   *  Will be treated as additive (the Instrument has to meet all the provided criteria to be selected).\n   *\n   *  Metric stream altering: Alter the metric stream of instruments selected by instrument selection criteria.\n   *\n   * @param viewOptions {@link ViewOptions} for altering the metric stream and instrument selection.\n   * @param viewOptions.name\n   * Alters the metric stream:\n   *  This will be used as the name of the metrics stream.\n   *  If not provided, the original Instrument name will be used.\n   * @param viewOptions.description\n   * Alters the metric stream:\n   *  This will be used as the description of the metrics stream.\n   *  If not provided, the original Instrument description will be used by default.\n   * @param viewOptions.attributesProcessors\n   * Alters the metric stream:\n   *  If provided, the attributes will be modified as defined by the added processors.\n   *  If not provided, all attribute keys will be used by default.\n   * @param viewOptions.aggregationCardinalityLimit\n   * Alters the metric stream:\n   *  Sets a limit on the number of unique attribute combinations (cardinality) that can be aggregated.\n   *  If not provided, the default limit of 2000 will be used.\n   * @param viewOptions.aggregation\n   * Alters the metric stream:\n   *  Alters the {@link Aggregation} of the metric stream.\n   * @param viewOptions.instrumentName\n   * Instrument selection criteria:\n   *  Original name of the Instrument(s) with wildcard support.\n   * @param viewOptions.instrumentType\n   * Instrument selection criteria:\n   *  The original type of the Instrument(s).\n   * @param viewOptions.instrumentUnit\n   * Instrument selection criteria:\n   *  The unit of the Instrument(s).\n   * @param viewOptions.meterName\n   * Instrument selection criteria:\n   *  The name of the Meter. No wildcard support, name must match the meter exactly.\n   * @param viewOptions.meterVersion\n   * Instrument selection criteria:\n   *  The version of the Meter. No wildcard support, version must match exactly.\n   * @param viewOptions.meterSchemaUrl\n   * Instrument selection criteria:\n   *  The schema URL of the Meter. No wildcard support, schema URL must match exactly.\n   *\n   * @example\n   * // Create a view that changes the Instrument 'my.instrument' to use to an\n   * // ExplicitBucketHistogramAggregation with the boundaries [20, 30, 40]\n   * new View({\n   *   aggregation: new ExplicitBucketHistogramAggregation([20, 30, 40]),\n   *   instrumentName: 'my.instrument'\n   * })\n   */\n  constructor(viewOptions: ViewOptions) {\n    validateViewOptions(viewOptions);\n\n    // Create multi-processor if attributesProcessors are defined.\n    if (viewOptions.attributesProcessors != null) {\n      this.attributesProcessor = createMultiAttributesProcessor(\n        viewOptions.attributesProcessors\n      );\n    } else {\n      this.attributesProcessor = createNoopAttributesProcessor();\n    }\n\n    this.name = viewOptions.name;\n    this.description = viewOptions.description;\n    this.aggregation = toAggregation(\n      viewOptions.aggregation ?? { type: AggregationType.DEFAULT }\n    );\n    this.instrumentSelector = new InstrumentSelector({\n      name: viewOptions.instrumentName,\n      type: viewOptions.instrumentType,\n      unit: viewOptions.instrumentUnit,\n    });\n    this.meterSelector = new MeterSelector({\n      name: viewOptions.meterName,\n      version: viewOptions.meterVersion,\n      schemaUrl: viewOptions.meterSchemaUrl,\n    });\n    this.aggregationCardinalityLimit = viewOptions.aggregationCardinalityLimit;\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  diag,\n  MeterProvider as IMeterProvider,\n  Meter as IMeter,\n  MeterOptions,\n  createNoopMeter,\n} from '@opentelemetry/api';\nimport { defaultResource, Resource } from '@opentelemetry/resources';\nimport { IMetricReader } from './export/MetricReader';\nimport { MeterProviderSharedState } from './state/MeterProviderSharedState';\nimport { MetricCollector } from './state/MetricCollector';\nimport { ForceFlushOptions, ShutdownOptions } from './types';\nimport { View, ViewOptions } from './view/View';\n\n/**\n * MeterProviderOptions provides an interface for configuring a MeterProvider.\n */\nexport interface MeterProviderOptions {\n  /** Resource associated with metric telemetry  */\n  resource?: Resource;\n  views?: ViewOptions[];\n  readers?: IMetricReader[];\n}\n\n/**\n * This class implements the {@link MeterProvider} interface.\n */\nexport class MeterProvider implements IMeterProvider {\n  private _sharedState: MeterProviderSharedState;\n  private _shutdown = false;\n\n  constructor(options?: MeterProviderOptions) {\n    this._sharedState = new MeterProviderSharedState(\n      options?.resource ?? defaultResource()\n    );\n    if (options?.views != null && options.views.length > 0) {\n      for (const viewOption of options.views) {\n        this._sharedState.viewRegistry.addView(new View(viewOption));\n      }\n    }\n\n    if (options?.readers != null && options.readers.length > 0) {\n      for (const metricReader of options.readers) {\n        const collector = new MetricCollector(this._sharedState, metricReader);\n        metricReader.setMetricProducer(collector);\n        this._sharedState.metricCollectors.push(collector);\n      }\n    }\n  }\n\n  /**\n   * Get a meter with the configuration of the MeterProvider.\n   */\n  getMeter(name: string, version = '', options: MeterOptions = {}): IMeter {\n    // https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/metrics/sdk.md#meter-creation\n    if (this._shutdown) {\n      diag.warn('A shutdown MeterProvider cannot provide a Meter');\n      return createNoopMeter();\n    }\n\n    return this._sharedState.getMeterSharedState({\n      name,\n      version,\n      schemaUrl: options.schemaUrl,\n    }).meter;\n  }\n\n  /**\n   * Shut down the MeterProvider and all registered\n   * MetricReaders.\n   *\n   * Returns a promise which is resolved when all flushes are complete.\n   */\n  async shutdown(options?: ShutdownOptions): Promise<void> {\n    if (this._shutdown) {\n      diag.warn('shutdown may only be called once per MeterProvider');\n      return;\n    }\n\n    this._shutdown = true;\n\n    await Promise.all(\n      this._sharedState.metricCollectors.map(collector => {\n        return collector.shutdown(options);\n      })\n    );\n  }\n\n  /**\n   * Notifies all registered MetricReaders to flush any buffered data.\n   *\n   * Returns a promise which is resolved when all flushes are complete.\n   */\n  async forceFlush(options?: ForceFlushOptions): Promise<void> {\n    // do not flush after shutdown\n    if (this._shutdown) {\n      diag.warn('invalid attempt to force flush after MeterProvider shutdown');\n      return;\n    }\n\n    await Promise.all(\n      this._sharedState.metricCollectors.map(collector => {\n        return collector.forceFlush(options);\n      })\n    );\n  }\n}\n"],
  "mappings": "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",
  "names": ["AggregationTemporality", "InstrumentType", "DataPointType", "AggregatorKind", "MAX_SCALE", "AggregationType", "context", "context", "context", "context"]
}
